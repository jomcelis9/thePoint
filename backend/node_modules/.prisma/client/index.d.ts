
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model appointment_status
 * 
 */
export type appointment_status = $Result.DefaultSelection<Prisma.$appointment_statusPayload>
/**
 * Model appointments
 * 
 */
export type appointments = $Result.DefaultSelection<Prisma.$appointmentsPayload>
/**
 * Model clinic_staff
 * 
 */
export type clinic_staff = $Result.DefaultSelection<Prisma.$clinic_staffPayload>
/**
 * Model clinic_staff_details
 * 
 */
export type clinic_staff_details = $Result.DefaultSelection<Prisma.$clinic_staff_detailsPayload>
/**
 * Model guardian
 * 
 */
export type guardian = $Result.DefaultSelection<Prisma.$guardianPayload>
/**
 * Model mode_of_payment
 * 
 */
export type mode_of_payment = $Result.DefaultSelection<Prisma.$mode_of_paymentPayload>
/**
 * Model patient_appointments
 * 
 */
export type patient_appointments = $Result.DefaultSelection<Prisma.$patient_appointmentsPayload>
/**
 * Model patient_conditions
 * 
 */
export type patient_conditions = $Result.DefaultSelection<Prisma.$patient_conditionsPayload>
/**
 * Model patient_details
 * 
 */
export type patient_details = $Result.DefaultSelection<Prisma.$patient_detailsPayload>
/**
 * Model patients
 * 
 */
export type patients = $Result.DefaultSelection<Prisma.$patientsPayload>
/**
 * Model payment
 * 
 */
export type payment = $Result.DefaultSelection<Prisma.$paymentPayload>
/**
 * Model recurrence
 * 
 */
export type recurrence = $Result.DefaultSelection<Prisma.$recurrencePayload>
/**
 * Model recurring_instances
 * 
 */
export type recurring_instances = $Result.DefaultSelection<Prisma.$recurring_instancesPayload>
/**
 * Model session
 * 
 */
export type session = $Result.DefaultSelection<Prisma.$sessionPayload>
/**
 * Model session_details
 * 
 */
export type session_details = $Result.DefaultSelection<Prisma.$session_detailsPayload>
/**
 * Model staff_role
 * 
 */
export type staff_role = $Result.DefaultSelection<Prisma.$staff_rolePayload>
/**
 * Model type_of_payment
 * 
 */
export type type_of_payment = $Result.DefaultSelection<Prisma.$type_of_paymentPayload>
/**
 * Model user_contacts
 * 
 */
export type user_contacts = $Result.DefaultSelection<Prisma.$user_contactsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Appointment_statuses
 * const appointment_statuses = await prisma.appointment_status.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Appointment_statuses
   * const appointment_statuses = await prisma.appointment_status.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.appointment_status`: Exposes CRUD operations for the **appointment_status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointment_statuses
    * const appointment_statuses = await prisma.appointment_status.findMany()
    * ```
    */
  get appointment_status(): Prisma.appointment_statusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointments`: Exposes CRUD operations for the **appointments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointments.findMany()
    * ```
    */
  get appointments(): Prisma.appointmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinic_staff`: Exposes CRUD operations for the **clinic_staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinic_staffs
    * const clinic_staffs = await prisma.clinic_staff.findMany()
    * ```
    */
  get clinic_staff(): Prisma.clinic_staffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinic_staff_details`: Exposes CRUD operations for the **clinic_staff_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinic_staff_details
    * const clinic_staff_details = await prisma.clinic_staff_details.findMany()
    * ```
    */
  get clinic_staff_details(): Prisma.clinic_staff_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guardian`: Exposes CRUD operations for the **guardian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guardians
    * const guardians = await prisma.guardian.findMany()
    * ```
    */
  get guardian(): Prisma.guardianDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mode_of_payment`: Exposes CRUD operations for the **mode_of_payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mode_of_payments
    * const mode_of_payments = await prisma.mode_of_payment.findMany()
    * ```
    */
  get mode_of_payment(): Prisma.mode_of_paymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient_appointments`: Exposes CRUD operations for the **patient_appointments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patient_appointments
    * const patient_appointments = await prisma.patient_appointments.findMany()
    * ```
    */
  get patient_appointments(): Prisma.patient_appointmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient_conditions`: Exposes CRUD operations for the **patient_conditions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patient_conditions
    * const patient_conditions = await prisma.patient_conditions.findMany()
    * ```
    */
  get patient_conditions(): Prisma.patient_conditionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient_details`: Exposes CRUD operations for the **patient_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patient_details
    * const patient_details = await prisma.patient_details.findMany()
    * ```
    */
  get patient_details(): Prisma.patient_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patients`: Exposes CRUD operations for the **patients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patients.findMany()
    * ```
    */
  get patients(): Prisma.patientsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.paymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurrence`: Exposes CRUD operations for the **recurrence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recurrences
    * const recurrences = await prisma.recurrence.findMany()
    * ```
    */
  get recurrence(): Prisma.recurrenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurring_instances`: Exposes CRUD operations for the **recurring_instances** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recurring_instances
    * const recurring_instances = await prisma.recurring_instances.findMany()
    * ```
    */
  get recurring_instances(): Prisma.recurring_instancesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.sessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session_details`: Exposes CRUD operations for the **session_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Session_details
    * const session_details = await prisma.session_details.findMany()
    * ```
    */
  get session_details(): Prisma.session_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staff_role`: Exposes CRUD operations for the **staff_role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff_roles
    * const staff_roles = await prisma.staff_role.findMany()
    * ```
    */
  get staff_role(): Prisma.staff_roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.type_of_payment`: Exposes CRUD operations for the **type_of_payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Type_of_payments
    * const type_of_payments = await prisma.type_of_payment.findMany()
    * ```
    */
  get type_of_payment(): Prisma.type_of_paymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_contacts`: Exposes CRUD operations for the **user_contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_contacts
    * const user_contacts = await prisma.user_contacts.findMany()
    * ```
    */
  get user_contacts(): Prisma.user_contactsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.1
   * Query Engine version: acc0b9dd43eb689cbd20c9470515d719db10d0b0
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    appointment_status: 'appointment_status',
    appointments: 'appointments',
    clinic_staff: 'clinic_staff',
    clinic_staff_details: 'clinic_staff_details',
    guardian: 'guardian',
    mode_of_payment: 'mode_of_payment',
    patient_appointments: 'patient_appointments',
    patient_conditions: 'patient_conditions',
    patient_details: 'patient_details',
    patients: 'patients',
    payment: 'payment',
    recurrence: 'recurrence',
    recurring_instances: 'recurring_instances',
    session: 'session',
    session_details: 'session_details',
    staff_role: 'staff_role',
    type_of_payment: 'type_of_payment',
    user_contacts: 'user_contacts',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "appointment_status" | "appointments" | "clinic_staff" | "clinic_staff_details" | "guardian" | "mode_of_payment" | "patient_appointments" | "patient_conditions" | "patient_details" | "patients" | "payment" | "recurrence" | "recurring_instances" | "session" | "session_details" | "staff_role" | "type_of_payment" | "user_contacts" | "users"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      appointment_status: {
        payload: Prisma.$appointment_statusPayload<ExtArgs>
        fields: Prisma.appointment_statusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.appointment_statusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointment_statusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.appointment_statusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointment_statusPayload>
          }
          findFirst: {
            args: Prisma.appointment_statusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointment_statusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.appointment_statusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointment_statusPayload>
          }
          findMany: {
            args: Prisma.appointment_statusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointment_statusPayload>[]
          }
          create: {
            args: Prisma.appointment_statusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointment_statusPayload>
          }
          createMany: {
            args: Prisma.appointment_statusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.appointment_statusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointment_statusPayload>[]
          }
          delete: {
            args: Prisma.appointment_statusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointment_statusPayload>
          }
          update: {
            args: Prisma.appointment_statusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointment_statusPayload>
          }
          deleteMany: {
            args: Prisma.appointment_statusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.appointment_statusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.appointment_statusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointment_statusPayload>[]
          }
          upsert: {
            args: Prisma.appointment_statusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointment_statusPayload>
          }
          aggregate: {
            args: Prisma.Appointment_statusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment_status>
          }
          groupBy: {
            args: Prisma.appointment_statusGroupByArgs<ExtArgs>
            result: $Utils.Optional<Appointment_statusGroupByOutputType>[]
          }
          count: {
            args: Prisma.appointment_statusCountArgs<ExtArgs>
            result: $Utils.Optional<Appointment_statusCountAggregateOutputType> | number
          }
        }
      }
      appointments: {
        payload: Prisma.$appointmentsPayload<ExtArgs>
        fields: Prisma.appointmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.appointmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.appointmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          findFirst: {
            args: Prisma.appointmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.appointmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          findMany: {
            args: Prisma.appointmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>[]
          }
          create: {
            args: Prisma.appointmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          createMany: {
            args: Prisma.appointmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.appointmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>[]
          }
          delete: {
            args: Prisma.appointmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          update: {
            args: Prisma.appointmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          deleteMany: {
            args: Prisma.appointmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.appointmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.appointmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>[]
          }
          upsert: {
            args: Prisma.appointmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          aggregate: {
            args: Prisma.AppointmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointments>
          }
          groupBy: {
            args: Prisma.appointmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.appointmentsCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentsCountAggregateOutputType> | number
          }
        }
      }
      clinic_staff: {
        payload: Prisma.$clinic_staffPayload<ExtArgs>
        fields: Prisma.clinic_staffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clinic_staffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clinic_staffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staffPayload>
          }
          findFirst: {
            args: Prisma.clinic_staffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clinic_staffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staffPayload>
          }
          findMany: {
            args: Prisma.clinic_staffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staffPayload>[]
          }
          create: {
            args: Prisma.clinic_staffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staffPayload>
          }
          createMany: {
            args: Prisma.clinic_staffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.clinic_staffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staffPayload>[]
          }
          delete: {
            args: Prisma.clinic_staffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staffPayload>
          }
          update: {
            args: Prisma.clinic_staffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staffPayload>
          }
          deleteMany: {
            args: Prisma.clinic_staffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clinic_staffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.clinic_staffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staffPayload>[]
          }
          upsert: {
            args: Prisma.clinic_staffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staffPayload>
          }
          aggregate: {
            args: Prisma.Clinic_staffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinic_staff>
          }
          groupBy: {
            args: Prisma.clinic_staffGroupByArgs<ExtArgs>
            result: $Utils.Optional<Clinic_staffGroupByOutputType>[]
          }
          count: {
            args: Prisma.clinic_staffCountArgs<ExtArgs>
            result: $Utils.Optional<Clinic_staffCountAggregateOutputType> | number
          }
        }
      }
      clinic_staff_details: {
        payload: Prisma.$clinic_staff_detailsPayload<ExtArgs>
        fields: Prisma.clinic_staff_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clinic_staff_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staff_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clinic_staff_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staff_detailsPayload>
          }
          findFirst: {
            args: Prisma.clinic_staff_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staff_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clinic_staff_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staff_detailsPayload>
          }
          findMany: {
            args: Prisma.clinic_staff_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staff_detailsPayload>[]
          }
          create: {
            args: Prisma.clinic_staff_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staff_detailsPayload>
          }
          createMany: {
            args: Prisma.clinic_staff_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.clinic_staff_detailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staff_detailsPayload>[]
          }
          delete: {
            args: Prisma.clinic_staff_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staff_detailsPayload>
          }
          update: {
            args: Prisma.clinic_staff_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staff_detailsPayload>
          }
          deleteMany: {
            args: Prisma.clinic_staff_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clinic_staff_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.clinic_staff_detailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staff_detailsPayload>[]
          }
          upsert: {
            args: Prisma.clinic_staff_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinic_staff_detailsPayload>
          }
          aggregate: {
            args: Prisma.Clinic_staff_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinic_staff_details>
          }
          groupBy: {
            args: Prisma.clinic_staff_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Clinic_staff_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.clinic_staff_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Clinic_staff_detailsCountAggregateOutputType> | number
          }
        }
      }
      guardian: {
        payload: Prisma.$guardianPayload<ExtArgs>
        fields: Prisma.guardianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.guardianFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guardianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guardianFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guardianPayload>
          }
          findFirst: {
            args: Prisma.guardianFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guardianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guardianFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guardianPayload>
          }
          findMany: {
            args: Prisma.guardianFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guardianPayload>[]
          }
          create: {
            args: Prisma.guardianCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guardianPayload>
          }
          createMany: {
            args: Prisma.guardianCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.guardianCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guardianPayload>[]
          }
          delete: {
            args: Prisma.guardianDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guardianPayload>
          }
          update: {
            args: Prisma.guardianUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guardianPayload>
          }
          deleteMany: {
            args: Prisma.guardianDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.guardianUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.guardianUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guardianPayload>[]
          }
          upsert: {
            args: Prisma.guardianUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guardianPayload>
          }
          aggregate: {
            args: Prisma.GuardianAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuardian>
          }
          groupBy: {
            args: Prisma.guardianGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuardianGroupByOutputType>[]
          }
          count: {
            args: Prisma.guardianCountArgs<ExtArgs>
            result: $Utils.Optional<GuardianCountAggregateOutputType> | number
          }
        }
      }
      mode_of_payment: {
        payload: Prisma.$mode_of_paymentPayload<ExtArgs>
        fields: Prisma.mode_of_paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mode_of_paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mode_of_paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mode_of_paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mode_of_paymentPayload>
          }
          findFirst: {
            args: Prisma.mode_of_paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mode_of_paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mode_of_paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mode_of_paymentPayload>
          }
          findMany: {
            args: Prisma.mode_of_paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mode_of_paymentPayload>[]
          }
          create: {
            args: Prisma.mode_of_paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mode_of_paymentPayload>
          }
          createMany: {
            args: Prisma.mode_of_paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mode_of_paymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mode_of_paymentPayload>[]
          }
          delete: {
            args: Prisma.mode_of_paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mode_of_paymentPayload>
          }
          update: {
            args: Prisma.mode_of_paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mode_of_paymentPayload>
          }
          deleteMany: {
            args: Prisma.mode_of_paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mode_of_paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mode_of_paymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mode_of_paymentPayload>[]
          }
          upsert: {
            args: Prisma.mode_of_paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mode_of_paymentPayload>
          }
          aggregate: {
            args: Prisma.Mode_of_paymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMode_of_payment>
          }
          groupBy: {
            args: Prisma.mode_of_paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mode_of_paymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.mode_of_paymentCountArgs<ExtArgs>
            result: $Utils.Optional<Mode_of_paymentCountAggregateOutputType> | number
          }
        }
      }
      patient_appointments: {
        payload: Prisma.$patient_appointmentsPayload<ExtArgs>
        fields: Prisma.patient_appointmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patient_appointmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_appointmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patient_appointmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_appointmentsPayload>
          }
          findFirst: {
            args: Prisma.patient_appointmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_appointmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patient_appointmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_appointmentsPayload>
          }
          findMany: {
            args: Prisma.patient_appointmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_appointmentsPayload>[]
          }
          create: {
            args: Prisma.patient_appointmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_appointmentsPayload>
          }
          createMany: {
            args: Prisma.patient_appointmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.patient_appointmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_appointmentsPayload>[]
          }
          delete: {
            args: Prisma.patient_appointmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_appointmentsPayload>
          }
          update: {
            args: Prisma.patient_appointmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_appointmentsPayload>
          }
          deleteMany: {
            args: Prisma.patient_appointmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patient_appointmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.patient_appointmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_appointmentsPayload>[]
          }
          upsert: {
            args: Prisma.patient_appointmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_appointmentsPayload>
          }
          aggregate: {
            args: Prisma.Patient_appointmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient_appointments>
          }
          groupBy: {
            args: Prisma.patient_appointmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Patient_appointmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.patient_appointmentsCountArgs<ExtArgs>
            result: $Utils.Optional<Patient_appointmentsCountAggregateOutputType> | number
          }
        }
      }
      patient_conditions: {
        payload: Prisma.$patient_conditionsPayload<ExtArgs>
        fields: Prisma.patient_conditionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patient_conditionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_conditionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patient_conditionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_conditionsPayload>
          }
          findFirst: {
            args: Prisma.patient_conditionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_conditionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patient_conditionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_conditionsPayload>
          }
          findMany: {
            args: Prisma.patient_conditionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_conditionsPayload>[]
          }
          create: {
            args: Prisma.patient_conditionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_conditionsPayload>
          }
          createMany: {
            args: Prisma.patient_conditionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.patient_conditionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_conditionsPayload>[]
          }
          delete: {
            args: Prisma.patient_conditionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_conditionsPayload>
          }
          update: {
            args: Prisma.patient_conditionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_conditionsPayload>
          }
          deleteMany: {
            args: Prisma.patient_conditionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patient_conditionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.patient_conditionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_conditionsPayload>[]
          }
          upsert: {
            args: Prisma.patient_conditionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_conditionsPayload>
          }
          aggregate: {
            args: Prisma.Patient_conditionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient_conditions>
          }
          groupBy: {
            args: Prisma.patient_conditionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Patient_conditionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.patient_conditionsCountArgs<ExtArgs>
            result: $Utils.Optional<Patient_conditionsCountAggregateOutputType> | number
          }
        }
      }
      patient_details: {
        payload: Prisma.$patient_detailsPayload<ExtArgs>
        fields: Prisma.patient_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patient_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patient_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_detailsPayload>
          }
          findFirst: {
            args: Prisma.patient_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patient_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_detailsPayload>
          }
          findMany: {
            args: Prisma.patient_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_detailsPayload>[]
          }
          create: {
            args: Prisma.patient_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_detailsPayload>
          }
          createMany: {
            args: Prisma.patient_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.patient_detailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_detailsPayload>[]
          }
          delete: {
            args: Prisma.patient_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_detailsPayload>
          }
          update: {
            args: Prisma.patient_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_detailsPayload>
          }
          deleteMany: {
            args: Prisma.patient_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patient_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.patient_detailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_detailsPayload>[]
          }
          upsert: {
            args: Prisma.patient_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_detailsPayload>
          }
          aggregate: {
            args: Prisma.Patient_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient_details>
          }
          groupBy: {
            args: Prisma.patient_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Patient_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.patient_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Patient_detailsCountAggregateOutputType> | number
          }
        }
      }
      patients: {
        payload: Prisma.$patientsPayload<ExtArgs>
        fields: Prisma.patientsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patientsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patientsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          findFirst: {
            args: Prisma.patientsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patientsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          findMany: {
            args: Prisma.patientsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>[]
          }
          create: {
            args: Prisma.patientsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          createMany: {
            args: Prisma.patientsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.patientsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>[]
          }
          delete: {
            args: Prisma.patientsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          update: {
            args: Prisma.patientsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          deleteMany: {
            args: Prisma.patientsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patientsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.patientsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>[]
          }
          upsert: {
            args: Prisma.patientsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          aggregate: {
            args: Prisma.PatientsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatients>
          }
          groupBy: {
            args: Prisma.patientsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientsGroupByOutputType>[]
          }
          count: {
            args: Prisma.patientsCountArgs<ExtArgs>
            result: $Utils.Optional<PatientsCountAggregateOutputType> | number
          }
        }
      }
      payment: {
        payload: Prisma.$paymentPayload<ExtArgs>
        fields: Prisma.paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findFirst: {
            args: Prisma.paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findMany: {
            args: Prisma.paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          create: {
            args: Prisma.paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          createMany: {
            args: Prisma.paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          delete: {
            args: Prisma.paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          update: {
            args: Prisma.paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          deleteMany: {
            args: Prisma.paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          upsert: {
            args: Prisma.paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      recurrence: {
        payload: Prisma.$recurrencePayload<ExtArgs>
        fields: Prisma.recurrenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.recurrenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurrencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.recurrenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurrencePayload>
          }
          findFirst: {
            args: Prisma.recurrenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurrencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.recurrenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurrencePayload>
          }
          findMany: {
            args: Prisma.recurrenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurrencePayload>[]
          }
          create: {
            args: Prisma.recurrenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurrencePayload>
          }
          createMany: {
            args: Prisma.recurrenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.recurrenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurrencePayload>[]
          }
          delete: {
            args: Prisma.recurrenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurrencePayload>
          }
          update: {
            args: Prisma.recurrenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurrencePayload>
          }
          deleteMany: {
            args: Prisma.recurrenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.recurrenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.recurrenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurrencePayload>[]
          }
          upsert: {
            args: Prisma.recurrenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurrencePayload>
          }
          aggregate: {
            args: Prisma.RecurrenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurrence>
          }
          groupBy: {
            args: Prisma.recurrenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurrenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.recurrenceCountArgs<ExtArgs>
            result: $Utils.Optional<RecurrenceCountAggregateOutputType> | number
          }
        }
      }
      recurring_instances: {
        payload: Prisma.$recurring_instancesPayload<ExtArgs>
        fields: Prisma.recurring_instancesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.recurring_instancesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurring_instancesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.recurring_instancesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurring_instancesPayload>
          }
          findFirst: {
            args: Prisma.recurring_instancesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurring_instancesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.recurring_instancesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurring_instancesPayload>
          }
          findMany: {
            args: Prisma.recurring_instancesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurring_instancesPayload>[]
          }
          create: {
            args: Prisma.recurring_instancesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurring_instancesPayload>
          }
          createMany: {
            args: Prisma.recurring_instancesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.recurring_instancesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurring_instancesPayload>[]
          }
          delete: {
            args: Prisma.recurring_instancesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurring_instancesPayload>
          }
          update: {
            args: Prisma.recurring_instancesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurring_instancesPayload>
          }
          deleteMany: {
            args: Prisma.recurring_instancesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.recurring_instancesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.recurring_instancesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurring_instancesPayload>[]
          }
          upsert: {
            args: Prisma.recurring_instancesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recurring_instancesPayload>
          }
          aggregate: {
            args: Prisma.Recurring_instancesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurring_instances>
          }
          groupBy: {
            args: Prisma.recurring_instancesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Recurring_instancesGroupByOutputType>[]
          }
          count: {
            args: Prisma.recurring_instancesCountArgs<ExtArgs>
            result: $Utils.Optional<Recurring_instancesCountAggregateOutputType> | number
          }
        }
      }
      session: {
        payload: Prisma.$sessionPayload<ExtArgs>
        fields: Prisma.sessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findFirst: {
            args: Prisma.sessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findMany: {
            args: Prisma.sessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          create: {
            args: Prisma.sessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          createMany: {
            args: Prisma.sessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          delete: {
            args: Prisma.sessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          update: {
            args: Prisma.sessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          deleteMany: {
            args: Prisma.sessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          upsert: {
            args: Prisma.sessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.sessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      session_details: {
        payload: Prisma.$session_detailsPayload<ExtArgs>
        fields: Prisma.session_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.session_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.session_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_detailsPayload>
          }
          findFirst: {
            args: Prisma.session_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.session_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_detailsPayload>
          }
          findMany: {
            args: Prisma.session_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_detailsPayload>[]
          }
          create: {
            args: Prisma.session_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_detailsPayload>
          }
          createMany: {
            args: Prisma.session_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.session_detailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_detailsPayload>[]
          }
          delete: {
            args: Prisma.session_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_detailsPayload>
          }
          update: {
            args: Prisma.session_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_detailsPayload>
          }
          deleteMany: {
            args: Prisma.session_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.session_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.session_detailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_detailsPayload>[]
          }
          upsert: {
            args: Prisma.session_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$session_detailsPayload>
          }
          aggregate: {
            args: Prisma.Session_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession_details>
          }
          groupBy: {
            args: Prisma.session_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Session_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.session_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Session_detailsCountAggregateOutputType> | number
          }
        }
      }
      staff_role: {
        payload: Prisma.$staff_rolePayload<ExtArgs>
        fields: Prisma.staff_roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.staff_roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staff_rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.staff_roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staff_rolePayload>
          }
          findFirst: {
            args: Prisma.staff_roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staff_rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.staff_roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staff_rolePayload>
          }
          findMany: {
            args: Prisma.staff_roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staff_rolePayload>[]
          }
          create: {
            args: Prisma.staff_roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staff_rolePayload>
          }
          createMany: {
            args: Prisma.staff_roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.staff_roleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staff_rolePayload>[]
          }
          delete: {
            args: Prisma.staff_roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staff_rolePayload>
          }
          update: {
            args: Prisma.staff_roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staff_rolePayload>
          }
          deleteMany: {
            args: Prisma.staff_roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.staff_roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.staff_roleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staff_rolePayload>[]
          }
          upsert: {
            args: Prisma.staff_roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$staff_rolePayload>
          }
          aggregate: {
            args: Prisma.Staff_roleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaff_role>
          }
          groupBy: {
            args: Prisma.staff_roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Staff_roleGroupByOutputType>[]
          }
          count: {
            args: Prisma.staff_roleCountArgs<ExtArgs>
            result: $Utils.Optional<Staff_roleCountAggregateOutputType> | number
          }
        }
      }
      type_of_payment: {
        payload: Prisma.$type_of_paymentPayload<ExtArgs>
        fields: Prisma.type_of_paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.type_of_paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.type_of_paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_paymentPayload>
          }
          findFirst: {
            args: Prisma.type_of_paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.type_of_paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_paymentPayload>
          }
          findMany: {
            args: Prisma.type_of_paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_paymentPayload>[]
          }
          create: {
            args: Prisma.type_of_paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_paymentPayload>
          }
          createMany: {
            args: Prisma.type_of_paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.type_of_paymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_paymentPayload>[]
          }
          delete: {
            args: Prisma.type_of_paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_paymentPayload>
          }
          update: {
            args: Prisma.type_of_paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_paymentPayload>
          }
          deleteMany: {
            args: Prisma.type_of_paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.type_of_paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.type_of_paymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_paymentPayload>[]
          }
          upsert: {
            args: Prisma.type_of_paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$type_of_paymentPayload>
          }
          aggregate: {
            args: Prisma.Type_of_paymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateType_of_payment>
          }
          groupBy: {
            args: Prisma.type_of_paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Type_of_paymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.type_of_paymentCountArgs<ExtArgs>
            result: $Utils.Optional<Type_of_paymentCountAggregateOutputType> | number
          }
        }
      }
      user_contacts: {
        payload: Prisma.$user_contactsPayload<ExtArgs>
        fields: Prisma.user_contactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_contactsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_contactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_contactsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_contactsPayload>
          }
          findFirst: {
            args: Prisma.user_contactsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_contactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_contactsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_contactsPayload>
          }
          findMany: {
            args: Prisma.user_contactsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_contactsPayload>[]
          }
          create: {
            args: Prisma.user_contactsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_contactsPayload>
          }
          createMany: {
            args: Prisma.user_contactsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_contactsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_contactsPayload>[]
          }
          delete: {
            args: Prisma.user_contactsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_contactsPayload>
          }
          update: {
            args: Prisma.user_contactsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_contactsPayload>
          }
          deleteMany: {
            args: Prisma.user_contactsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_contactsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_contactsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_contactsPayload>[]
          }
          upsert: {
            args: Prisma.user_contactsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_contactsPayload>
          }
          aggregate: {
            args: Prisma.User_contactsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_contacts>
          }
          groupBy: {
            args: Prisma.user_contactsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_contactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_contactsCountArgs<ExtArgs>
            result: $Utils.Optional<User_contactsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    appointment_status?: appointment_statusOmit
    appointments?: appointmentsOmit
    clinic_staff?: clinic_staffOmit
    clinic_staff_details?: clinic_staff_detailsOmit
    guardian?: guardianOmit
    mode_of_payment?: mode_of_paymentOmit
    patient_appointments?: patient_appointmentsOmit
    patient_conditions?: patient_conditionsOmit
    patient_details?: patient_detailsOmit
    patients?: patientsOmit
    payment?: paymentOmit
    recurrence?: recurrenceOmit
    recurring_instances?: recurring_instancesOmit
    session?: sessionOmit
    session_details?: session_detailsOmit
    staff_role?: staff_roleOmit
    type_of_payment?: type_of_paymentOmit
    user_contacts?: user_contactsOmit
    users?: usersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Appointment_statusCountOutputType
   */

  export type Appointment_statusCountOutputType = {
    appointments: number
  }

  export type Appointment_statusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | Appointment_statusCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * Appointment_statusCountOutputType without action
   */
  export type Appointment_statusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment_statusCountOutputType
     */
    select?: Appointment_statusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Appointment_statusCountOutputType without action
   */
  export type Appointment_statusCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
  }


  /**
   * Count Type AppointmentsCountOutputType
   */

  export type AppointmentsCountOutputType = {
    patient_appointments: number
    recurring_instances: number
    session: number
  }

  export type AppointmentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient_appointments?: boolean | AppointmentsCountOutputTypeCountPatient_appointmentsArgs
    recurring_instances?: boolean | AppointmentsCountOutputTypeCountRecurring_instancesArgs
    session?: boolean | AppointmentsCountOutputTypeCountSessionArgs
  }

  // Custom InputTypes
  /**
   * AppointmentsCountOutputType without action
   */
  export type AppointmentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentsCountOutputType
     */
    select?: AppointmentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentsCountOutputType without action
   */
  export type AppointmentsCountOutputTypeCountPatient_appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patient_appointmentsWhereInput
  }

  /**
   * AppointmentsCountOutputType without action
   */
  export type AppointmentsCountOutputTypeCountRecurring_instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recurring_instancesWhereInput
  }

  /**
   * AppointmentsCountOutputType without action
   */
  export type AppointmentsCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
  }


  /**
   * Count Type Clinic_staffCountOutputType
   */

  export type Clinic_staffCountOutputType = {
    appointments: number
    clinic_staff_details: number
    session: number
    staff_role: number
  }

  export type Clinic_staffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | Clinic_staffCountOutputTypeCountAppointmentsArgs
    clinic_staff_details?: boolean | Clinic_staffCountOutputTypeCountClinic_staff_detailsArgs
    session?: boolean | Clinic_staffCountOutputTypeCountSessionArgs
    staff_role?: boolean | Clinic_staffCountOutputTypeCountStaff_roleArgs
  }

  // Custom InputTypes
  /**
   * Clinic_staffCountOutputType without action
   */
  export type Clinic_staffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic_staffCountOutputType
     */
    select?: Clinic_staffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Clinic_staffCountOutputType without action
   */
  export type Clinic_staffCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
  }

  /**
   * Clinic_staffCountOutputType without action
   */
  export type Clinic_staffCountOutputTypeCountClinic_staff_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clinic_staff_detailsWhereInput
  }

  /**
   * Clinic_staffCountOutputType without action
   */
  export type Clinic_staffCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
  }

  /**
   * Clinic_staffCountOutputType without action
   */
  export type Clinic_staffCountOutputTypeCountStaff_roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: staff_roleWhereInput
  }


  /**
   * Count Type PatientsCountOutputType
   */

  export type PatientsCountOutputType = {
    patient_appointments: number
    patient_details: number
    session: number
  }

  export type PatientsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient_appointments?: boolean | PatientsCountOutputTypeCountPatient_appointmentsArgs
    patient_details?: boolean | PatientsCountOutputTypeCountPatient_detailsArgs
    session?: boolean | PatientsCountOutputTypeCountSessionArgs
  }

  // Custom InputTypes
  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientsCountOutputType
     */
    select?: PatientsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountPatient_appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patient_appointmentsWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountPatient_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patient_detailsWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
  }


  /**
   * Count Type RecurrenceCountOutputType
   */

  export type RecurrenceCountOutputType = {
    recurring_instances: number
  }

  export type RecurrenceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recurring_instances?: boolean | RecurrenceCountOutputTypeCountRecurring_instancesArgs
  }

  // Custom InputTypes
  /**
   * RecurrenceCountOutputType without action
   */
  export type RecurrenceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurrenceCountOutputType
     */
    select?: RecurrenceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecurrenceCountOutputType without action
   */
  export type RecurrenceCountOutputTypeCountRecurring_instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recurring_instancesWhereInput
  }


  /**
   * Count Type SessionCountOutputType
   */

  export type SessionCountOutputType = {
    session_details: number
  }

  export type SessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session_details?: boolean | SessionCountOutputTypeCountSession_detailsArgs
  }

  // Custom InputTypes
  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionCountOutputType
     */
    select?: SessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountSession_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_detailsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    appointments: number
    patients: number
    user_contacts: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | UsersCountOutputTypeCountAppointmentsArgs
    patients?: boolean | UsersCountOutputTypeCountPatientsArgs
    user_contacts?: boolean | UsersCountOutputTypeCountUser_contactsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patientsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_contactsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model appointment_status
   */

  export type AggregateAppointment_status = {
    _count: Appointment_statusCountAggregateOutputType | null
    _avg: Appointment_statusAvgAggregateOutputType | null
    _sum: Appointment_statusSumAggregateOutputType | null
    _min: Appointment_statusMinAggregateOutputType | null
    _max: Appointment_statusMaxAggregateOutputType | null
  }

  export type Appointment_statusAvgAggregateOutputType = {
    appointment_status_id: number | null
  }

  export type Appointment_statusSumAggregateOutputType = {
    appointment_status_id: bigint | null
  }

  export type Appointment_statusMinAggregateOutputType = {
    appointment_status_id: bigint | null
    appointment_status: string | null
  }

  export type Appointment_statusMaxAggregateOutputType = {
    appointment_status_id: bigint | null
    appointment_status: string | null
  }

  export type Appointment_statusCountAggregateOutputType = {
    appointment_status_id: number
    appointment_status: number
    _all: number
  }


  export type Appointment_statusAvgAggregateInputType = {
    appointment_status_id?: true
  }

  export type Appointment_statusSumAggregateInputType = {
    appointment_status_id?: true
  }

  export type Appointment_statusMinAggregateInputType = {
    appointment_status_id?: true
    appointment_status?: true
  }

  export type Appointment_statusMaxAggregateInputType = {
    appointment_status_id?: true
    appointment_status?: true
  }

  export type Appointment_statusCountAggregateInputType = {
    appointment_status_id?: true
    appointment_status?: true
    _all?: true
  }

  export type Appointment_statusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointment_status to aggregate.
     */
    where?: appointment_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointment_statuses to fetch.
     */
    orderBy?: appointment_statusOrderByWithRelationInput | appointment_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: appointment_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointment_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointment_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned appointment_statuses
    **/
    _count?: true | Appointment_statusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Appointment_statusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Appointment_statusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Appointment_statusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Appointment_statusMaxAggregateInputType
  }

  export type GetAppointment_statusAggregateType<T extends Appointment_statusAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment_status]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment_status[P]>
      : GetScalarType<T[P], AggregateAppointment_status[P]>
  }




  export type appointment_statusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointment_statusWhereInput
    orderBy?: appointment_statusOrderByWithAggregationInput | appointment_statusOrderByWithAggregationInput[]
    by: Appointment_statusScalarFieldEnum[] | Appointment_statusScalarFieldEnum
    having?: appointment_statusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Appointment_statusCountAggregateInputType | true
    _avg?: Appointment_statusAvgAggregateInputType
    _sum?: Appointment_statusSumAggregateInputType
    _min?: Appointment_statusMinAggregateInputType
    _max?: Appointment_statusMaxAggregateInputType
  }

  export type Appointment_statusGroupByOutputType = {
    appointment_status_id: bigint
    appointment_status: string | null
    _count: Appointment_statusCountAggregateOutputType | null
    _avg: Appointment_statusAvgAggregateOutputType | null
    _sum: Appointment_statusSumAggregateOutputType | null
    _min: Appointment_statusMinAggregateOutputType | null
    _max: Appointment_statusMaxAggregateOutputType | null
  }

  type GetAppointment_statusGroupByPayload<T extends appointment_statusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Appointment_statusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Appointment_statusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Appointment_statusGroupByOutputType[P]>
            : GetScalarType<T[P], Appointment_statusGroupByOutputType[P]>
        }
      >
    >


  export type appointment_statusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appointment_status_id?: boolean
    appointment_status?: boolean
    appointments?: boolean | appointment_status$appointmentsArgs<ExtArgs>
    _count?: boolean | Appointment_statusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment_status"]>

  export type appointment_statusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appointment_status_id?: boolean
    appointment_status?: boolean
  }, ExtArgs["result"]["appointment_status"]>

  export type appointment_statusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appointment_status_id?: boolean
    appointment_status?: boolean
  }, ExtArgs["result"]["appointment_status"]>

  export type appointment_statusSelectScalar = {
    appointment_status_id?: boolean
    appointment_status?: boolean
  }

  export type appointment_statusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"appointment_status_id" | "appointment_status", ExtArgs["result"]["appointment_status"]>
  export type appointment_statusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | appointment_status$appointmentsArgs<ExtArgs>
    _count?: boolean | Appointment_statusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type appointment_statusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type appointment_statusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $appointment_statusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "appointment_status"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      appointment_status_id: bigint
      appointment_status: string | null
    }, ExtArgs["result"]["appointment_status"]>
    composites: {}
  }

  type appointment_statusGetPayload<S extends boolean | null | undefined | appointment_statusDefaultArgs> = $Result.GetResult<Prisma.$appointment_statusPayload, S>

  type appointment_statusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<appointment_statusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Appointment_statusCountAggregateInputType | true
    }

  export interface appointment_statusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['appointment_status'], meta: { name: 'appointment_status' } }
    /**
     * Find zero or one Appointment_status that matches the filter.
     * @param {appointment_statusFindUniqueArgs} args - Arguments to find a Appointment_status
     * @example
     * // Get one Appointment_status
     * const appointment_status = await prisma.appointment_status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends appointment_statusFindUniqueArgs>(args: SelectSubset<T, appointment_statusFindUniqueArgs<ExtArgs>>): Prisma__appointment_statusClient<$Result.GetResult<Prisma.$appointment_statusPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Appointment_status that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {appointment_statusFindUniqueOrThrowArgs} args - Arguments to find a Appointment_status
     * @example
     * // Get one Appointment_status
     * const appointment_status = await prisma.appointment_status.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends appointment_statusFindUniqueOrThrowArgs>(args: SelectSubset<T, appointment_statusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__appointment_statusClient<$Result.GetResult<Prisma.$appointment_statusPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Appointment_status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointment_statusFindFirstArgs} args - Arguments to find a Appointment_status
     * @example
     * // Get one Appointment_status
     * const appointment_status = await prisma.appointment_status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends appointment_statusFindFirstArgs>(args?: SelectSubset<T, appointment_statusFindFirstArgs<ExtArgs>>): Prisma__appointment_statusClient<$Result.GetResult<Prisma.$appointment_statusPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Appointment_status that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointment_statusFindFirstOrThrowArgs} args - Arguments to find a Appointment_status
     * @example
     * // Get one Appointment_status
     * const appointment_status = await prisma.appointment_status.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends appointment_statusFindFirstOrThrowArgs>(args?: SelectSubset<T, appointment_statusFindFirstOrThrowArgs<ExtArgs>>): Prisma__appointment_statusClient<$Result.GetResult<Prisma.$appointment_statusPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Appointment_statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointment_statusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointment_statuses
     * const appointment_statuses = await prisma.appointment_status.findMany()
     * 
     * // Get first 10 Appointment_statuses
     * const appointment_statuses = await prisma.appointment_status.findMany({ take: 10 })
     * 
     * // Only select the `appointment_status_id`
     * const appointment_statusWithAppointment_status_idOnly = await prisma.appointment_status.findMany({ select: { appointment_status_id: true } })
     * 
     */
    findMany<T extends appointment_statusFindManyArgs>(args?: SelectSubset<T, appointment_statusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointment_statusPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Appointment_status.
     * @param {appointment_statusCreateArgs} args - Arguments to create a Appointment_status.
     * @example
     * // Create one Appointment_status
     * const Appointment_status = await prisma.appointment_status.create({
     *   data: {
     *     // ... data to create a Appointment_status
     *   }
     * })
     * 
     */
    create<T extends appointment_statusCreateArgs>(args: SelectSubset<T, appointment_statusCreateArgs<ExtArgs>>): Prisma__appointment_statusClient<$Result.GetResult<Prisma.$appointment_statusPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Appointment_statuses.
     * @param {appointment_statusCreateManyArgs} args - Arguments to create many Appointment_statuses.
     * @example
     * // Create many Appointment_statuses
     * const appointment_status = await prisma.appointment_status.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends appointment_statusCreateManyArgs>(args?: SelectSubset<T, appointment_statusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointment_statuses and returns the data saved in the database.
     * @param {appointment_statusCreateManyAndReturnArgs} args - Arguments to create many Appointment_statuses.
     * @example
     * // Create many Appointment_statuses
     * const appointment_status = await prisma.appointment_status.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointment_statuses and only return the `appointment_status_id`
     * const appointment_statusWithAppointment_status_idOnly = await prisma.appointment_status.createManyAndReturn({
     *   select: { appointment_status_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends appointment_statusCreateManyAndReturnArgs>(args?: SelectSubset<T, appointment_statusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointment_statusPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Appointment_status.
     * @param {appointment_statusDeleteArgs} args - Arguments to delete one Appointment_status.
     * @example
     * // Delete one Appointment_status
     * const Appointment_status = await prisma.appointment_status.delete({
     *   where: {
     *     // ... filter to delete one Appointment_status
     *   }
     * })
     * 
     */
    delete<T extends appointment_statusDeleteArgs>(args: SelectSubset<T, appointment_statusDeleteArgs<ExtArgs>>): Prisma__appointment_statusClient<$Result.GetResult<Prisma.$appointment_statusPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Appointment_status.
     * @param {appointment_statusUpdateArgs} args - Arguments to update one Appointment_status.
     * @example
     * // Update one Appointment_status
     * const appointment_status = await prisma.appointment_status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends appointment_statusUpdateArgs>(args: SelectSubset<T, appointment_statusUpdateArgs<ExtArgs>>): Prisma__appointment_statusClient<$Result.GetResult<Prisma.$appointment_statusPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Appointment_statuses.
     * @param {appointment_statusDeleteManyArgs} args - Arguments to filter Appointment_statuses to delete.
     * @example
     * // Delete a few Appointment_statuses
     * const { count } = await prisma.appointment_status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends appointment_statusDeleteManyArgs>(args?: SelectSubset<T, appointment_statusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointment_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointment_statusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointment_statuses
     * const appointment_status = await prisma.appointment_status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends appointment_statusUpdateManyArgs>(args: SelectSubset<T, appointment_statusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointment_statuses and returns the data updated in the database.
     * @param {appointment_statusUpdateManyAndReturnArgs} args - Arguments to update many Appointment_statuses.
     * @example
     * // Update many Appointment_statuses
     * const appointment_status = await prisma.appointment_status.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointment_statuses and only return the `appointment_status_id`
     * const appointment_statusWithAppointment_status_idOnly = await prisma.appointment_status.updateManyAndReturn({
     *   select: { appointment_status_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends appointment_statusUpdateManyAndReturnArgs>(args: SelectSubset<T, appointment_statusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointment_statusPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Appointment_status.
     * @param {appointment_statusUpsertArgs} args - Arguments to update or create a Appointment_status.
     * @example
     * // Update or create a Appointment_status
     * const appointment_status = await prisma.appointment_status.upsert({
     *   create: {
     *     // ... data to create a Appointment_status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment_status we want to update
     *   }
     * })
     */
    upsert<T extends appointment_statusUpsertArgs>(args: SelectSubset<T, appointment_statusUpsertArgs<ExtArgs>>): Prisma__appointment_statusClient<$Result.GetResult<Prisma.$appointment_statusPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Appointment_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointment_statusCountArgs} args - Arguments to filter Appointment_statuses to count.
     * @example
     * // Count the number of Appointment_statuses
     * const count = await prisma.appointment_status.count({
     *   where: {
     *     // ... the filter for the Appointment_statuses we want to count
     *   }
     * })
    **/
    count<T extends appointment_statusCountArgs>(
      args?: Subset<T, appointment_statusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Appointment_statusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Appointment_statusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Appointment_statusAggregateArgs>(args: Subset<T, Appointment_statusAggregateArgs>): Prisma.PrismaPromise<GetAppointment_statusAggregateType<T>>

    /**
     * Group by Appointment_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointment_statusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends appointment_statusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: appointment_statusGroupByArgs['orderBy'] }
        : { orderBy?: appointment_statusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, appointment_statusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointment_statusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the appointment_status model
   */
  readonly fields: appointment_statusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for appointment_status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__appointment_statusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends appointment_status$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, appointment_status$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the appointment_status model
   */ 
  interface appointment_statusFieldRefs {
    readonly appointment_status_id: FieldRef<"appointment_status", 'BigInt'>
    readonly appointment_status: FieldRef<"appointment_status", 'String'>
  }
    

  // Custom InputTypes
  /**
   * appointment_status findUnique
   */
  export type appointment_statusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment_status
     */
    select?: appointment_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointment_status
     */
    omit?: appointment_statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointment_statusInclude<ExtArgs> | null
    /**
     * Filter, which appointment_status to fetch.
     */
    where: appointment_statusWhereUniqueInput
  }

  /**
   * appointment_status findUniqueOrThrow
   */
  export type appointment_statusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment_status
     */
    select?: appointment_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointment_status
     */
    omit?: appointment_statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointment_statusInclude<ExtArgs> | null
    /**
     * Filter, which appointment_status to fetch.
     */
    where: appointment_statusWhereUniqueInput
  }

  /**
   * appointment_status findFirst
   */
  export type appointment_statusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment_status
     */
    select?: appointment_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointment_status
     */
    omit?: appointment_statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointment_statusInclude<ExtArgs> | null
    /**
     * Filter, which appointment_status to fetch.
     */
    where?: appointment_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointment_statuses to fetch.
     */
    orderBy?: appointment_statusOrderByWithRelationInput | appointment_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointment_statuses.
     */
    cursor?: appointment_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointment_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointment_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointment_statuses.
     */
    distinct?: Appointment_statusScalarFieldEnum | Appointment_statusScalarFieldEnum[]
  }

  /**
   * appointment_status findFirstOrThrow
   */
  export type appointment_statusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment_status
     */
    select?: appointment_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointment_status
     */
    omit?: appointment_statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointment_statusInclude<ExtArgs> | null
    /**
     * Filter, which appointment_status to fetch.
     */
    where?: appointment_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointment_statuses to fetch.
     */
    orderBy?: appointment_statusOrderByWithRelationInput | appointment_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointment_statuses.
     */
    cursor?: appointment_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointment_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointment_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointment_statuses.
     */
    distinct?: Appointment_statusScalarFieldEnum | Appointment_statusScalarFieldEnum[]
  }

  /**
   * appointment_status findMany
   */
  export type appointment_statusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment_status
     */
    select?: appointment_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointment_status
     */
    omit?: appointment_statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointment_statusInclude<ExtArgs> | null
    /**
     * Filter, which appointment_statuses to fetch.
     */
    where?: appointment_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointment_statuses to fetch.
     */
    orderBy?: appointment_statusOrderByWithRelationInput | appointment_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing appointment_statuses.
     */
    cursor?: appointment_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointment_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointment_statuses.
     */
    skip?: number
    distinct?: Appointment_statusScalarFieldEnum | Appointment_statusScalarFieldEnum[]
  }

  /**
   * appointment_status create
   */
  export type appointment_statusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment_status
     */
    select?: appointment_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointment_status
     */
    omit?: appointment_statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointment_statusInclude<ExtArgs> | null
    /**
     * The data needed to create a appointment_status.
     */
    data?: XOR<appointment_statusCreateInput, appointment_statusUncheckedCreateInput>
  }

  /**
   * appointment_status createMany
   */
  export type appointment_statusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many appointment_statuses.
     */
    data: appointment_statusCreateManyInput | appointment_statusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * appointment_status createManyAndReturn
   */
  export type appointment_statusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment_status
     */
    select?: appointment_statusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the appointment_status
     */
    omit?: appointment_statusOmit<ExtArgs> | null
    /**
     * The data used to create many appointment_statuses.
     */
    data: appointment_statusCreateManyInput | appointment_statusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * appointment_status update
   */
  export type appointment_statusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment_status
     */
    select?: appointment_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointment_status
     */
    omit?: appointment_statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointment_statusInclude<ExtArgs> | null
    /**
     * The data needed to update a appointment_status.
     */
    data: XOR<appointment_statusUpdateInput, appointment_statusUncheckedUpdateInput>
    /**
     * Choose, which appointment_status to update.
     */
    where: appointment_statusWhereUniqueInput
  }

  /**
   * appointment_status updateMany
   */
  export type appointment_statusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update appointment_statuses.
     */
    data: XOR<appointment_statusUpdateManyMutationInput, appointment_statusUncheckedUpdateManyInput>
    /**
     * Filter which appointment_statuses to update
     */
    where?: appointment_statusWhereInput
    /**
     * Limit how many appointment_statuses to update.
     */
    limit?: number
  }

  /**
   * appointment_status updateManyAndReturn
   */
  export type appointment_statusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment_status
     */
    select?: appointment_statusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the appointment_status
     */
    omit?: appointment_statusOmit<ExtArgs> | null
    /**
     * The data used to update appointment_statuses.
     */
    data: XOR<appointment_statusUpdateManyMutationInput, appointment_statusUncheckedUpdateManyInput>
    /**
     * Filter which appointment_statuses to update
     */
    where?: appointment_statusWhereInput
    /**
     * Limit how many appointment_statuses to update.
     */
    limit?: number
  }

  /**
   * appointment_status upsert
   */
  export type appointment_statusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment_status
     */
    select?: appointment_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointment_status
     */
    omit?: appointment_statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointment_statusInclude<ExtArgs> | null
    /**
     * The filter to search for the appointment_status to update in case it exists.
     */
    where: appointment_statusWhereUniqueInput
    /**
     * In case the appointment_status found by the `where` argument doesn't exist, create a new appointment_status with this data.
     */
    create: XOR<appointment_statusCreateInput, appointment_statusUncheckedCreateInput>
    /**
     * In case the appointment_status was found with the provided `where` argument, update it with this data.
     */
    update: XOR<appointment_statusUpdateInput, appointment_statusUncheckedUpdateInput>
  }

  /**
   * appointment_status delete
   */
  export type appointment_statusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment_status
     */
    select?: appointment_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointment_status
     */
    omit?: appointment_statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointment_statusInclude<ExtArgs> | null
    /**
     * Filter which appointment_status to delete.
     */
    where: appointment_statusWhereUniqueInput
  }

  /**
   * appointment_status deleteMany
   */
  export type appointment_statusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointment_statuses to delete
     */
    where?: appointment_statusWhereInput
    /**
     * Limit how many appointment_statuses to delete.
     */
    limit?: number
  }

  /**
   * appointment_status.appointments
   */
  export type appointment_status$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    cursor?: appointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * appointment_status without action
   */
  export type appointment_statusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment_status
     */
    select?: appointment_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointment_status
     */
    omit?: appointment_statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointment_statusInclude<ExtArgs> | null
  }


  /**
   * Model appointments
   */

  export type AggregateAppointments = {
    _count: AppointmentsCountAggregateOutputType | null
    _avg: AppointmentsAvgAggregateOutputType | null
    _sum: AppointmentsSumAggregateOutputType | null
    _min: AppointmentsMinAggregateOutputType | null
    _max: AppointmentsMaxAggregateOutputType | null
  }

  export type AppointmentsAvgAggregateOutputType = {
    appoint_id: number | null
    staff_id: number | null
    appointment_status_id: number | null
    user_id: number | null
  }

  export type AppointmentsSumAggregateOutputType = {
    appoint_id: bigint | null
    staff_id: bigint | null
    appointment_status_id: bigint | null
    user_id: bigint | null
  }

  export type AppointmentsMinAggregateOutputType = {
    appoint_id: bigint | null
    preferred_time: Date | null
    preferred_date: Date | null
    staff_id: bigint | null
    appointment_status_id: bigint | null
    final_date: Date | null
    final_time: Date | null
    user_id: bigint | null
  }

  export type AppointmentsMaxAggregateOutputType = {
    appoint_id: bigint | null
    preferred_time: Date | null
    preferred_date: Date | null
    staff_id: bigint | null
    appointment_status_id: bigint | null
    final_date: Date | null
    final_time: Date | null
    user_id: bigint | null
  }

  export type AppointmentsCountAggregateOutputType = {
    appoint_id: number
    preferred_time: number
    preferred_date: number
    staff_id: number
    appointment_status_id: number
    final_date: number
    final_time: number
    user_id: number
    _all: number
  }


  export type AppointmentsAvgAggregateInputType = {
    appoint_id?: true
    staff_id?: true
    appointment_status_id?: true
    user_id?: true
  }

  export type AppointmentsSumAggregateInputType = {
    appoint_id?: true
    staff_id?: true
    appointment_status_id?: true
    user_id?: true
  }

  export type AppointmentsMinAggregateInputType = {
    appoint_id?: true
    preferred_time?: true
    preferred_date?: true
    staff_id?: true
    appointment_status_id?: true
    final_date?: true
    final_time?: true
    user_id?: true
  }

  export type AppointmentsMaxAggregateInputType = {
    appoint_id?: true
    preferred_time?: true
    preferred_date?: true
    staff_id?: true
    appointment_status_id?: true
    final_date?: true
    final_time?: true
    user_id?: true
  }

  export type AppointmentsCountAggregateInputType = {
    appoint_id?: true
    preferred_time?: true
    preferred_date?: true
    staff_id?: true
    appointment_status_id?: true
    final_date?: true
    final_time?: true
    user_id?: true
    _all?: true
  }

  export type AppointmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointments to aggregate.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned appointments
    **/
    _count?: true | AppointmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentsMaxAggregateInputType
  }

  export type GetAppointmentsAggregateType<T extends AppointmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointments[P]>
      : GetScalarType<T[P], AggregateAppointments[P]>
  }




  export type appointmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithAggregationInput | appointmentsOrderByWithAggregationInput[]
    by: AppointmentsScalarFieldEnum[] | AppointmentsScalarFieldEnum
    having?: appointmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentsCountAggregateInputType | true
    _avg?: AppointmentsAvgAggregateInputType
    _sum?: AppointmentsSumAggregateInputType
    _min?: AppointmentsMinAggregateInputType
    _max?: AppointmentsMaxAggregateInputType
  }

  export type AppointmentsGroupByOutputType = {
    appoint_id: bigint
    preferred_time: Date | null
    preferred_date: Date | null
    staff_id: bigint | null
    appointment_status_id: bigint | null
    final_date: Date | null
    final_time: Date | null
    user_id: bigint | null
    _count: AppointmentsCountAggregateOutputType | null
    _avg: AppointmentsAvgAggregateOutputType | null
    _sum: AppointmentsSumAggregateOutputType | null
    _min: AppointmentsMinAggregateOutputType | null
    _max: AppointmentsMaxAggregateOutputType | null
  }

  type GetAppointmentsGroupByPayload<T extends appointmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentsGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentsGroupByOutputType[P]>
        }
      >
    >


  export type appointmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appoint_id?: boolean
    preferred_time?: boolean
    preferred_date?: boolean
    staff_id?: boolean
    appointment_status_id?: boolean
    final_date?: boolean
    final_time?: boolean
    user_id?: boolean
    appointment_status?: boolean | appointments$appointment_statusArgs<ExtArgs>
    clinic_staff?: boolean | appointments$clinic_staffArgs<ExtArgs>
    users?: boolean | appointments$usersArgs<ExtArgs>
    patient_appointments?: boolean | appointments$patient_appointmentsArgs<ExtArgs>
    recurring_instances?: boolean | appointments$recurring_instancesArgs<ExtArgs>
    session?: boolean | appointments$sessionArgs<ExtArgs>
    _count?: boolean | AppointmentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointments"]>

  export type appointmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appoint_id?: boolean
    preferred_time?: boolean
    preferred_date?: boolean
    staff_id?: boolean
    appointment_status_id?: boolean
    final_date?: boolean
    final_time?: boolean
    user_id?: boolean
    appointment_status?: boolean | appointments$appointment_statusArgs<ExtArgs>
    clinic_staff?: boolean | appointments$clinic_staffArgs<ExtArgs>
    users?: boolean | appointments$usersArgs<ExtArgs>
  }, ExtArgs["result"]["appointments"]>

  export type appointmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appoint_id?: boolean
    preferred_time?: boolean
    preferred_date?: boolean
    staff_id?: boolean
    appointment_status_id?: boolean
    final_date?: boolean
    final_time?: boolean
    user_id?: boolean
    appointment_status?: boolean | appointments$appointment_statusArgs<ExtArgs>
    clinic_staff?: boolean | appointments$clinic_staffArgs<ExtArgs>
    users?: boolean | appointments$usersArgs<ExtArgs>
  }, ExtArgs["result"]["appointments"]>

  export type appointmentsSelectScalar = {
    appoint_id?: boolean
    preferred_time?: boolean
    preferred_date?: boolean
    staff_id?: boolean
    appointment_status_id?: boolean
    final_date?: boolean
    final_time?: boolean
    user_id?: boolean
  }

  export type appointmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"appoint_id" | "preferred_time" | "preferred_date" | "staff_id" | "appointment_status_id" | "final_date" | "final_time" | "user_id", ExtArgs["result"]["appointments"]>
  export type appointmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment_status?: boolean | appointments$appointment_statusArgs<ExtArgs>
    clinic_staff?: boolean | appointments$clinic_staffArgs<ExtArgs>
    users?: boolean | appointments$usersArgs<ExtArgs>
    patient_appointments?: boolean | appointments$patient_appointmentsArgs<ExtArgs>
    recurring_instances?: boolean | appointments$recurring_instancesArgs<ExtArgs>
    session?: boolean | appointments$sessionArgs<ExtArgs>
    _count?: boolean | AppointmentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type appointmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment_status?: boolean | appointments$appointment_statusArgs<ExtArgs>
    clinic_staff?: boolean | appointments$clinic_staffArgs<ExtArgs>
    users?: boolean | appointments$usersArgs<ExtArgs>
  }
  export type appointmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment_status?: boolean | appointments$appointment_statusArgs<ExtArgs>
    clinic_staff?: boolean | appointments$clinic_staffArgs<ExtArgs>
    users?: boolean | appointments$usersArgs<ExtArgs>
  }

  export type $appointmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "appointments"
    objects: {
      appointment_status: Prisma.$appointment_statusPayload<ExtArgs> | null
      clinic_staff: Prisma.$clinic_staffPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
      patient_appointments: Prisma.$patient_appointmentsPayload<ExtArgs>[]
      recurring_instances: Prisma.$recurring_instancesPayload<ExtArgs>[]
      session: Prisma.$sessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      appoint_id: bigint
      preferred_time: Date | null
      preferred_date: Date | null
      staff_id: bigint | null
      appointment_status_id: bigint | null
      final_date: Date | null
      final_time: Date | null
      user_id: bigint | null
    }, ExtArgs["result"]["appointments"]>
    composites: {}
  }

  type appointmentsGetPayload<S extends boolean | null | undefined | appointmentsDefaultArgs> = $Result.GetResult<Prisma.$appointmentsPayload, S>

  type appointmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<appointmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentsCountAggregateInputType | true
    }

  export interface appointmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['appointments'], meta: { name: 'appointments' } }
    /**
     * Find zero or one Appointments that matches the filter.
     * @param {appointmentsFindUniqueArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends appointmentsFindUniqueArgs>(args: SelectSubset<T, appointmentsFindUniqueArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Appointments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {appointmentsFindUniqueOrThrowArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends appointmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, appointmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsFindFirstArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends appointmentsFindFirstArgs>(args?: SelectSubset<T, appointmentsFindFirstArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Appointments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsFindFirstOrThrowArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends appointmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, appointmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointments.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointments.findMany({ take: 10 })
     * 
     * // Only select the `appoint_id`
     * const appointmentsWithAppoint_idOnly = await prisma.appointments.findMany({ select: { appoint_id: true } })
     * 
     */
    findMany<T extends appointmentsFindManyArgs>(args?: SelectSubset<T, appointmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Appointments.
     * @param {appointmentsCreateArgs} args - Arguments to create a Appointments.
     * @example
     * // Create one Appointments
     * const Appointments = await prisma.appointments.create({
     *   data: {
     *     // ... data to create a Appointments
     *   }
     * })
     * 
     */
    create<T extends appointmentsCreateArgs>(args: SelectSubset<T, appointmentsCreateArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Appointments.
     * @param {appointmentsCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointments = await prisma.appointments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends appointmentsCreateManyArgs>(args?: SelectSubset<T, appointmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {appointmentsCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointments = await prisma.appointments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `appoint_id`
     * const appointmentsWithAppoint_idOnly = await prisma.appointments.createManyAndReturn({
     *   select: { appoint_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends appointmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, appointmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Appointments.
     * @param {appointmentsDeleteArgs} args - Arguments to delete one Appointments.
     * @example
     * // Delete one Appointments
     * const Appointments = await prisma.appointments.delete({
     *   where: {
     *     // ... filter to delete one Appointments
     *   }
     * })
     * 
     */
    delete<T extends appointmentsDeleteArgs>(args: SelectSubset<T, appointmentsDeleteArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Appointments.
     * @param {appointmentsUpdateArgs} args - Arguments to update one Appointments.
     * @example
     * // Update one Appointments
     * const appointments = await prisma.appointments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends appointmentsUpdateArgs>(args: SelectSubset<T, appointmentsUpdateArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Appointments.
     * @param {appointmentsDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends appointmentsDeleteManyArgs>(args?: SelectSubset<T, appointmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointments = await prisma.appointments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends appointmentsUpdateManyArgs>(args: SelectSubset<T, appointmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {appointmentsUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointments = await prisma.appointments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `appoint_id`
     * const appointmentsWithAppoint_idOnly = await prisma.appointments.updateManyAndReturn({
     *   select: { appoint_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends appointmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, appointmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Appointments.
     * @param {appointmentsUpsertArgs} args - Arguments to update or create a Appointments.
     * @example
     * // Update or create a Appointments
     * const appointments = await prisma.appointments.upsert({
     *   create: {
     *     // ... data to create a Appointments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointments we want to update
     *   }
     * })
     */
    upsert<T extends appointmentsUpsertArgs>(args: SelectSubset<T, appointmentsUpsertArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointments.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends appointmentsCountArgs>(
      args?: Subset<T, appointmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentsAggregateArgs>(args: Subset<T, AppointmentsAggregateArgs>): Prisma.PrismaPromise<GetAppointmentsAggregateType<T>>

    /**
     * Group by Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends appointmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: appointmentsGroupByArgs['orderBy'] }
        : { orderBy?: appointmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, appointmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the appointments model
   */
  readonly fields: appointmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for appointments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__appointmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment_status<T extends appointments$appointment_statusArgs<ExtArgs> = {}>(args?: Subset<T, appointments$appointment_statusArgs<ExtArgs>>): Prisma__appointment_statusClient<$Result.GetResult<Prisma.$appointment_statusPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    clinic_staff<T extends appointments$clinic_staffArgs<ExtArgs> = {}>(args?: Subset<T, appointments$clinic_staffArgs<ExtArgs>>): Prisma__clinic_staffClient<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    users<T extends appointments$usersArgs<ExtArgs> = {}>(args?: Subset<T, appointments$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    patient_appointments<T extends appointments$patient_appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, appointments$patient_appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_appointmentsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    recurring_instances<T extends appointments$recurring_instancesArgs<ExtArgs> = {}>(args?: Subset<T, appointments$recurring_instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recurring_instancesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    session<T extends appointments$sessionArgs<ExtArgs> = {}>(args?: Subset<T, appointments$sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the appointments model
   */ 
  interface appointmentsFieldRefs {
    readonly appoint_id: FieldRef<"appointments", 'BigInt'>
    readonly preferred_time: FieldRef<"appointments", 'DateTime'>
    readonly preferred_date: FieldRef<"appointments", 'DateTime'>
    readonly staff_id: FieldRef<"appointments", 'BigInt'>
    readonly appointment_status_id: FieldRef<"appointments", 'BigInt'>
    readonly final_date: FieldRef<"appointments", 'DateTime'>
    readonly final_time: FieldRef<"appointments", 'DateTime'>
    readonly user_id: FieldRef<"appointments", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * appointments findUnique
   */
  export type appointmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments findUniqueOrThrow
   */
  export type appointmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments findFirst
   */
  export type appointmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointments.
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointments.
     */
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * appointments findFirstOrThrow
   */
  export type appointmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointments.
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointments.
     */
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * appointments findMany
   */
  export type appointmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing appointments.
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * appointments create
   */
  export type appointmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a appointments.
     */
    data?: XOR<appointmentsCreateInput, appointmentsUncheckedCreateInput>
  }

  /**
   * appointments createMany
   */
  export type appointmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many appointments.
     */
    data: appointmentsCreateManyInput | appointmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * appointments createManyAndReturn
   */
  export type appointmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * The data used to create many appointments.
     */
    data: appointmentsCreateManyInput | appointmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * appointments update
   */
  export type appointmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a appointments.
     */
    data: XOR<appointmentsUpdateInput, appointmentsUncheckedUpdateInput>
    /**
     * Choose, which appointments to update.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments updateMany
   */
  export type appointmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update appointments.
     */
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyInput>
    /**
     * Filter which appointments to update
     */
    where?: appointmentsWhereInput
    /**
     * Limit how many appointments to update.
     */
    limit?: number
  }

  /**
   * appointments updateManyAndReturn
   */
  export type appointmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * The data used to update appointments.
     */
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyInput>
    /**
     * Filter which appointments to update
     */
    where?: appointmentsWhereInput
    /**
     * Limit how many appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * appointments upsert
   */
  export type appointmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the appointments to update in case it exists.
     */
    where: appointmentsWhereUniqueInput
    /**
     * In case the appointments found by the `where` argument doesn't exist, create a new appointments with this data.
     */
    create: XOR<appointmentsCreateInput, appointmentsUncheckedCreateInput>
    /**
     * In case the appointments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<appointmentsUpdateInput, appointmentsUncheckedUpdateInput>
  }

  /**
   * appointments delete
   */
  export type appointmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter which appointments to delete.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments deleteMany
   */
  export type appointmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointments to delete
     */
    where?: appointmentsWhereInput
    /**
     * Limit how many appointments to delete.
     */
    limit?: number
  }

  /**
   * appointments.appointment_status
   */
  export type appointments$appointment_statusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment_status
     */
    select?: appointment_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointment_status
     */
    omit?: appointment_statusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointment_statusInclude<ExtArgs> | null
    where?: appointment_statusWhereInput
  }

  /**
   * appointments.clinic_staff
   */
  export type appointments$clinic_staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff
     */
    select?: clinic_staffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff
     */
    omit?: clinic_staffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staffInclude<ExtArgs> | null
    where?: clinic_staffWhereInput
  }

  /**
   * appointments.users
   */
  export type appointments$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * appointments.patient_appointments
   */
  export type appointments$patient_appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsInclude<ExtArgs> | null
    where?: patient_appointmentsWhereInput
    orderBy?: patient_appointmentsOrderByWithRelationInput | patient_appointmentsOrderByWithRelationInput[]
    cursor?: patient_appointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Patient_appointmentsScalarFieldEnum | Patient_appointmentsScalarFieldEnum[]
  }

  /**
   * appointments.recurring_instances
   */
  export type appointments$recurring_instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesInclude<ExtArgs> | null
    where?: recurring_instancesWhereInput
    orderBy?: recurring_instancesOrderByWithRelationInput | recurring_instancesOrderByWithRelationInput[]
    cursor?: recurring_instancesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Recurring_instancesScalarFieldEnum | Recurring_instancesScalarFieldEnum[]
  }

  /**
   * appointments.session
   */
  export type appointments$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    cursor?: sessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * appointments without action
   */
  export type appointmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
  }


  /**
   * Model clinic_staff
   */

  export type AggregateClinic_staff = {
    _count: Clinic_staffCountAggregateOutputType | null
    _avg: Clinic_staffAvgAggregateOutputType | null
    _sum: Clinic_staffSumAggregateOutputType | null
    _min: Clinic_staffMinAggregateOutputType | null
    _max: Clinic_staffMaxAggregateOutputType | null
  }

  export type Clinic_staffAvgAggregateOutputType = {
    staff_id: number | null
  }

  export type Clinic_staffSumAggregateOutputType = {
    staff_id: bigint | null
  }

  export type Clinic_staffMinAggregateOutputType = {
    staff_id: bigint | null
    staff_name: string | null
    staff_birthdate: Date | null
  }

  export type Clinic_staffMaxAggregateOutputType = {
    staff_id: bigint | null
    staff_name: string | null
    staff_birthdate: Date | null
  }

  export type Clinic_staffCountAggregateOutputType = {
    staff_id: number
    staff_name: number
    staff_birthdate: number
    _all: number
  }


  export type Clinic_staffAvgAggregateInputType = {
    staff_id?: true
  }

  export type Clinic_staffSumAggregateInputType = {
    staff_id?: true
  }

  export type Clinic_staffMinAggregateInputType = {
    staff_id?: true
    staff_name?: true
    staff_birthdate?: true
  }

  export type Clinic_staffMaxAggregateInputType = {
    staff_id?: true
    staff_name?: true
    staff_birthdate?: true
  }

  export type Clinic_staffCountAggregateInputType = {
    staff_id?: true
    staff_name?: true
    staff_birthdate?: true
    _all?: true
  }

  export type Clinic_staffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinic_staff to aggregate.
     */
    where?: clinic_staffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_staffs to fetch.
     */
    orderBy?: clinic_staffOrderByWithRelationInput | clinic_staffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clinic_staffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_staffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_staffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clinic_staffs
    **/
    _count?: true | Clinic_staffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Clinic_staffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Clinic_staffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Clinic_staffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Clinic_staffMaxAggregateInputType
  }

  export type GetClinic_staffAggregateType<T extends Clinic_staffAggregateArgs> = {
        [P in keyof T & keyof AggregateClinic_staff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinic_staff[P]>
      : GetScalarType<T[P], AggregateClinic_staff[P]>
  }




  export type clinic_staffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clinic_staffWhereInput
    orderBy?: clinic_staffOrderByWithAggregationInput | clinic_staffOrderByWithAggregationInput[]
    by: Clinic_staffScalarFieldEnum[] | Clinic_staffScalarFieldEnum
    having?: clinic_staffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Clinic_staffCountAggregateInputType | true
    _avg?: Clinic_staffAvgAggregateInputType
    _sum?: Clinic_staffSumAggregateInputType
    _min?: Clinic_staffMinAggregateInputType
    _max?: Clinic_staffMaxAggregateInputType
  }

  export type Clinic_staffGroupByOutputType = {
    staff_id: bigint
    staff_name: string | null
    staff_birthdate: Date | null
    _count: Clinic_staffCountAggregateOutputType | null
    _avg: Clinic_staffAvgAggregateOutputType | null
    _sum: Clinic_staffSumAggregateOutputType | null
    _min: Clinic_staffMinAggregateOutputType | null
    _max: Clinic_staffMaxAggregateOutputType | null
  }

  type GetClinic_staffGroupByPayload<T extends clinic_staffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Clinic_staffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Clinic_staffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Clinic_staffGroupByOutputType[P]>
            : GetScalarType<T[P], Clinic_staffGroupByOutputType[P]>
        }
      >
    >


  export type clinic_staffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    staff_id?: boolean
    staff_name?: boolean
    staff_birthdate?: boolean
    appointments?: boolean | clinic_staff$appointmentsArgs<ExtArgs>
    clinic_staff_details?: boolean | clinic_staff$clinic_staff_detailsArgs<ExtArgs>
    session?: boolean | clinic_staff$sessionArgs<ExtArgs>
    staff_role?: boolean | clinic_staff$staff_roleArgs<ExtArgs>
    _count?: boolean | Clinic_staffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic_staff"]>

  export type clinic_staffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    staff_id?: boolean
    staff_name?: boolean
    staff_birthdate?: boolean
  }, ExtArgs["result"]["clinic_staff"]>

  export type clinic_staffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    staff_id?: boolean
    staff_name?: boolean
    staff_birthdate?: boolean
  }, ExtArgs["result"]["clinic_staff"]>

  export type clinic_staffSelectScalar = {
    staff_id?: boolean
    staff_name?: boolean
    staff_birthdate?: boolean
  }

  export type clinic_staffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"staff_id" | "staff_name" | "staff_birthdate", ExtArgs["result"]["clinic_staff"]>
  export type clinic_staffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | clinic_staff$appointmentsArgs<ExtArgs>
    clinic_staff_details?: boolean | clinic_staff$clinic_staff_detailsArgs<ExtArgs>
    session?: boolean | clinic_staff$sessionArgs<ExtArgs>
    staff_role?: boolean | clinic_staff$staff_roleArgs<ExtArgs>
    _count?: boolean | Clinic_staffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type clinic_staffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type clinic_staffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $clinic_staffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clinic_staff"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs>[]
      clinic_staff_details: Prisma.$clinic_staff_detailsPayload<ExtArgs>[]
      session: Prisma.$sessionPayload<ExtArgs>[]
      staff_role: Prisma.$staff_rolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      staff_id: bigint
      staff_name: string | null
      staff_birthdate: Date | null
    }, ExtArgs["result"]["clinic_staff"]>
    composites: {}
  }

  type clinic_staffGetPayload<S extends boolean | null | undefined | clinic_staffDefaultArgs> = $Result.GetResult<Prisma.$clinic_staffPayload, S>

  type clinic_staffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clinic_staffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Clinic_staffCountAggregateInputType | true
    }

  export interface clinic_staffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clinic_staff'], meta: { name: 'clinic_staff' } }
    /**
     * Find zero or one Clinic_staff that matches the filter.
     * @param {clinic_staffFindUniqueArgs} args - Arguments to find a Clinic_staff
     * @example
     * // Get one Clinic_staff
     * const clinic_staff = await prisma.clinic_staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clinic_staffFindUniqueArgs>(args: SelectSubset<T, clinic_staffFindUniqueArgs<ExtArgs>>): Prisma__clinic_staffClient<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Clinic_staff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clinic_staffFindUniqueOrThrowArgs} args - Arguments to find a Clinic_staff
     * @example
     * // Get one Clinic_staff
     * const clinic_staff = await prisma.clinic_staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clinic_staffFindUniqueOrThrowArgs>(args: SelectSubset<T, clinic_staffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clinic_staffClient<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Clinic_staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_staffFindFirstArgs} args - Arguments to find a Clinic_staff
     * @example
     * // Get one Clinic_staff
     * const clinic_staff = await prisma.clinic_staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clinic_staffFindFirstArgs>(args?: SelectSubset<T, clinic_staffFindFirstArgs<ExtArgs>>): Prisma__clinic_staffClient<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Clinic_staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_staffFindFirstOrThrowArgs} args - Arguments to find a Clinic_staff
     * @example
     * // Get one Clinic_staff
     * const clinic_staff = await prisma.clinic_staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clinic_staffFindFirstOrThrowArgs>(args?: SelectSubset<T, clinic_staffFindFirstOrThrowArgs<ExtArgs>>): Prisma__clinic_staffClient<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Clinic_staffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_staffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinic_staffs
     * const clinic_staffs = await prisma.clinic_staff.findMany()
     * 
     * // Get first 10 Clinic_staffs
     * const clinic_staffs = await prisma.clinic_staff.findMany({ take: 10 })
     * 
     * // Only select the `staff_id`
     * const clinic_staffWithStaff_idOnly = await prisma.clinic_staff.findMany({ select: { staff_id: true } })
     * 
     */
    findMany<T extends clinic_staffFindManyArgs>(args?: SelectSubset<T, clinic_staffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Clinic_staff.
     * @param {clinic_staffCreateArgs} args - Arguments to create a Clinic_staff.
     * @example
     * // Create one Clinic_staff
     * const Clinic_staff = await prisma.clinic_staff.create({
     *   data: {
     *     // ... data to create a Clinic_staff
     *   }
     * })
     * 
     */
    create<T extends clinic_staffCreateArgs>(args: SelectSubset<T, clinic_staffCreateArgs<ExtArgs>>): Prisma__clinic_staffClient<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Clinic_staffs.
     * @param {clinic_staffCreateManyArgs} args - Arguments to create many Clinic_staffs.
     * @example
     * // Create many Clinic_staffs
     * const clinic_staff = await prisma.clinic_staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clinic_staffCreateManyArgs>(args?: SelectSubset<T, clinic_staffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clinic_staffs and returns the data saved in the database.
     * @param {clinic_staffCreateManyAndReturnArgs} args - Arguments to create many Clinic_staffs.
     * @example
     * // Create many Clinic_staffs
     * const clinic_staff = await prisma.clinic_staff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clinic_staffs and only return the `staff_id`
     * const clinic_staffWithStaff_idOnly = await prisma.clinic_staff.createManyAndReturn({
     *   select: { staff_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends clinic_staffCreateManyAndReturnArgs>(args?: SelectSubset<T, clinic_staffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Clinic_staff.
     * @param {clinic_staffDeleteArgs} args - Arguments to delete one Clinic_staff.
     * @example
     * // Delete one Clinic_staff
     * const Clinic_staff = await prisma.clinic_staff.delete({
     *   where: {
     *     // ... filter to delete one Clinic_staff
     *   }
     * })
     * 
     */
    delete<T extends clinic_staffDeleteArgs>(args: SelectSubset<T, clinic_staffDeleteArgs<ExtArgs>>): Prisma__clinic_staffClient<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Clinic_staff.
     * @param {clinic_staffUpdateArgs} args - Arguments to update one Clinic_staff.
     * @example
     * // Update one Clinic_staff
     * const clinic_staff = await prisma.clinic_staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clinic_staffUpdateArgs>(args: SelectSubset<T, clinic_staffUpdateArgs<ExtArgs>>): Prisma__clinic_staffClient<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Clinic_staffs.
     * @param {clinic_staffDeleteManyArgs} args - Arguments to filter Clinic_staffs to delete.
     * @example
     * // Delete a few Clinic_staffs
     * const { count } = await prisma.clinic_staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clinic_staffDeleteManyArgs>(args?: SelectSubset<T, clinic_staffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinic_staffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_staffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinic_staffs
     * const clinic_staff = await prisma.clinic_staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clinic_staffUpdateManyArgs>(args: SelectSubset<T, clinic_staffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinic_staffs and returns the data updated in the database.
     * @param {clinic_staffUpdateManyAndReturnArgs} args - Arguments to update many Clinic_staffs.
     * @example
     * // Update many Clinic_staffs
     * const clinic_staff = await prisma.clinic_staff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clinic_staffs and only return the `staff_id`
     * const clinic_staffWithStaff_idOnly = await prisma.clinic_staff.updateManyAndReturn({
     *   select: { staff_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends clinic_staffUpdateManyAndReturnArgs>(args: SelectSubset<T, clinic_staffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Clinic_staff.
     * @param {clinic_staffUpsertArgs} args - Arguments to update or create a Clinic_staff.
     * @example
     * // Update or create a Clinic_staff
     * const clinic_staff = await prisma.clinic_staff.upsert({
     *   create: {
     *     // ... data to create a Clinic_staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinic_staff we want to update
     *   }
     * })
     */
    upsert<T extends clinic_staffUpsertArgs>(args: SelectSubset<T, clinic_staffUpsertArgs<ExtArgs>>): Prisma__clinic_staffClient<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Clinic_staffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_staffCountArgs} args - Arguments to filter Clinic_staffs to count.
     * @example
     * // Count the number of Clinic_staffs
     * const count = await prisma.clinic_staff.count({
     *   where: {
     *     // ... the filter for the Clinic_staffs we want to count
     *   }
     * })
    **/
    count<T extends clinic_staffCountArgs>(
      args?: Subset<T, clinic_staffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Clinic_staffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinic_staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Clinic_staffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Clinic_staffAggregateArgs>(args: Subset<T, Clinic_staffAggregateArgs>): Prisma.PrismaPromise<GetClinic_staffAggregateType<T>>

    /**
     * Group by Clinic_staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_staffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clinic_staffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clinic_staffGroupByArgs['orderBy'] }
        : { orderBy?: clinic_staffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clinic_staffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinic_staffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clinic_staff model
   */
  readonly fields: clinic_staffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clinic_staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clinic_staffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends clinic_staff$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, clinic_staff$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    clinic_staff_details<T extends clinic_staff$clinic_staff_detailsArgs<ExtArgs> = {}>(args?: Subset<T, clinic_staff$clinic_staff_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinic_staff_detailsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    session<T extends clinic_staff$sessionArgs<ExtArgs> = {}>(args?: Subset<T, clinic_staff$sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    staff_role<T extends clinic_staff$staff_roleArgs<ExtArgs> = {}>(args?: Subset<T, clinic_staff$staff_roleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staff_rolePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clinic_staff model
   */ 
  interface clinic_staffFieldRefs {
    readonly staff_id: FieldRef<"clinic_staff", 'BigInt'>
    readonly staff_name: FieldRef<"clinic_staff", 'String'>
    readonly staff_birthdate: FieldRef<"clinic_staff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * clinic_staff findUnique
   */
  export type clinic_staffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff
     */
    select?: clinic_staffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff
     */
    omit?: clinic_staffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staffInclude<ExtArgs> | null
    /**
     * Filter, which clinic_staff to fetch.
     */
    where: clinic_staffWhereUniqueInput
  }

  /**
   * clinic_staff findUniqueOrThrow
   */
  export type clinic_staffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff
     */
    select?: clinic_staffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff
     */
    omit?: clinic_staffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staffInclude<ExtArgs> | null
    /**
     * Filter, which clinic_staff to fetch.
     */
    where: clinic_staffWhereUniqueInput
  }

  /**
   * clinic_staff findFirst
   */
  export type clinic_staffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff
     */
    select?: clinic_staffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff
     */
    omit?: clinic_staffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staffInclude<ExtArgs> | null
    /**
     * Filter, which clinic_staff to fetch.
     */
    where?: clinic_staffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_staffs to fetch.
     */
    orderBy?: clinic_staffOrderByWithRelationInput | clinic_staffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinic_staffs.
     */
    cursor?: clinic_staffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_staffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_staffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinic_staffs.
     */
    distinct?: Clinic_staffScalarFieldEnum | Clinic_staffScalarFieldEnum[]
  }

  /**
   * clinic_staff findFirstOrThrow
   */
  export type clinic_staffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff
     */
    select?: clinic_staffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff
     */
    omit?: clinic_staffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staffInclude<ExtArgs> | null
    /**
     * Filter, which clinic_staff to fetch.
     */
    where?: clinic_staffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_staffs to fetch.
     */
    orderBy?: clinic_staffOrderByWithRelationInput | clinic_staffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinic_staffs.
     */
    cursor?: clinic_staffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_staffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_staffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinic_staffs.
     */
    distinct?: Clinic_staffScalarFieldEnum | Clinic_staffScalarFieldEnum[]
  }

  /**
   * clinic_staff findMany
   */
  export type clinic_staffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff
     */
    select?: clinic_staffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff
     */
    omit?: clinic_staffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staffInclude<ExtArgs> | null
    /**
     * Filter, which clinic_staffs to fetch.
     */
    where?: clinic_staffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_staffs to fetch.
     */
    orderBy?: clinic_staffOrderByWithRelationInput | clinic_staffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clinic_staffs.
     */
    cursor?: clinic_staffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_staffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_staffs.
     */
    skip?: number
    distinct?: Clinic_staffScalarFieldEnum | Clinic_staffScalarFieldEnum[]
  }

  /**
   * clinic_staff create
   */
  export type clinic_staffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff
     */
    select?: clinic_staffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff
     */
    omit?: clinic_staffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staffInclude<ExtArgs> | null
    /**
     * The data needed to create a clinic_staff.
     */
    data?: XOR<clinic_staffCreateInput, clinic_staffUncheckedCreateInput>
  }

  /**
   * clinic_staff createMany
   */
  export type clinic_staffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clinic_staffs.
     */
    data: clinic_staffCreateManyInput | clinic_staffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clinic_staff createManyAndReturn
   */
  export type clinic_staffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff
     */
    select?: clinic_staffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff
     */
    omit?: clinic_staffOmit<ExtArgs> | null
    /**
     * The data used to create many clinic_staffs.
     */
    data: clinic_staffCreateManyInput | clinic_staffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clinic_staff update
   */
  export type clinic_staffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff
     */
    select?: clinic_staffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff
     */
    omit?: clinic_staffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staffInclude<ExtArgs> | null
    /**
     * The data needed to update a clinic_staff.
     */
    data: XOR<clinic_staffUpdateInput, clinic_staffUncheckedUpdateInput>
    /**
     * Choose, which clinic_staff to update.
     */
    where: clinic_staffWhereUniqueInput
  }

  /**
   * clinic_staff updateMany
   */
  export type clinic_staffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clinic_staffs.
     */
    data: XOR<clinic_staffUpdateManyMutationInput, clinic_staffUncheckedUpdateManyInput>
    /**
     * Filter which clinic_staffs to update
     */
    where?: clinic_staffWhereInput
    /**
     * Limit how many clinic_staffs to update.
     */
    limit?: number
  }

  /**
   * clinic_staff updateManyAndReturn
   */
  export type clinic_staffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff
     */
    select?: clinic_staffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff
     */
    omit?: clinic_staffOmit<ExtArgs> | null
    /**
     * The data used to update clinic_staffs.
     */
    data: XOR<clinic_staffUpdateManyMutationInput, clinic_staffUncheckedUpdateManyInput>
    /**
     * Filter which clinic_staffs to update
     */
    where?: clinic_staffWhereInput
    /**
     * Limit how many clinic_staffs to update.
     */
    limit?: number
  }

  /**
   * clinic_staff upsert
   */
  export type clinic_staffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff
     */
    select?: clinic_staffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff
     */
    omit?: clinic_staffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staffInclude<ExtArgs> | null
    /**
     * The filter to search for the clinic_staff to update in case it exists.
     */
    where: clinic_staffWhereUniqueInput
    /**
     * In case the clinic_staff found by the `where` argument doesn't exist, create a new clinic_staff with this data.
     */
    create: XOR<clinic_staffCreateInput, clinic_staffUncheckedCreateInput>
    /**
     * In case the clinic_staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clinic_staffUpdateInput, clinic_staffUncheckedUpdateInput>
  }

  /**
   * clinic_staff delete
   */
  export type clinic_staffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff
     */
    select?: clinic_staffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff
     */
    omit?: clinic_staffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staffInclude<ExtArgs> | null
    /**
     * Filter which clinic_staff to delete.
     */
    where: clinic_staffWhereUniqueInput
  }

  /**
   * clinic_staff deleteMany
   */
  export type clinic_staffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinic_staffs to delete
     */
    where?: clinic_staffWhereInput
    /**
     * Limit how many clinic_staffs to delete.
     */
    limit?: number
  }

  /**
   * clinic_staff.appointments
   */
  export type clinic_staff$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    cursor?: appointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * clinic_staff.clinic_staff_details
   */
  export type clinic_staff$clinic_staff_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff_details
     */
    select?: clinic_staff_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff_details
     */
    omit?: clinic_staff_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staff_detailsInclude<ExtArgs> | null
    where?: clinic_staff_detailsWhereInput
    orderBy?: clinic_staff_detailsOrderByWithRelationInput | clinic_staff_detailsOrderByWithRelationInput[]
    cursor?: clinic_staff_detailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Clinic_staff_detailsScalarFieldEnum | Clinic_staff_detailsScalarFieldEnum[]
  }

  /**
   * clinic_staff.session
   */
  export type clinic_staff$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    cursor?: sessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * clinic_staff.staff_role
   */
  export type clinic_staff$staff_roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff_role
     */
    select?: staff_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staff_role
     */
    omit?: staff_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staff_roleInclude<ExtArgs> | null
    where?: staff_roleWhereInput
    orderBy?: staff_roleOrderByWithRelationInput | staff_roleOrderByWithRelationInput[]
    cursor?: staff_roleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Staff_roleScalarFieldEnum | Staff_roleScalarFieldEnum[]
  }

  /**
   * clinic_staff without action
   */
  export type clinic_staffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff
     */
    select?: clinic_staffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff
     */
    omit?: clinic_staffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staffInclude<ExtArgs> | null
  }


  /**
   * Model clinic_staff_details
   */

  export type AggregateClinic_staff_details = {
    _count: Clinic_staff_detailsCountAggregateOutputType | null
    _avg: Clinic_staff_detailsAvgAggregateOutputType | null
    _sum: Clinic_staff_detailsSumAggregateOutputType | null
    _min: Clinic_staff_detailsMinAggregateOutputType | null
    _max: Clinic_staff_detailsMaxAggregateOutputType | null
  }

  export type Clinic_staff_detailsAvgAggregateOutputType = {
    clinic_staff_contact_id: number | null
    staff_id: number | null
  }

  export type Clinic_staff_detailsSumAggregateOutputType = {
    clinic_staff_contact_id: bigint | null
    staff_id: bigint | null
  }

  export type Clinic_staff_detailsMinAggregateOutputType = {
    clinic_staff_contact_id: bigint | null
    staff_id: bigint | null
    staff_contact: string | null
    staff_address: string | null
  }

  export type Clinic_staff_detailsMaxAggregateOutputType = {
    clinic_staff_contact_id: bigint | null
    staff_id: bigint | null
    staff_contact: string | null
    staff_address: string | null
  }

  export type Clinic_staff_detailsCountAggregateOutputType = {
    clinic_staff_contact_id: number
    staff_id: number
    staff_contact: number
    staff_address: number
    _all: number
  }


  export type Clinic_staff_detailsAvgAggregateInputType = {
    clinic_staff_contact_id?: true
    staff_id?: true
  }

  export type Clinic_staff_detailsSumAggregateInputType = {
    clinic_staff_contact_id?: true
    staff_id?: true
  }

  export type Clinic_staff_detailsMinAggregateInputType = {
    clinic_staff_contact_id?: true
    staff_id?: true
    staff_contact?: true
    staff_address?: true
  }

  export type Clinic_staff_detailsMaxAggregateInputType = {
    clinic_staff_contact_id?: true
    staff_id?: true
    staff_contact?: true
    staff_address?: true
  }

  export type Clinic_staff_detailsCountAggregateInputType = {
    clinic_staff_contact_id?: true
    staff_id?: true
    staff_contact?: true
    staff_address?: true
    _all?: true
  }

  export type Clinic_staff_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinic_staff_details to aggregate.
     */
    where?: clinic_staff_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_staff_details to fetch.
     */
    orderBy?: clinic_staff_detailsOrderByWithRelationInput | clinic_staff_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clinic_staff_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_staff_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_staff_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clinic_staff_details
    **/
    _count?: true | Clinic_staff_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Clinic_staff_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Clinic_staff_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Clinic_staff_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Clinic_staff_detailsMaxAggregateInputType
  }

  export type GetClinic_staff_detailsAggregateType<T extends Clinic_staff_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateClinic_staff_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinic_staff_details[P]>
      : GetScalarType<T[P], AggregateClinic_staff_details[P]>
  }




  export type clinic_staff_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clinic_staff_detailsWhereInput
    orderBy?: clinic_staff_detailsOrderByWithAggregationInput | clinic_staff_detailsOrderByWithAggregationInput[]
    by: Clinic_staff_detailsScalarFieldEnum[] | Clinic_staff_detailsScalarFieldEnum
    having?: clinic_staff_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Clinic_staff_detailsCountAggregateInputType | true
    _avg?: Clinic_staff_detailsAvgAggregateInputType
    _sum?: Clinic_staff_detailsSumAggregateInputType
    _min?: Clinic_staff_detailsMinAggregateInputType
    _max?: Clinic_staff_detailsMaxAggregateInputType
  }

  export type Clinic_staff_detailsGroupByOutputType = {
    clinic_staff_contact_id: bigint
    staff_id: bigint
    staff_contact: string | null
    staff_address: string | null
    _count: Clinic_staff_detailsCountAggregateOutputType | null
    _avg: Clinic_staff_detailsAvgAggregateOutputType | null
    _sum: Clinic_staff_detailsSumAggregateOutputType | null
    _min: Clinic_staff_detailsMinAggregateOutputType | null
    _max: Clinic_staff_detailsMaxAggregateOutputType | null
  }

  type GetClinic_staff_detailsGroupByPayload<T extends clinic_staff_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Clinic_staff_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Clinic_staff_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Clinic_staff_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Clinic_staff_detailsGroupByOutputType[P]>
        }
      >
    >


  export type clinic_staff_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clinic_staff_contact_id?: boolean
    staff_id?: boolean
    staff_contact?: boolean
    staff_address?: boolean
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic_staff_details"]>

  export type clinic_staff_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clinic_staff_contact_id?: boolean
    staff_id?: boolean
    staff_contact?: boolean
    staff_address?: boolean
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic_staff_details"]>

  export type clinic_staff_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clinic_staff_contact_id?: boolean
    staff_id?: boolean
    staff_contact?: boolean
    staff_address?: boolean
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic_staff_details"]>

  export type clinic_staff_detailsSelectScalar = {
    clinic_staff_contact_id?: boolean
    staff_id?: boolean
    staff_contact?: boolean
    staff_address?: boolean
  }

  export type clinic_staff_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"clinic_staff_contact_id" | "staff_id" | "staff_contact" | "staff_address", ExtArgs["result"]["clinic_staff_details"]>
  export type clinic_staff_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }
  export type clinic_staff_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }
  export type clinic_staff_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }

  export type $clinic_staff_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clinic_staff_details"
    objects: {
      clinic_staff: Prisma.$clinic_staffPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      clinic_staff_contact_id: bigint
      staff_id: bigint
      staff_contact: string | null
      staff_address: string | null
    }, ExtArgs["result"]["clinic_staff_details"]>
    composites: {}
  }

  type clinic_staff_detailsGetPayload<S extends boolean | null | undefined | clinic_staff_detailsDefaultArgs> = $Result.GetResult<Prisma.$clinic_staff_detailsPayload, S>

  type clinic_staff_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clinic_staff_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Clinic_staff_detailsCountAggregateInputType | true
    }

  export interface clinic_staff_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clinic_staff_details'], meta: { name: 'clinic_staff_details' } }
    /**
     * Find zero or one Clinic_staff_details that matches the filter.
     * @param {clinic_staff_detailsFindUniqueArgs} args - Arguments to find a Clinic_staff_details
     * @example
     * // Get one Clinic_staff_details
     * const clinic_staff_details = await prisma.clinic_staff_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clinic_staff_detailsFindUniqueArgs>(args: SelectSubset<T, clinic_staff_detailsFindUniqueArgs<ExtArgs>>): Prisma__clinic_staff_detailsClient<$Result.GetResult<Prisma.$clinic_staff_detailsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Clinic_staff_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clinic_staff_detailsFindUniqueOrThrowArgs} args - Arguments to find a Clinic_staff_details
     * @example
     * // Get one Clinic_staff_details
     * const clinic_staff_details = await prisma.clinic_staff_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clinic_staff_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, clinic_staff_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clinic_staff_detailsClient<$Result.GetResult<Prisma.$clinic_staff_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Clinic_staff_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_staff_detailsFindFirstArgs} args - Arguments to find a Clinic_staff_details
     * @example
     * // Get one Clinic_staff_details
     * const clinic_staff_details = await prisma.clinic_staff_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clinic_staff_detailsFindFirstArgs>(args?: SelectSubset<T, clinic_staff_detailsFindFirstArgs<ExtArgs>>): Prisma__clinic_staff_detailsClient<$Result.GetResult<Prisma.$clinic_staff_detailsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Clinic_staff_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_staff_detailsFindFirstOrThrowArgs} args - Arguments to find a Clinic_staff_details
     * @example
     * // Get one Clinic_staff_details
     * const clinic_staff_details = await prisma.clinic_staff_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clinic_staff_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, clinic_staff_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__clinic_staff_detailsClient<$Result.GetResult<Prisma.$clinic_staff_detailsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Clinic_staff_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_staff_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinic_staff_details
     * const clinic_staff_details = await prisma.clinic_staff_details.findMany()
     * 
     * // Get first 10 Clinic_staff_details
     * const clinic_staff_details = await prisma.clinic_staff_details.findMany({ take: 10 })
     * 
     * // Only select the `clinic_staff_contact_id`
     * const clinic_staff_detailsWithClinic_staff_contact_idOnly = await prisma.clinic_staff_details.findMany({ select: { clinic_staff_contact_id: true } })
     * 
     */
    findMany<T extends clinic_staff_detailsFindManyArgs>(args?: SelectSubset<T, clinic_staff_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinic_staff_detailsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Clinic_staff_details.
     * @param {clinic_staff_detailsCreateArgs} args - Arguments to create a Clinic_staff_details.
     * @example
     * // Create one Clinic_staff_details
     * const Clinic_staff_details = await prisma.clinic_staff_details.create({
     *   data: {
     *     // ... data to create a Clinic_staff_details
     *   }
     * })
     * 
     */
    create<T extends clinic_staff_detailsCreateArgs>(args: SelectSubset<T, clinic_staff_detailsCreateArgs<ExtArgs>>): Prisma__clinic_staff_detailsClient<$Result.GetResult<Prisma.$clinic_staff_detailsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Clinic_staff_details.
     * @param {clinic_staff_detailsCreateManyArgs} args - Arguments to create many Clinic_staff_details.
     * @example
     * // Create many Clinic_staff_details
     * const clinic_staff_details = await prisma.clinic_staff_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clinic_staff_detailsCreateManyArgs>(args?: SelectSubset<T, clinic_staff_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clinic_staff_details and returns the data saved in the database.
     * @param {clinic_staff_detailsCreateManyAndReturnArgs} args - Arguments to create many Clinic_staff_details.
     * @example
     * // Create many Clinic_staff_details
     * const clinic_staff_details = await prisma.clinic_staff_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clinic_staff_details and only return the `clinic_staff_contact_id`
     * const clinic_staff_detailsWithClinic_staff_contact_idOnly = await prisma.clinic_staff_details.createManyAndReturn({
     *   select: { clinic_staff_contact_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends clinic_staff_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, clinic_staff_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinic_staff_detailsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Clinic_staff_details.
     * @param {clinic_staff_detailsDeleteArgs} args - Arguments to delete one Clinic_staff_details.
     * @example
     * // Delete one Clinic_staff_details
     * const Clinic_staff_details = await prisma.clinic_staff_details.delete({
     *   where: {
     *     // ... filter to delete one Clinic_staff_details
     *   }
     * })
     * 
     */
    delete<T extends clinic_staff_detailsDeleteArgs>(args: SelectSubset<T, clinic_staff_detailsDeleteArgs<ExtArgs>>): Prisma__clinic_staff_detailsClient<$Result.GetResult<Prisma.$clinic_staff_detailsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Clinic_staff_details.
     * @param {clinic_staff_detailsUpdateArgs} args - Arguments to update one Clinic_staff_details.
     * @example
     * // Update one Clinic_staff_details
     * const clinic_staff_details = await prisma.clinic_staff_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clinic_staff_detailsUpdateArgs>(args: SelectSubset<T, clinic_staff_detailsUpdateArgs<ExtArgs>>): Prisma__clinic_staff_detailsClient<$Result.GetResult<Prisma.$clinic_staff_detailsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Clinic_staff_details.
     * @param {clinic_staff_detailsDeleteManyArgs} args - Arguments to filter Clinic_staff_details to delete.
     * @example
     * // Delete a few Clinic_staff_details
     * const { count } = await prisma.clinic_staff_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clinic_staff_detailsDeleteManyArgs>(args?: SelectSubset<T, clinic_staff_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinic_staff_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_staff_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinic_staff_details
     * const clinic_staff_details = await prisma.clinic_staff_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clinic_staff_detailsUpdateManyArgs>(args: SelectSubset<T, clinic_staff_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinic_staff_details and returns the data updated in the database.
     * @param {clinic_staff_detailsUpdateManyAndReturnArgs} args - Arguments to update many Clinic_staff_details.
     * @example
     * // Update many Clinic_staff_details
     * const clinic_staff_details = await prisma.clinic_staff_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clinic_staff_details and only return the `clinic_staff_contact_id`
     * const clinic_staff_detailsWithClinic_staff_contact_idOnly = await prisma.clinic_staff_details.updateManyAndReturn({
     *   select: { clinic_staff_contact_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends clinic_staff_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, clinic_staff_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinic_staff_detailsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Clinic_staff_details.
     * @param {clinic_staff_detailsUpsertArgs} args - Arguments to update or create a Clinic_staff_details.
     * @example
     * // Update or create a Clinic_staff_details
     * const clinic_staff_details = await prisma.clinic_staff_details.upsert({
     *   create: {
     *     // ... data to create a Clinic_staff_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinic_staff_details we want to update
     *   }
     * })
     */
    upsert<T extends clinic_staff_detailsUpsertArgs>(args: SelectSubset<T, clinic_staff_detailsUpsertArgs<ExtArgs>>): Prisma__clinic_staff_detailsClient<$Result.GetResult<Prisma.$clinic_staff_detailsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Clinic_staff_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_staff_detailsCountArgs} args - Arguments to filter Clinic_staff_details to count.
     * @example
     * // Count the number of Clinic_staff_details
     * const count = await prisma.clinic_staff_details.count({
     *   where: {
     *     // ... the filter for the Clinic_staff_details we want to count
     *   }
     * })
    **/
    count<T extends clinic_staff_detailsCountArgs>(
      args?: Subset<T, clinic_staff_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Clinic_staff_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinic_staff_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Clinic_staff_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Clinic_staff_detailsAggregateArgs>(args: Subset<T, Clinic_staff_detailsAggregateArgs>): Prisma.PrismaPromise<GetClinic_staff_detailsAggregateType<T>>

    /**
     * Group by Clinic_staff_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinic_staff_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clinic_staff_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clinic_staff_detailsGroupByArgs['orderBy'] }
        : { orderBy?: clinic_staff_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clinic_staff_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinic_staff_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clinic_staff_details model
   */
  readonly fields: clinic_staff_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clinic_staff_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clinic_staff_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic_staff<T extends clinic_staffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clinic_staffDefaultArgs<ExtArgs>>): Prisma__clinic_staffClient<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clinic_staff_details model
   */ 
  interface clinic_staff_detailsFieldRefs {
    readonly clinic_staff_contact_id: FieldRef<"clinic_staff_details", 'BigInt'>
    readonly staff_id: FieldRef<"clinic_staff_details", 'BigInt'>
    readonly staff_contact: FieldRef<"clinic_staff_details", 'String'>
    readonly staff_address: FieldRef<"clinic_staff_details", 'String'>
  }
    

  // Custom InputTypes
  /**
   * clinic_staff_details findUnique
   */
  export type clinic_staff_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff_details
     */
    select?: clinic_staff_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff_details
     */
    omit?: clinic_staff_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staff_detailsInclude<ExtArgs> | null
    /**
     * Filter, which clinic_staff_details to fetch.
     */
    where: clinic_staff_detailsWhereUniqueInput
  }

  /**
   * clinic_staff_details findUniqueOrThrow
   */
  export type clinic_staff_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff_details
     */
    select?: clinic_staff_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff_details
     */
    omit?: clinic_staff_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staff_detailsInclude<ExtArgs> | null
    /**
     * Filter, which clinic_staff_details to fetch.
     */
    where: clinic_staff_detailsWhereUniqueInput
  }

  /**
   * clinic_staff_details findFirst
   */
  export type clinic_staff_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff_details
     */
    select?: clinic_staff_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff_details
     */
    omit?: clinic_staff_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staff_detailsInclude<ExtArgs> | null
    /**
     * Filter, which clinic_staff_details to fetch.
     */
    where?: clinic_staff_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_staff_details to fetch.
     */
    orderBy?: clinic_staff_detailsOrderByWithRelationInput | clinic_staff_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinic_staff_details.
     */
    cursor?: clinic_staff_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_staff_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_staff_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinic_staff_details.
     */
    distinct?: Clinic_staff_detailsScalarFieldEnum | Clinic_staff_detailsScalarFieldEnum[]
  }

  /**
   * clinic_staff_details findFirstOrThrow
   */
  export type clinic_staff_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff_details
     */
    select?: clinic_staff_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff_details
     */
    omit?: clinic_staff_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staff_detailsInclude<ExtArgs> | null
    /**
     * Filter, which clinic_staff_details to fetch.
     */
    where?: clinic_staff_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_staff_details to fetch.
     */
    orderBy?: clinic_staff_detailsOrderByWithRelationInput | clinic_staff_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinic_staff_details.
     */
    cursor?: clinic_staff_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_staff_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_staff_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinic_staff_details.
     */
    distinct?: Clinic_staff_detailsScalarFieldEnum | Clinic_staff_detailsScalarFieldEnum[]
  }

  /**
   * clinic_staff_details findMany
   */
  export type clinic_staff_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff_details
     */
    select?: clinic_staff_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff_details
     */
    omit?: clinic_staff_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staff_detailsInclude<ExtArgs> | null
    /**
     * Filter, which clinic_staff_details to fetch.
     */
    where?: clinic_staff_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinic_staff_details to fetch.
     */
    orderBy?: clinic_staff_detailsOrderByWithRelationInput | clinic_staff_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clinic_staff_details.
     */
    cursor?: clinic_staff_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinic_staff_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinic_staff_details.
     */
    skip?: number
    distinct?: Clinic_staff_detailsScalarFieldEnum | Clinic_staff_detailsScalarFieldEnum[]
  }

  /**
   * clinic_staff_details create
   */
  export type clinic_staff_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff_details
     */
    select?: clinic_staff_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff_details
     */
    omit?: clinic_staff_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staff_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a clinic_staff_details.
     */
    data: XOR<clinic_staff_detailsCreateInput, clinic_staff_detailsUncheckedCreateInput>
  }

  /**
   * clinic_staff_details createMany
   */
  export type clinic_staff_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clinic_staff_details.
     */
    data: clinic_staff_detailsCreateManyInput | clinic_staff_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clinic_staff_details createManyAndReturn
   */
  export type clinic_staff_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff_details
     */
    select?: clinic_staff_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff_details
     */
    omit?: clinic_staff_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many clinic_staff_details.
     */
    data: clinic_staff_detailsCreateManyInput | clinic_staff_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staff_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * clinic_staff_details update
   */
  export type clinic_staff_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff_details
     */
    select?: clinic_staff_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff_details
     */
    omit?: clinic_staff_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staff_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a clinic_staff_details.
     */
    data: XOR<clinic_staff_detailsUpdateInput, clinic_staff_detailsUncheckedUpdateInput>
    /**
     * Choose, which clinic_staff_details to update.
     */
    where: clinic_staff_detailsWhereUniqueInput
  }

  /**
   * clinic_staff_details updateMany
   */
  export type clinic_staff_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clinic_staff_details.
     */
    data: XOR<clinic_staff_detailsUpdateManyMutationInput, clinic_staff_detailsUncheckedUpdateManyInput>
    /**
     * Filter which clinic_staff_details to update
     */
    where?: clinic_staff_detailsWhereInput
    /**
     * Limit how many clinic_staff_details to update.
     */
    limit?: number
  }

  /**
   * clinic_staff_details updateManyAndReturn
   */
  export type clinic_staff_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff_details
     */
    select?: clinic_staff_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff_details
     */
    omit?: clinic_staff_detailsOmit<ExtArgs> | null
    /**
     * The data used to update clinic_staff_details.
     */
    data: XOR<clinic_staff_detailsUpdateManyMutationInput, clinic_staff_detailsUncheckedUpdateManyInput>
    /**
     * Filter which clinic_staff_details to update
     */
    where?: clinic_staff_detailsWhereInput
    /**
     * Limit how many clinic_staff_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staff_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * clinic_staff_details upsert
   */
  export type clinic_staff_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff_details
     */
    select?: clinic_staff_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff_details
     */
    omit?: clinic_staff_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staff_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the clinic_staff_details to update in case it exists.
     */
    where: clinic_staff_detailsWhereUniqueInput
    /**
     * In case the clinic_staff_details found by the `where` argument doesn't exist, create a new clinic_staff_details with this data.
     */
    create: XOR<clinic_staff_detailsCreateInput, clinic_staff_detailsUncheckedCreateInput>
    /**
     * In case the clinic_staff_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clinic_staff_detailsUpdateInput, clinic_staff_detailsUncheckedUpdateInput>
  }

  /**
   * clinic_staff_details delete
   */
  export type clinic_staff_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff_details
     */
    select?: clinic_staff_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff_details
     */
    omit?: clinic_staff_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staff_detailsInclude<ExtArgs> | null
    /**
     * Filter which clinic_staff_details to delete.
     */
    where: clinic_staff_detailsWhereUniqueInput
  }

  /**
   * clinic_staff_details deleteMany
   */
  export type clinic_staff_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinic_staff_details to delete
     */
    where?: clinic_staff_detailsWhereInput
    /**
     * Limit how many clinic_staff_details to delete.
     */
    limit?: number
  }

  /**
   * clinic_staff_details without action
   */
  export type clinic_staff_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic_staff_details
     */
    select?: clinic_staff_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clinic_staff_details
     */
    omit?: clinic_staff_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinic_staff_detailsInclude<ExtArgs> | null
  }


  /**
   * Model guardian
   */

  export type AggregateGuardian = {
    _count: GuardianCountAggregateOutputType | null
    _avg: GuardianAvgAggregateOutputType | null
    _sum: GuardianSumAggregateOutputType | null
    _min: GuardianMinAggregateOutputType | null
    _max: GuardianMaxAggregateOutputType | null
  }

  export type GuardianAvgAggregateOutputType = {
    guardian_id: number | null
    patient_details_id: number | null
  }

  export type GuardianSumAggregateOutputType = {
    guardian_id: bigint | null
    patient_details_id: bigint | null
  }

  export type GuardianMinAggregateOutputType = {
    guardian_id: bigint | null
    patient_details_id: bigint | null
    guardian_name: string | null
    guardian_contact: string | null
  }

  export type GuardianMaxAggregateOutputType = {
    guardian_id: bigint | null
    patient_details_id: bigint | null
    guardian_name: string | null
    guardian_contact: string | null
  }

  export type GuardianCountAggregateOutputType = {
    guardian_id: number
    patient_details_id: number
    guardian_name: number
    guardian_contact: number
    _all: number
  }


  export type GuardianAvgAggregateInputType = {
    guardian_id?: true
    patient_details_id?: true
  }

  export type GuardianSumAggregateInputType = {
    guardian_id?: true
    patient_details_id?: true
  }

  export type GuardianMinAggregateInputType = {
    guardian_id?: true
    patient_details_id?: true
    guardian_name?: true
    guardian_contact?: true
  }

  export type GuardianMaxAggregateInputType = {
    guardian_id?: true
    patient_details_id?: true
    guardian_name?: true
    guardian_contact?: true
  }

  export type GuardianCountAggregateInputType = {
    guardian_id?: true
    patient_details_id?: true
    guardian_name?: true
    guardian_contact?: true
    _all?: true
  }

  export type GuardianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guardian to aggregate.
     */
    where?: guardianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guardians to fetch.
     */
    orderBy?: guardianOrderByWithRelationInput | guardianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guardianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guardians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guardians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guardians
    **/
    _count?: true | GuardianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuardianAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuardianSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuardianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuardianMaxAggregateInputType
  }

  export type GetGuardianAggregateType<T extends GuardianAggregateArgs> = {
        [P in keyof T & keyof AggregateGuardian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuardian[P]>
      : GetScalarType<T[P], AggregateGuardian[P]>
  }




  export type guardianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: guardianWhereInput
    orderBy?: guardianOrderByWithAggregationInput | guardianOrderByWithAggregationInput[]
    by: GuardianScalarFieldEnum[] | GuardianScalarFieldEnum
    having?: guardianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuardianCountAggregateInputType | true
    _avg?: GuardianAvgAggregateInputType
    _sum?: GuardianSumAggregateInputType
    _min?: GuardianMinAggregateInputType
    _max?: GuardianMaxAggregateInputType
  }

  export type GuardianGroupByOutputType = {
    guardian_id: bigint
    patient_details_id: bigint
    guardian_name: string | null
    guardian_contact: string | null
    _count: GuardianCountAggregateOutputType | null
    _avg: GuardianAvgAggregateOutputType | null
    _sum: GuardianSumAggregateOutputType | null
    _min: GuardianMinAggregateOutputType | null
    _max: GuardianMaxAggregateOutputType | null
  }

  type GetGuardianGroupByPayload<T extends guardianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuardianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuardianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuardianGroupByOutputType[P]>
            : GetScalarType<T[P], GuardianGroupByOutputType[P]>
        }
      >
    >


  export type guardianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    guardian_id?: boolean
    patient_details_id?: boolean
    guardian_name?: boolean
    guardian_contact?: boolean
  }, ExtArgs["result"]["guardian"]>

  export type guardianSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    guardian_id?: boolean
    patient_details_id?: boolean
    guardian_name?: boolean
    guardian_contact?: boolean
  }, ExtArgs["result"]["guardian"]>

  export type guardianSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    guardian_id?: boolean
    patient_details_id?: boolean
    guardian_name?: boolean
    guardian_contact?: boolean
  }, ExtArgs["result"]["guardian"]>

  export type guardianSelectScalar = {
    guardian_id?: boolean
    patient_details_id?: boolean
    guardian_name?: boolean
    guardian_contact?: boolean
  }

  export type guardianOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"guardian_id" | "patient_details_id" | "guardian_name" | "guardian_contact", ExtArgs["result"]["guardian"]>

  export type $guardianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "guardian"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      guardian_id: bigint
      patient_details_id: bigint
      guardian_name: string | null
      guardian_contact: string | null
    }, ExtArgs["result"]["guardian"]>
    composites: {}
  }

  type guardianGetPayload<S extends boolean | null | undefined | guardianDefaultArgs> = $Result.GetResult<Prisma.$guardianPayload, S>

  type guardianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<guardianFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuardianCountAggregateInputType | true
    }

  export interface guardianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guardian'], meta: { name: 'guardian' } }
    /**
     * Find zero or one Guardian that matches the filter.
     * @param {guardianFindUniqueArgs} args - Arguments to find a Guardian
     * @example
     * // Get one Guardian
     * const guardian = await prisma.guardian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends guardianFindUniqueArgs>(args: SelectSubset<T, guardianFindUniqueArgs<ExtArgs>>): Prisma__guardianClient<$Result.GetResult<Prisma.$guardianPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Guardian that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {guardianFindUniqueOrThrowArgs} args - Arguments to find a Guardian
     * @example
     * // Get one Guardian
     * const guardian = await prisma.guardian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends guardianFindUniqueOrThrowArgs>(args: SelectSubset<T, guardianFindUniqueOrThrowArgs<ExtArgs>>): Prisma__guardianClient<$Result.GetResult<Prisma.$guardianPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Guardian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guardianFindFirstArgs} args - Arguments to find a Guardian
     * @example
     * // Get one Guardian
     * const guardian = await prisma.guardian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends guardianFindFirstArgs>(args?: SelectSubset<T, guardianFindFirstArgs<ExtArgs>>): Prisma__guardianClient<$Result.GetResult<Prisma.$guardianPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Guardian that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guardianFindFirstOrThrowArgs} args - Arguments to find a Guardian
     * @example
     * // Get one Guardian
     * const guardian = await prisma.guardian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends guardianFindFirstOrThrowArgs>(args?: SelectSubset<T, guardianFindFirstOrThrowArgs<ExtArgs>>): Prisma__guardianClient<$Result.GetResult<Prisma.$guardianPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Guardians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guardianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guardians
     * const guardians = await prisma.guardian.findMany()
     * 
     * // Get first 10 Guardians
     * const guardians = await prisma.guardian.findMany({ take: 10 })
     * 
     * // Only select the `guardian_id`
     * const guardianWithGuardian_idOnly = await prisma.guardian.findMany({ select: { guardian_id: true } })
     * 
     */
    findMany<T extends guardianFindManyArgs>(args?: SelectSubset<T, guardianFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guardianPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Guardian.
     * @param {guardianCreateArgs} args - Arguments to create a Guardian.
     * @example
     * // Create one Guardian
     * const Guardian = await prisma.guardian.create({
     *   data: {
     *     // ... data to create a Guardian
     *   }
     * })
     * 
     */
    create<T extends guardianCreateArgs>(args: SelectSubset<T, guardianCreateArgs<ExtArgs>>): Prisma__guardianClient<$Result.GetResult<Prisma.$guardianPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Guardians.
     * @param {guardianCreateManyArgs} args - Arguments to create many Guardians.
     * @example
     * // Create many Guardians
     * const guardian = await prisma.guardian.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends guardianCreateManyArgs>(args?: SelectSubset<T, guardianCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Guardians and returns the data saved in the database.
     * @param {guardianCreateManyAndReturnArgs} args - Arguments to create many Guardians.
     * @example
     * // Create many Guardians
     * const guardian = await prisma.guardian.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Guardians and only return the `guardian_id`
     * const guardianWithGuardian_idOnly = await prisma.guardian.createManyAndReturn({
     *   select: { guardian_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends guardianCreateManyAndReturnArgs>(args?: SelectSubset<T, guardianCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guardianPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Guardian.
     * @param {guardianDeleteArgs} args - Arguments to delete one Guardian.
     * @example
     * // Delete one Guardian
     * const Guardian = await prisma.guardian.delete({
     *   where: {
     *     // ... filter to delete one Guardian
     *   }
     * })
     * 
     */
    delete<T extends guardianDeleteArgs>(args: SelectSubset<T, guardianDeleteArgs<ExtArgs>>): Prisma__guardianClient<$Result.GetResult<Prisma.$guardianPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Guardian.
     * @param {guardianUpdateArgs} args - Arguments to update one Guardian.
     * @example
     * // Update one Guardian
     * const guardian = await prisma.guardian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends guardianUpdateArgs>(args: SelectSubset<T, guardianUpdateArgs<ExtArgs>>): Prisma__guardianClient<$Result.GetResult<Prisma.$guardianPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Guardians.
     * @param {guardianDeleteManyArgs} args - Arguments to filter Guardians to delete.
     * @example
     * // Delete a few Guardians
     * const { count } = await prisma.guardian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends guardianDeleteManyArgs>(args?: SelectSubset<T, guardianDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guardians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guardianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guardians
     * const guardian = await prisma.guardian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends guardianUpdateManyArgs>(args: SelectSubset<T, guardianUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guardians and returns the data updated in the database.
     * @param {guardianUpdateManyAndReturnArgs} args - Arguments to update many Guardians.
     * @example
     * // Update many Guardians
     * const guardian = await prisma.guardian.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Guardians and only return the `guardian_id`
     * const guardianWithGuardian_idOnly = await prisma.guardian.updateManyAndReturn({
     *   select: { guardian_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends guardianUpdateManyAndReturnArgs>(args: SelectSubset<T, guardianUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guardianPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Guardian.
     * @param {guardianUpsertArgs} args - Arguments to update or create a Guardian.
     * @example
     * // Update or create a Guardian
     * const guardian = await prisma.guardian.upsert({
     *   create: {
     *     // ... data to create a Guardian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guardian we want to update
     *   }
     * })
     */
    upsert<T extends guardianUpsertArgs>(args: SelectSubset<T, guardianUpsertArgs<ExtArgs>>): Prisma__guardianClient<$Result.GetResult<Prisma.$guardianPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Guardians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guardianCountArgs} args - Arguments to filter Guardians to count.
     * @example
     * // Count the number of Guardians
     * const count = await prisma.guardian.count({
     *   where: {
     *     // ... the filter for the Guardians we want to count
     *   }
     * })
    **/
    count<T extends guardianCountArgs>(
      args?: Subset<T, guardianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuardianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guardian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuardianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuardianAggregateArgs>(args: Subset<T, GuardianAggregateArgs>): Prisma.PrismaPromise<GetGuardianAggregateType<T>>

    /**
     * Group by Guardian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guardianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends guardianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: guardianGroupByArgs['orderBy'] }
        : { orderBy?: guardianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, guardianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuardianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the guardian model
   */
  readonly fields: guardianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for guardian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__guardianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the guardian model
   */ 
  interface guardianFieldRefs {
    readonly guardian_id: FieldRef<"guardian", 'BigInt'>
    readonly patient_details_id: FieldRef<"guardian", 'BigInt'>
    readonly guardian_name: FieldRef<"guardian", 'String'>
    readonly guardian_contact: FieldRef<"guardian", 'String'>
  }
    

  // Custom InputTypes
  /**
   * guardian findUnique
   */
  export type guardianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guardian
     */
    select?: guardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guardian
     */
    omit?: guardianOmit<ExtArgs> | null
    /**
     * Filter, which guardian to fetch.
     */
    where: guardianWhereUniqueInput
  }

  /**
   * guardian findUniqueOrThrow
   */
  export type guardianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guardian
     */
    select?: guardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guardian
     */
    omit?: guardianOmit<ExtArgs> | null
    /**
     * Filter, which guardian to fetch.
     */
    where: guardianWhereUniqueInput
  }

  /**
   * guardian findFirst
   */
  export type guardianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guardian
     */
    select?: guardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guardian
     */
    omit?: guardianOmit<ExtArgs> | null
    /**
     * Filter, which guardian to fetch.
     */
    where?: guardianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guardians to fetch.
     */
    orderBy?: guardianOrderByWithRelationInput | guardianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guardians.
     */
    cursor?: guardianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guardians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guardians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guardians.
     */
    distinct?: GuardianScalarFieldEnum | GuardianScalarFieldEnum[]
  }

  /**
   * guardian findFirstOrThrow
   */
  export type guardianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guardian
     */
    select?: guardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guardian
     */
    omit?: guardianOmit<ExtArgs> | null
    /**
     * Filter, which guardian to fetch.
     */
    where?: guardianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guardians to fetch.
     */
    orderBy?: guardianOrderByWithRelationInput | guardianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guardians.
     */
    cursor?: guardianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guardians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guardians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guardians.
     */
    distinct?: GuardianScalarFieldEnum | GuardianScalarFieldEnum[]
  }

  /**
   * guardian findMany
   */
  export type guardianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guardian
     */
    select?: guardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guardian
     */
    omit?: guardianOmit<ExtArgs> | null
    /**
     * Filter, which guardians to fetch.
     */
    where?: guardianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guardians to fetch.
     */
    orderBy?: guardianOrderByWithRelationInput | guardianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guardians.
     */
    cursor?: guardianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guardians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guardians.
     */
    skip?: number
    distinct?: GuardianScalarFieldEnum | GuardianScalarFieldEnum[]
  }

  /**
   * guardian create
   */
  export type guardianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guardian
     */
    select?: guardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guardian
     */
    omit?: guardianOmit<ExtArgs> | null
    /**
     * The data needed to create a guardian.
     */
    data: XOR<guardianCreateInput, guardianUncheckedCreateInput>
  }

  /**
   * guardian createMany
   */
  export type guardianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guardians.
     */
    data: guardianCreateManyInput | guardianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * guardian createManyAndReturn
   */
  export type guardianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guardian
     */
    select?: guardianSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the guardian
     */
    omit?: guardianOmit<ExtArgs> | null
    /**
     * The data used to create many guardians.
     */
    data: guardianCreateManyInput | guardianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * guardian update
   */
  export type guardianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guardian
     */
    select?: guardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guardian
     */
    omit?: guardianOmit<ExtArgs> | null
    /**
     * The data needed to update a guardian.
     */
    data: XOR<guardianUpdateInput, guardianUncheckedUpdateInput>
    /**
     * Choose, which guardian to update.
     */
    where: guardianWhereUniqueInput
  }

  /**
   * guardian updateMany
   */
  export type guardianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guardians.
     */
    data: XOR<guardianUpdateManyMutationInput, guardianUncheckedUpdateManyInput>
    /**
     * Filter which guardians to update
     */
    where?: guardianWhereInput
    /**
     * Limit how many guardians to update.
     */
    limit?: number
  }

  /**
   * guardian updateManyAndReturn
   */
  export type guardianUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guardian
     */
    select?: guardianSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the guardian
     */
    omit?: guardianOmit<ExtArgs> | null
    /**
     * The data used to update guardians.
     */
    data: XOR<guardianUpdateManyMutationInput, guardianUncheckedUpdateManyInput>
    /**
     * Filter which guardians to update
     */
    where?: guardianWhereInput
    /**
     * Limit how many guardians to update.
     */
    limit?: number
  }

  /**
   * guardian upsert
   */
  export type guardianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guardian
     */
    select?: guardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guardian
     */
    omit?: guardianOmit<ExtArgs> | null
    /**
     * The filter to search for the guardian to update in case it exists.
     */
    where: guardianWhereUniqueInput
    /**
     * In case the guardian found by the `where` argument doesn't exist, create a new guardian with this data.
     */
    create: XOR<guardianCreateInput, guardianUncheckedCreateInput>
    /**
     * In case the guardian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guardianUpdateInput, guardianUncheckedUpdateInput>
  }

  /**
   * guardian delete
   */
  export type guardianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guardian
     */
    select?: guardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guardian
     */
    omit?: guardianOmit<ExtArgs> | null
    /**
     * Filter which guardian to delete.
     */
    where: guardianWhereUniqueInput
  }

  /**
   * guardian deleteMany
   */
  export type guardianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guardians to delete
     */
    where?: guardianWhereInput
    /**
     * Limit how many guardians to delete.
     */
    limit?: number
  }

  /**
   * guardian without action
   */
  export type guardianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guardian
     */
    select?: guardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guardian
     */
    omit?: guardianOmit<ExtArgs> | null
  }


  /**
   * Model mode_of_payment
   */

  export type AggregateMode_of_payment = {
    _count: Mode_of_paymentCountAggregateOutputType | null
    _avg: Mode_of_paymentAvgAggregateOutputType | null
    _sum: Mode_of_paymentSumAggregateOutputType | null
    _min: Mode_of_paymentMinAggregateOutputType | null
    _max: Mode_of_paymentMaxAggregateOutputType | null
  }

  export type Mode_of_paymentAvgAggregateOutputType = {
    mode_of_payment_id: number | null
  }

  export type Mode_of_paymentSumAggregateOutputType = {
    mode_of_payment_id: bigint | null
  }

  export type Mode_of_paymentMinAggregateOutputType = {
    mode_of_payment_id: bigint | null
    mode_of_payment: string | null
  }

  export type Mode_of_paymentMaxAggregateOutputType = {
    mode_of_payment_id: bigint | null
    mode_of_payment: string | null
  }

  export type Mode_of_paymentCountAggregateOutputType = {
    mode_of_payment_id: number
    mode_of_payment: number
    _all: number
  }


  export type Mode_of_paymentAvgAggregateInputType = {
    mode_of_payment_id?: true
  }

  export type Mode_of_paymentSumAggregateInputType = {
    mode_of_payment_id?: true
  }

  export type Mode_of_paymentMinAggregateInputType = {
    mode_of_payment_id?: true
    mode_of_payment?: true
  }

  export type Mode_of_paymentMaxAggregateInputType = {
    mode_of_payment_id?: true
    mode_of_payment?: true
  }

  export type Mode_of_paymentCountAggregateInputType = {
    mode_of_payment_id?: true
    mode_of_payment?: true
    _all?: true
  }

  export type Mode_of_paymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mode_of_payment to aggregate.
     */
    where?: mode_of_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mode_of_payments to fetch.
     */
    orderBy?: mode_of_paymentOrderByWithRelationInput | mode_of_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mode_of_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mode_of_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mode_of_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mode_of_payments
    **/
    _count?: true | Mode_of_paymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mode_of_paymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mode_of_paymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mode_of_paymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mode_of_paymentMaxAggregateInputType
  }

  export type GetMode_of_paymentAggregateType<T extends Mode_of_paymentAggregateArgs> = {
        [P in keyof T & keyof AggregateMode_of_payment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMode_of_payment[P]>
      : GetScalarType<T[P], AggregateMode_of_payment[P]>
  }




  export type mode_of_paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mode_of_paymentWhereInput
    orderBy?: mode_of_paymentOrderByWithAggregationInput | mode_of_paymentOrderByWithAggregationInput[]
    by: Mode_of_paymentScalarFieldEnum[] | Mode_of_paymentScalarFieldEnum
    having?: mode_of_paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mode_of_paymentCountAggregateInputType | true
    _avg?: Mode_of_paymentAvgAggregateInputType
    _sum?: Mode_of_paymentSumAggregateInputType
    _min?: Mode_of_paymentMinAggregateInputType
    _max?: Mode_of_paymentMaxAggregateInputType
  }

  export type Mode_of_paymentGroupByOutputType = {
    mode_of_payment_id: bigint
    mode_of_payment: string | null
    _count: Mode_of_paymentCountAggregateOutputType | null
    _avg: Mode_of_paymentAvgAggregateOutputType | null
    _sum: Mode_of_paymentSumAggregateOutputType | null
    _min: Mode_of_paymentMinAggregateOutputType | null
    _max: Mode_of_paymentMaxAggregateOutputType | null
  }

  type GetMode_of_paymentGroupByPayload<T extends mode_of_paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mode_of_paymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mode_of_paymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mode_of_paymentGroupByOutputType[P]>
            : GetScalarType<T[P], Mode_of_paymentGroupByOutputType[P]>
        }
      >
    >


  export type mode_of_paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mode_of_payment_id?: boolean
    mode_of_payment?: boolean
  }, ExtArgs["result"]["mode_of_payment"]>

  export type mode_of_paymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mode_of_payment_id?: boolean
    mode_of_payment?: boolean
  }, ExtArgs["result"]["mode_of_payment"]>

  export type mode_of_paymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mode_of_payment_id?: boolean
    mode_of_payment?: boolean
  }, ExtArgs["result"]["mode_of_payment"]>

  export type mode_of_paymentSelectScalar = {
    mode_of_payment_id?: boolean
    mode_of_payment?: boolean
  }

  export type mode_of_paymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"mode_of_payment_id" | "mode_of_payment", ExtArgs["result"]["mode_of_payment"]>

  export type $mode_of_paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mode_of_payment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      mode_of_payment_id: bigint
      mode_of_payment: string | null
    }, ExtArgs["result"]["mode_of_payment"]>
    composites: {}
  }

  type mode_of_paymentGetPayload<S extends boolean | null | undefined | mode_of_paymentDefaultArgs> = $Result.GetResult<Prisma.$mode_of_paymentPayload, S>

  type mode_of_paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mode_of_paymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mode_of_paymentCountAggregateInputType | true
    }

  export interface mode_of_paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mode_of_payment'], meta: { name: 'mode_of_payment' } }
    /**
     * Find zero or one Mode_of_payment that matches the filter.
     * @param {mode_of_paymentFindUniqueArgs} args - Arguments to find a Mode_of_payment
     * @example
     * // Get one Mode_of_payment
     * const mode_of_payment = await prisma.mode_of_payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mode_of_paymentFindUniqueArgs>(args: SelectSubset<T, mode_of_paymentFindUniqueArgs<ExtArgs>>): Prisma__mode_of_paymentClient<$Result.GetResult<Prisma.$mode_of_paymentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Mode_of_payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mode_of_paymentFindUniqueOrThrowArgs} args - Arguments to find a Mode_of_payment
     * @example
     * // Get one Mode_of_payment
     * const mode_of_payment = await prisma.mode_of_payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mode_of_paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, mode_of_paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mode_of_paymentClient<$Result.GetResult<Prisma.$mode_of_paymentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Mode_of_payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mode_of_paymentFindFirstArgs} args - Arguments to find a Mode_of_payment
     * @example
     * // Get one Mode_of_payment
     * const mode_of_payment = await prisma.mode_of_payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mode_of_paymentFindFirstArgs>(args?: SelectSubset<T, mode_of_paymentFindFirstArgs<ExtArgs>>): Prisma__mode_of_paymentClient<$Result.GetResult<Prisma.$mode_of_paymentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Mode_of_payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mode_of_paymentFindFirstOrThrowArgs} args - Arguments to find a Mode_of_payment
     * @example
     * // Get one Mode_of_payment
     * const mode_of_payment = await prisma.mode_of_payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mode_of_paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, mode_of_paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__mode_of_paymentClient<$Result.GetResult<Prisma.$mode_of_paymentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Mode_of_payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mode_of_paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mode_of_payments
     * const mode_of_payments = await prisma.mode_of_payment.findMany()
     * 
     * // Get first 10 Mode_of_payments
     * const mode_of_payments = await prisma.mode_of_payment.findMany({ take: 10 })
     * 
     * // Only select the `mode_of_payment_id`
     * const mode_of_paymentWithMode_of_payment_idOnly = await prisma.mode_of_payment.findMany({ select: { mode_of_payment_id: true } })
     * 
     */
    findMany<T extends mode_of_paymentFindManyArgs>(args?: SelectSubset<T, mode_of_paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mode_of_paymentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Mode_of_payment.
     * @param {mode_of_paymentCreateArgs} args - Arguments to create a Mode_of_payment.
     * @example
     * // Create one Mode_of_payment
     * const Mode_of_payment = await prisma.mode_of_payment.create({
     *   data: {
     *     // ... data to create a Mode_of_payment
     *   }
     * })
     * 
     */
    create<T extends mode_of_paymentCreateArgs>(args: SelectSubset<T, mode_of_paymentCreateArgs<ExtArgs>>): Prisma__mode_of_paymentClient<$Result.GetResult<Prisma.$mode_of_paymentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Mode_of_payments.
     * @param {mode_of_paymentCreateManyArgs} args - Arguments to create many Mode_of_payments.
     * @example
     * // Create many Mode_of_payments
     * const mode_of_payment = await prisma.mode_of_payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mode_of_paymentCreateManyArgs>(args?: SelectSubset<T, mode_of_paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mode_of_payments and returns the data saved in the database.
     * @param {mode_of_paymentCreateManyAndReturnArgs} args - Arguments to create many Mode_of_payments.
     * @example
     * // Create many Mode_of_payments
     * const mode_of_payment = await prisma.mode_of_payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mode_of_payments and only return the `mode_of_payment_id`
     * const mode_of_paymentWithMode_of_payment_idOnly = await prisma.mode_of_payment.createManyAndReturn({
     *   select: { mode_of_payment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mode_of_paymentCreateManyAndReturnArgs>(args?: SelectSubset<T, mode_of_paymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mode_of_paymentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Mode_of_payment.
     * @param {mode_of_paymentDeleteArgs} args - Arguments to delete one Mode_of_payment.
     * @example
     * // Delete one Mode_of_payment
     * const Mode_of_payment = await prisma.mode_of_payment.delete({
     *   where: {
     *     // ... filter to delete one Mode_of_payment
     *   }
     * })
     * 
     */
    delete<T extends mode_of_paymentDeleteArgs>(args: SelectSubset<T, mode_of_paymentDeleteArgs<ExtArgs>>): Prisma__mode_of_paymentClient<$Result.GetResult<Prisma.$mode_of_paymentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Mode_of_payment.
     * @param {mode_of_paymentUpdateArgs} args - Arguments to update one Mode_of_payment.
     * @example
     * // Update one Mode_of_payment
     * const mode_of_payment = await prisma.mode_of_payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mode_of_paymentUpdateArgs>(args: SelectSubset<T, mode_of_paymentUpdateArgs<ExtArgs>>): Prisma__mode_of_paymentClient<$Result.GetResult<Prisma.$mode_of_paymentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Mode_of_payments.
     * @param {mode_of_paymentDeleteManyArgs} args - Arguments to filter Mode_of_payments to delete.
     * @example
     * // Delete a few Mode_of_payments
     * const { count } = await prisma.mode_of_payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mode_of_paymentDeleteManyArgs>(args?: SelectSubset<T, mode_of_paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mode_of_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mode_of_paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mode_of_payments
     * const mode_of_payment = await prisma.mode_of_payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mode_of_paymentUpdateManyArgs>(args: SelectSubset<T, mode_of_paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mode_of_payments and returns the data updated in the database.
     * @param {mode_of_paymentUpdateManyAndReturnArgs} args - Arguments to update many Mode_of_payments.
     * @example
     * // Update many Mode_of_payments
     * const mode_of_payment = await prisma.mode_of_payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mode_of_payments and only return the `mode_of_payment_id`
     * const mode_of_paymentWithMode_of_payment_idOnly = await prisma.mode_of_payment.updateManyAndReturn({
     *   select: { mode_of_payment_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mode_of_paymentUpdateManyAndReturnArgs>(args: SelectSubset<T, mode_of_paymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mode_of_paymentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Mode_of_payment.
     * @param {mode_of_paymentUpsertArgs} args - Arguments to update or create a Mode_of_payment.
     * @example
     * // Update or create a Mode_of_payment
     * const mode_of_payment = await prisma.mode_of_payment.upsert({
     *   create: {
     *     // ... data to create a Mode_of_payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mode_of_payment we want to update
     *   }
     * })
     */
    upsert<T extends mode_of_paymentUpsertArgs>(args: SelectSubset<T, mode_of_paymentUpsertArgs<ExtArgs>>): Prisma__mode_of_paymentClient<$Result.GetResult<Prisma.$mode_of_paymentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Mode_of_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mode_of_paymentCountArgs} args - Arguments to filter Mode_of_payments to count.
     * @example
     * // Count the number of Mode_of_payments
     * const count = await prisma.mode_of_payment.count({
     *   where: {
     *     // ... the filter for the Mode_of_payments we want to count
     *   }
     * })
    **/
    count<T extends mode_of_paymentCountArgs>(
      args?: Subset<T, mode_of_paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mode_of_paymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mode_of_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mode_of_paymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mode_of_paymentAggregateArgs>(args: Subset<T, Mode_of_paymentAggregateArgs>): Prisma.PrismaPromise<GetMode_of_paymentAggregateType<T>>

    /**
     * Group by Mode_of_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mode_of_paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mode_of_paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mode_of_paymentGroupByArgs['orderBy'] }
        : { orderBy?: mode_of_paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mode_of_paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMode_of_paymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mode_of_payment model
   */
  readonly fields: mode_of_paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mode_of_payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mode_of_paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mode_of_payment model
   */ 
  interface mode_of_paymentFieldRefs {
    readonly mode_of_payment_id: FieldRef<"mode_of_payment", 'BigInt'>
    readonly mode_of_payment: FieldRef<"mode_of_payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * mode_of_payment findUnique
   */
  export type mode_of_paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mode_of_payment
     */
    select?: mode_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mode_of_payment
     */
    omit?: mode_of_paymentOmit<ExtArgs> | null
    /**
     * Filter, which mode_of_payment to fetch.
     */
    where: mode_of_paymentWhereUniqueInput
  }

  /**
   * mode_of_payment findUniqueOrThrow
   */
  export type mode_of_paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mode_of_payment
     */
    select?: mode_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mode_of_payment
     */
    omit?: mode_of_paymentOmit<ExtArgs> | null
    /**
     * Filter, which mode_of_payment to fetch.
     */
    where: mode_of_paymentWhereUniqueInput
  }

  /**
   * mode_of_payment findFirst
   */
  export type mode_of_paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mode_of_payment
     */
    select?: mode_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mode_of_payment
     */
    omit?: mode_of_paymentOmit<ExtArgs> | null
    /**
     * Filter, which mode_of_payment to fetch.
     */
    where?: mode_of_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mode_of_payments to fetch.
     */
    orderBy?: mode_of_paymentOrderByWithRelationInput | mode_of_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mode_of_payments.
     */
    cursor?: mode_of_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mode_of_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mode_of_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mode_of_payments.
     */
    distinct?: Mode_of_paymentScalarFieldEnum | Mode_of_paymentScalarFieldEnum[]
  }

  /**
   * mode_of_payment findFirstOrThrow
   */
  export type mode_of_paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mode_of_payment
     */
    select?: mode_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mode_of_payment
     */
    omit?: mode_of_paymentOmit<ExtArgs> | null
    /**
     * Filter, which mode_of_payment to fetch.
     */
    where?: mode_of_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mode_of_payments to fetch.
     */
    orderBy?: mode_of_paymentOrderByWithRelationInput | mode_of_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mode_of_payments.
     */
    cursor?: mode_of_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mode_of_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mode_of_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mode_of_payments.
     */
    distinct?: Mode_of_paymentScalarFieldEnum | Mode_of_paymentScalarFieldEnum[]
  }

  /**
   * mode_of_payment findMany
   */
  export type mode_of_paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mode_of_payment
     */
    select?: mode_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mode_of_payment
     */
    omit?: mode_of_paymentOmit<ExtArgs> | null
    /**
     * Filter, which mode_of_payments to fetch.
     */
    where?: mode_of_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mode_of_payments to fetch.
     */
    orderBy?: mode_of_paymentOrderByWithRelationInput | mode_of_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mode_of_payments.
     */
    cursor?: mode_of_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mode_of_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mode_of_payments.
     */
    skip?: number
    distinct?: Mode_of_paymentScalarFieldEnum | Mode_of_paymentScalarFieldEnum[]
  }

  /**
   * mode_of_payment create
   */
  export type mode_of_paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mode_of_payment
     */
    select?: mode_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mode_of_payment
     */
    omit?: mode_of_paymentOmit<ExtArgs> | null
    /**
     * The data needed to create a mode_of_payment.
     */
    data?: XOR<mode_of_paymentCreateInput, mode_of_paymentUncheckedCreateInput>
  }

  /**
   * mode_of_payment createMany
   */
  export type mode_of_paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mode_of_payments.
     */
    data: mode_of_paymentCreateManyInput | mode_of_paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mode_of_payment createManyAndReturn
   */
  export type mode_of_paymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mode_of_payment
     */
    select?: mode_of_paymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mode_of_payment
     */
    omit?: mode_of_paymentOmit<ExtArgs> | null
    /**
     * The data used to create many mode_of_payments.
     */
    data: mode_of_paymentCreateManyInput | mode_of_paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mode_of_payment update
   */
  export type mode_of_paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mode_of_payment
     */
    select?: mode_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mode_of_payment
     */
    omit?: mode_of_paymentOmit<ExtArgs> | null
    /**
     * The data needed to update a mode_of_payment.
     */
    data: XOR<mode_of_paymentUpdateInput, mode_of_paymentUncheckedUpdateInput>
    /**
     * Choose, which mode_of_payment to update.
     */
    where: mode_of_paymentWhereUniqueInput
  }

  /**
   * mode_of_payment updateMany
   */
  export type mode_of_paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mode_of_payments.
     */
    data: XOR<mode_of_paymentUpdateManyMutationInput, mode_of_paymentUncheckedUpdateManyInput>
    /**
     * Filter which mode_of_payments to update
     */
    where?: mode_of_paymentWhereInput
    /**
     * Limit how many mode_of_payments to update.
     */
    limit?: number
  }

  /**
   * mode_of_payment updateManyAndReturn
   */
  export type mode_of_paymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mode_of_payment
     */
    select?: mode_of_paymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mode_of_payment
     */
    omit?: mode_of_paymentOmit<ExtArgs> | null
    /**
     * The data used to update mode_of_payments.
     */
    data: XOR<mode_of_paymentUpdateManyMutationInput, mode_of_paymentUncheckedUpdateManyInput>
    /**
     * Filter which mode_of_payments to update
     */
    where?: mode_of_paymentWhereInput
    /**
     * Limit how many mode_of_payments to update.
     */
    limit?: number
  }

  /**
   * mode_of_payment upsert
   */
  export type mode_of_paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mode_of_payment
     */
    select?: mode_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mode_of_payment
     */
    omit?: mode_of_paymentOmit<ExtArgs> | null
    /**
     * The filter to search for the mode_of_payment to update in case it exists.
     */
    where: mode_of_paymentWhereUniqueInput
    /**
     * In case the mode_of_payment found by the `where` argument doesn't exist, create a new mode_of_payment with this data.
     */
    create: XOR<mode_of_paymentCreateInput, mode_of_paymentUncheckedCreateInput>
    /**
     * In case the mode_of_payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mode_of_paymentUpdateInput, mode_of_paymentUncheckedUpdateInput>
  }

  /**
   * mode_of_payment delete
   */
  export type mode_of_paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mode_of_payment
     */
    select?: mode_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mode_of_payment
     */
    omit?: mode_of_paymentOmit<ExtArgs> | null
    /**
     * Filter which mode_of_payment to delete.
     */
    where: mode_of_paymentWhereUniqueInput
  }

  /**
   * mode_of_payment deleteMany
   */
  export type mode_of_paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mode_of_payments to delete
     */
    where?: mode_of_paymentWhereInput
    /**
     * Limit how many mode_of_payments to delete.
     */
    limit?: number
  }

  /**
   * mode_of_payment without action
   */
  export type mode_of_paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mode_of_payment
     */
    select?: mode_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mode_of_payment
     */
    omit?: mode_of_paymentOmit<ExtArgs> | null
  }


  /**
   * Model patient_appointments
   */

  export type AggregatePatient_appointments = {
    _count: Patient_appointmentsCountAggregateOutputType | null
    _avg: Patient_appointmentsAvgAggregateOutputType | null
    _sum: Patient_appointmentsSumAggregateOutputType | null
    _min: Patient_appointmentsMinAggregateOutputType | null
    _max: Patient_appointmentsMaxAggregateOutputType | null
  }

  export type Patient_appointmentsAvgAggregateOutputType = {
    patient_appointments_id: number | null
    patient_id: number | null
    appoint_id: number | null
  }

  export type Patient_appointmentsSumAggregateOutputType = {
    patient_appointments_id: bigint | null
    patient_id: bigint | null
    appoint_id: bigint | null
  }

  export type Patient_appointmentsMinAggregateOutputType = {
    patient_appointments_id: bigint | null
    patient_id: bigint | null
    appoint_id: bigint | null
    booking_date: Date | null
  }

  export type Patient_appointmentsMaxAggregateOutputType = {
    patient_appointments_id: bigint | null
    patient_id: bigint | null
    appoint_id: bigint | null
    booking_date: Date | null
  }

  export type Patient_appointmentsCountAggregateOutputType = {
    patient_appointments_id: number
    patient_id: number
    appoint_id: number
    booking_date: number
    _all: number
  }


  export type Patient_appointmentsAvgAggregateInputType = {
    patient_appointments_id?: true
    patient_id?: true
    appoint_id?: true
  }

  export type Patient_appointmentsSumAggregateInputType = {
    patient_appointments_id?: true
    patient_id?: true
    appoint_id?: true
  }

  export type Patient_appointmentsMinAggregateInputType = {
    patient_appointments_id?: true
    patient_id?: true
    appoint_id?: true
    booking_date?: true
  }

  export type Patient_appointmentsMaxAggregateInputType = {
    patient_appointments_id?: true
    patient_id?: true
    appoint_id?: true
    booking_date?: true
  }

  export type Patient_appointmentsCountAggregateInputType = {
    patient_appointments_id?: true
    patient_id?: true
    appoint_id?: true
    booking_date?: true
    _all?: true
  }

  export type Patient_appointmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_appointments to aggregate.
     */
    where?: patient_appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_appointments to fetch.
     */
    orderBy?: patient_appointmentsOrderByWithRelationInput | patient_appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patient_appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patient_appointments
    **/
    _count?: true | Patient_appointmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Patient_appointmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Patient_appointmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Patient_appointmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Patient_appointmentsMaxAggregateInputType
  }

  export type GetPatient_appointmentsAggregateType<T extends Patient_appointmentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient_appointments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient_appointments[P]>
      : GetScalarType<T[P], AggregatePatient_appointments[P]>
  }




  export type patient_appointmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patient_appointmentsWhereInput
    orderBy?: patient_appointmentsOrderByWithAggregationInput | patient_appointmentsOrderByWithAggregationInput[]
    by: Patient_appointmentsScalarFieldEnum[] | Patient_appointmentsScalarFieldEnum
    having?: patient_appointmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Patient_appointmentsCountAggregateInputType | true
    _avg?: Patient_appointmentsAvgAggregateInputType
    _sum?: Patient_appointmentsSumAggregateInputType
    _min?: Patient_appointmentsMinAggregateInputType
    _max?: Patient_appointmentsMaxAggregateInputType
  }

  export type Patient_appointmentsGroupByOutputType = {
    patient_appointments_id: bigint
    patient_id: bigint
    appoint_id: bigint
    booking_date: Date | null
    _count: Patient_appointmentsCountAggregateOutputType | null
    _avg: Patient_appointmentsAvgAggregateOutputType | null
    _sum: Patient_appointmentsSumAggregateOutputType | null
    _min: Patient_appointmentsMinAggregateOutputType | null
    _max: Patient_appointmentsMaxAggregateOutputType | null
  }

  type GetPatient_appointmentsGroupByPayload<T extends patient_appointmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Patient_appointmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Patient_appointmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Patient_appointmentsGroupByOutputType[P]>
            : GetScalarType<T[P], Patient_appointmentsGroupByOutputType[P]>
        }
      >
    >


  export type patient_appointmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_appointments_id?: boolean
    patient_id?: boolean
    appoint_id?: boolean
    booking_date?: boolean
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient_appointments"]>

  export type patient_appointmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_appointments_id?: boolean
    patient_id?: boolean
    appoint_id?: boolean
    booking_date?: boolean
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient_appointments"]>

  export type patient_appointmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_appointments_id?: boolean
    patient_id?: boolean
    appoint_id?: boolean
    booking_date?: boolean
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient_appointments"]>

  export type patient_appointmentsSelectScalar = {
    patient_appointments_id?: boolean
    patient_id?: boolean
    appoint_id?: boolean
    booking_date?: boolean
  }

  export type patient_appointmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"patient_appointments_id" | "patient_id" | "appoint_id" | "booking_date", ExtArgs["result"]["patient_appointments"]>
  export type patient_appointmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }
  export type patient_appointmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }
  export type patient_appointmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }

  export type $patient_appointmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patient_appointments"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs>
      patients: Prisma.$patientsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      patient_appointments_id: bigint
      patient_id: bigint
      appoint_id: bigint
      booking_date: Date | null
    }, ExtArgs["result"]["patient_appointments"]>
    composites: {}
  }

  type patient_appointmentsGetPayload<S extends boolean | null | undefined | patient_appointmentsDefaultArgs> = $Result.GetResult<Prisma.$patient_appointmentsPayload, S>

  type patient_appointmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<patient_appointmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Patient_appointmentsCountAggregateInputType | true
    }

  export interface patient_appointmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patient_appointments'], meta: { name: 'patient_appointments' } }
    /**
     * Find zero or one Patient_appointments that matches the filter.
     * @param {patient_appointmentsFindUniqueArgs} args - Arguments to find a Patient_appointments
     * @example
     * // Get one Patient_appointments
     * const patient_appointments = await prisma.patient_appointments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patient_appointmentsFindUniqueArgs>(args: SelectSubset<T, patient_appointmentsFindUniqueArgs<ExtArgs>>): Prisma__patient_appointmentsClient<$Result.GetResult<Prisma.$patient_appointmentsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Patient_appointments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {patient_appointmentsFindUniqueOrThrowArgs} args - Arguments to find a Patient_appointments
     * @example
     * // Get one Patient_appointments
     * const patient_appointments = await prisma.patient_appointments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patient_appointmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, patient_appointmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patient_appointmentsClient<$Result.GetResult<Prisma.$patient_appointmentsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Patient_appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_appointmentsFindFirstArgs} args - Arguments to find a Patient_appointments
     * @example
     * // Get one Patient_appointments
     * const patient_appointments = await prisma.patient_appointments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patient_appointmentsFindFirstArgs>(args?: SelectSubset<T, patient_appointmentsFindFirstArgs<ExtArgs>>): Prisma__patient_appointmentsClient<$Result.GetResult<Prisma.$patient_appointmentsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Patient_appointments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_appointmentsFindFirstOrThrowArgs} args - Arguments to find a Patient_appointments
     * @example
     * // Get one Patient_appointments
     * const patient_appointments = await prisma.patient_appointments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patient_appointmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, patient_appointmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__patient_appointmentsClient<$Result.GetResult<Prisma.$patient_appointmentsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Patient_appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_appointmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patient_appointments
     * const patient_appointments = await prisma.patient_appointments.findMany()
     * 
     * // Get first 10 Patient_appointments
     * const patient_appointments = await prisma.patient_appointments.findMany({ take: 10 })
     * 
     * // Only select the `patient_appointments_id`
     * const patient_appointmentsWithPatient_appointments_idOnly = await prisma.patient_appointments.findMany({ select: { patient_appointments_id: true } })
     * 
     */
    findMany<T extends patient_appointmentsFindManyArgs>(args?: SelectSubset<T, patient_appointmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_appointmentsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Patient_appointments.
     * @param {patient_appointmentsCreateArgs} args - Arguments to create a Patient_appointments.
     * @example
     * // Create one Patient_appointments
     * const Patient_appointments = await prisma.patient_appointments.create({
     *   data: {
     *     // ... data to create a Patient_appointments
     *   }
     * })
     * 
     */
    create<T extends patient_appointmentsCreateArgs>(args: SelectSubset<T, patient_appointmentsCreateArgs<ExtArgs>>): Prisma__patient_appointmentsClient<$Result.GetResult<Prisma.$patient_appointmentsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Patient_appointments.
     * @param {patient_appointmentsCreateManyArgs} args - Arguments to create many Patient_appointments.
     * @example
     * // Create many Patient_appointments
     * const patient_appointments = await prisma.patient_appointments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patient_appointmentsCreateManyArgs>(args?: SelectSubset<T, patient_appointmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patient_appointments and returns the data saved in the database.
     * @param {patient_appointmentsCreateManyAndReturnArgs} args - Arguments to create many Patient_appointments.
     * @example
     * // Create many Patient_appointments
     * const patient_appointments = await prisma.patient_appointments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patient_appointments and only return the `patient_appointments_id`
     * const patient_appointmentsWithPatient_appointments_idOnly = await prisma.patient_appointments.createManyAndReturn({
     *   select: { patient_appointments_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends patient_appointmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, patient_appointmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_appointmentsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Patient_appointments.
     * @param {patient_appointmentsDeleteArgs} args - Arguments to delete one Patient_appointments.
     * @example
     * // Delete one Patient_appointments
     * const Patient_appointments = await prisma.patient_appointments.delete({
     *   where: {
     *     // ... filter to delete one Patient_appointments
     *   }
     * })
     * 
     */
    delete<T extends patient_appointmentsDeleteArgs>(args: SelectSubset<T, patient_appointmentsDeleteArgs<ExtArgs>>): Prisma__patient_appointmentsClient<$Result.GetResult<Prisma.$patient_appointmentsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Patient_appointments.
     * @param {patient_appointmentsUpdateArgs} args - Arguments to update one Patient_appointments.
     * @example
     * // Update one Patient_appointments
     * const patient_appointments = await prisma.patient_appointments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patient_appointmentsUpdateArgs>(args: SelectSubset<T, patient_appointmentsUpdateArgs<ExtArgs>>): Prisma__patient_appointmentsClient<$Result.GetResult<Prisma.$patient_appointmentsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Patient_appointments.
     * @param {patient_appointmentsDeleteManyArgs} args - Arguments to filter Patient_appointments to delete.
     * @example
     * // Delete a few Patient_appointments
     * const { count } = await prisma.patient_appointments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patient_appointmentsDeleteManyArgs>(args?: SelectSubset<T, patient_appointmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patient_appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_appointmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patient_appointments
     * const patient_appointments = await prisma.patient_appointments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patient_appointmentsUpdateManyArgs>(args: SelectSubset<T, patient_appointmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patient_appointments and returns the data updated in the database.
     * @param {patient_appointmentsUpdateManyAndReturnArgs} args - Arguments to update many Patient_appointments.
     * @example
     * // Update many Patient_appointments
     * const patient_appointments = await prisma.patient_appointments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patient_appointments and only return the `patient_appointments_id`
     * const patient_appointmentsWithPatient_appointments_idOnly = await prisma.patient_appointments.updateManyAndReturn({
     *   select: { patient_appointments_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends patient_appointmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, patient_appointmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_appointmentsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Patient_appointments.
     * @param {patient_appointmentsUpsertArgs} args - Arguments to update or create a Patient_appointments.
     * @example
     * // Update or create a Patient_appointments
     * const patient_appointments = await prisma.patient_appointments.upsert({
     *   create: {
     *     // ... data to create a Patient_appointments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient_appointments we want to update
     *   }
     * })
     */
    upsert<T extends patient_appointmentsUpsertArgs>(args: SelectSubset<T, patient_appointmentsUpsertArgs<ExtArgs>>): Prisma__patient_appointmentsClient<$Result.GetResult<Prisma.$patient_appointmentsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Patient_appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_appointmentsCountArgs} args - Arguments to filter Patient_appointments to count.
     * @example
     * // Count the number of Patient_appointments
     * const count = await prisma.patient_appointments.count({
     *   where: {
     *     // ... the filter for the Patient_appointments we want to count
     *   }
     * })
    **/
    count<T extends patient_appointmentsCountArgs>(
      args?: Subset<T, patient_appointmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Patient_appointmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient_appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Patient_appointmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Patient_appointmentsAggregateArgs>(args: Subset<T, Patient_appointmentsAggregateArgs>): Prisma.PrismaPromise<GetPatient_appointmentsAggregateType<T>>

    /**
     * Group by Patient_appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_appointmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patient_appointmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patient_appointmentsGroupByArgs['orderBy'] }
        : { orderBy?: patient_appointmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patient_appointmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatient_appointmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patient_appointments model
   */
  readonly fields: patient_appointmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patient_appointments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patient_appointmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends appointmentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, appointmentsDefaultArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    patients<T extends patientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, patientsDefaultArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patient_appointments model
   */ 
  interface patient_appointmentsFieldRefs {
    readonly patient_appointments_id: FieldRef<"patient_appointments", 'BigInt'>
    readonly patient_id: FieldRef<"patient_appointments", 'BigInt'>
    readonly appoint_id: FieldRef<"patient_appointments", 'BigInt'>
    readonly booking_date: FieldRef<"patient_appointments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * patient_appointments findUnique
   */
  export type patient_appointmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which patient_appointments to fetch.
     */
    where: patient_appointmentsWhereUniqueInput
  }

  /**
   * patient_appointments findUniqueOrThrow
   */
  export type patient_appointmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which patient_appointments to fetch.
     */
    where: patient_appointmentsWhereUniqueInput
  }

  /**
   * patient_appointments findFirst
   */
  export type patient_appointmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which patient_appointments to fetch.
     */
    where?: patient_appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_appointments to fetch.
     */
    orderBy?: patient_appointmentsOrderByWithRelationInput | patient_appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_appointments.
     */
    cursor?: patient_appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_appointments.
     */
    distinct?: Patient_appointmentsScalarFieldEnum | Patient_appointmentsScalarFieldEnum[]
  }

  /**
   * patient_appointments findFirstOrThrow
   */
  export type patient_appointmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which patient_appointments to fetch.
     */
    where?: patient_appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_appointments to fetch.
     */
    orderBy?: patient_appointmentsOrderByWithRelationInput | patient_appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_appointments.
     */
    cursor?: patient_appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_appointments.
     */
    distinct?: Patient_appointmentsScalarFieldEnum | Patient_appointmentsScalarFieldEnum[]
  }

  /**
   * patient_appointments findMany
   */
  export type patient_appointmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which patient_appointments to fetch.
     */
    where?: patient_appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_appointments to fetch.
     */
    orderBy?: patient_appointmentsOrderByWithRelationInput | patient_appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patient_appointments.
     */
    cursor?: patient_appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_appointments.
     */
    skip?: number
    distinct?: Patient_appointmentsScalarFieldEnum | Patient_appointmentsScalarFieldEnum[]
  }

  /**
   * patient_appointments create
   */
  export type patient_appointmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a patient_appointments.
     */
    data: XOR<patient_appointmentsCreateInput, patient_appointmentsUncheckedCreateInput>
  }

  /**
   * patient_appointments createMany
   */
  export type patient_appointmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patient_appointments.
     */
    data: patient_appointmentsCreateManyInput | patient_appointmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patient_appointments createManyAndReturn
   */
  export type patient_appointmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * The data used to create many patient_appointments.
     */
    data: patient_appointmentsCreateManyInput | patient_appointmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * patient_appointments update
   */
  export type patient_appointmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a patient_appointments.
     */
    data: XOR<patient_appointmentsUpdateInput, patient_appointmentsUncheckedUpdateInput>
    /**
     * Choose, which patient_appointments to update.
     */
    where: patient_appointmentsWhereUniqueInput
  }

  /**
   * patient_appointments updateMany
   */
  export type patient_appointmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patient_appointments.
     */
    data: XOR<patient_appointmentsUpdateManyMutationInput, patient_appointmentsUncheckedUpdateManyInput>
    /**
     * Filter which patient_appointments to update
     */
    where?: patient_appointmentsWhereInput
    /**
     * Limit how many patient_appointments to update.
     */
    limit?: number
  }

  /**
   * patient_appointments updateManyAndReturn
   */
  export type patient_appointmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * The data used to update patient_appointments.
     */
    data: XOR<patient_appointmentsUpdateManyMutationInput, patient_appointmentsUncheckedUpdateManyInput>
    /**
     * Filter which patient_appointments to update
     */
    where?: patient_appointmentsWhereInput
    /**
     * Limit how many patient_appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * patient_appointments upsert
   */
  export type patient_appointmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the patient_appointments to update in case it exists.
     */
    where: patient_appointmentsWhereUniqueInput
    /**
     * In case the patient_appointments found by the `where` argument doesn't exist, create a new patient_appointments with this data.
     */
    create: XOR<patient_appointmentsCreateInput, patient_appointmentsUncheckedCreateInput>
    /**
     * In case the patient_appointments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patient_appointmentsUpdateInput, patient_appointmentsUncheckedUpdateInput>
  }

  /**
   * patient_appointments delete
   */
  export type patient_appointmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsInclude<ExtArgs> | null
    /**
     * Filter which patient_appointments to delete.
     */
    where: patient_appointmentsWhereUniqueInput
  }

  /**
   * patient_appointments deleteMany
   */
  export type patient_appointmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_appointments to delete
     */
    where?: patient_appointmentsWhereInput
    /**
     * Limit how many patient_appointments to delete.
     */
    limit?: number
  }

  /**
   * patient_appointments without action
   */
  export type patient_appointmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsInclude<ExtArgs> | null
  }


  /**
   * Model patient_conditions
   */

  export type AggregatePatient_conditions = {
    _count: Patient_conditionsCountAggregateOutputType | null
    _avg: Patient_conditionsAvgAggregateOutputType | null
    _sum: Patient_conditionsSumAggregateOutputType | null
    _min: Patient_conditionsMinAggregateOutputType | null
    _max: Patient_conditionsMaxAggregateOutputType | null
  }

  export type Patient_conditionsAvgAggregateOutputType = {
    patient_conditions_id: number | null
  }

  export type Patient_conditionsSumAggregateOutputType = {
    patient_conditions_id: bigint | null
  }

  export type Patient_conditionsMinAggregateOutputType = {
    patient_conditions_id: bigint | null
    condition_type: string | null
    condition_description: string | null
  }

  export type Patient_conditionsMaxAggregateOutputType = {
    patient_conditions_id: bigint | null
    condition_type: string | null
    condition_description: string | null
  }

  export type Patient_conditionsCountAggregateOutputType = {
    patient_conditions_id: number
    condition_type: number
    condition_description: number
    _all: number
  }


  export type Patient_conditionsAvgAggregateInputType = {
    patient_conditions_id?: true
  }

  export type Patient_conditionsSumAggregateInputType = {
    patient_conditions_id?: true
  }

  export type Patient_conditionsMinAggregateInputType = {
    patient_conditions_id?: true
    condition_type?: true
    condition_description?: true
  }

  export type Patient_conditionsMaxAggregateInputType = {
    patient_conditions_id?: true
    condition_type?: true
    condition_description?: true
  }

  export type Patient_conditionsCountAggregateInputType = {
    patient_conditions_id?: true
    condition_type?: true
    condition_description?: true
    _all?: true
  }

  export type Patient_conditionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_conditions to aggregate.
     */
    where?: patient_conditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_conditions to fetch.
     */
    orderBy?: patient_conditionsOrderByWithRelationInput | patient_conditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patient_conditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patient_conditions
    **/
    _count?: true | Patient_conditionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Patient_conditionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Patient_conditionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Patient_conditionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Patient_conditionsMaxAggregateInputType
  }

  export type GetPatient_conditionsAggregateType<T extends Patient_conditionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient_conditions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient_conditions[P]>
      : GetScalarType<T[P], AggregatePatient_conditions[P]>
  }




  export type patient_conditionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patient_conditionsWhereInput
    orderBy?: patient_conditionsOrderByWithAggregationInput | patient_conditionsOrderByWithAggregationInput[]
    by: Patient_conditionsScalarFieldEnum[] | Patient_conditionsScalarFieldEnum
    having?: patient_conditionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Patient_conditionsCountAggregateInputType | true
    _avg?: Patient_conditionsAvgAggregateInputType
    _sum?: Patient_conditionsSumAggregateInputType
    _min?: Patient_conditionsMinAggregateInputType
    _max?: Patient_conditionsMaxAggregateInputType
  }

  export type Patient_conditionsGroupByOutputType = {
    patient_conditions_id: bigint
    condition_type: string | null
    condition_description: string | null
    _count: Patient_conditionsCountAggregateOutputType | null
    _avg: Patient_conditionsAvgAggregateOutputType | null
    _sum: Patient_conditionsSumAggregateOutputType | null
    _min: Patient_conditionsMinAggregateOutputType | null
    _max: Patient_conditionsMaxAggregateOutputType | null
  }

  type GetPatient_conditionsGroupByPayload<T extends patient_conditionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Patient_conditionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Patient_conditionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Patient_conditionsGroupByOutputType[P]>
            : GetScalarType<T[P], Patient_conditionsGroupByOutputType[P]>
        }
      >
    >


  export type patient_conditionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_conditions_id?: boolean
    condition_type?: boolean
    condition_description?: boolean
    patient_conditions?: boolean | patient_conditionsDefaultArgs<ExtArgs>
    other_patient_conditions?: boolean | patient_conditions$other_patient_conditionsArgs<ExtArgs>
  }, ExtArgs["result"]["patient_conditions"]>

  export type patient_conditionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_conditions_id?: boolean
    condition_type?: boolean
    condition_description?: boolean
    patient_conditions?: boolean | patient_conditionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient_conditions"]>

  export type patient_conditionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_conditions_id?: boolean
    condition_type?: boolean
    condition_description?: boolean
    patient_conditions?: boolean | patient_conditionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient_conditions"]>

  export type patient_conditionsSelectScalar = {
    patient_conditions_id?: boolean
    condition_type?: boolean
    condition_description?: boolean
  }

  export type patient_conditionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"patient_conditions_id" | "condition_type" | "condition_description", ExtArgs["result"]["patient_conditions"]>
  export type patient_conditionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient_conditions?: boolean | patient_conditionsDefaultArgs<ExtArgs>
    other_patient_conditions?: boolean | patient_conditions$other_patient_conditionsArgs<ExtArgs>
  }
  export type patient_conditionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient_conditions?: boolean | patient_conditionsDefaultArgs<ExtArgs>
  }
  export type patient_conditionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient_conditions?: boolean | patient_conditionsDefaultArgs<ExtArgs>
  }

  export type $patient_conditionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patient_conditions"
    objects: {
      patient_conditions: Prisma.$patient_conditionsPayload<ExtArgs>
      other_patient_conditions: Prisma.$patient_conditionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      patient_conditions_id: bigint
      condition_type: string | null
      condition_description: string | null
    }, ExtArgs["result"]["patient_conditions"]>
    composites: {}
  }

  type patient_conditionsGetPayload<S extends boolean | null | undefined | patient_conditionsDefaultArgs> = $Result.GetResult<Prisma.$patient_conditionsPayload, S>

  type patient_conditionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<patient_conditionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Patient_conditionsCountAggregateInputType | true
    }

  export interface patient_conditionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patient_conditions'], meta: { name: 'patient_conditions' } }
    /**
     * Find zero or one Patient_conditions that matches the filter.
     * @param {patient_conditionsFindUniqueArgs} args - Arguments to find a Patient_conditions
     * @example
     * // Get one Patient_conditions
     * const patient_conditions = await prisma.patient_conditions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patient_conditionsFindUniqueArgs>(args: SelectSubset<T, patient_conditionsFindUniqueArgs<ExtArgs>>): Prisma__patient_conditionsClient<$Result.GetResult<Prisma.$patient_conditionsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Patient_conditions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {patient_conditionsFindUniqueOrThrowArgs} args - Arguments to find a Patient_conditions
     * @example
     * // Get one Patient_conditions
     * const patient_conditions = await prisma.patient_conditions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patient_conditionsFindUniqueOrThrowArgs>(args: SelectSubset<T, patient_conditionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patient_conditionsClient<$Result.GetResult<Prisma.$patient_conditionsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Patient_conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_conditionsFindFirstArgs} args - Arguments to find a Patient_conditions
     * @example
     * // Get one Patient_conditions
     * const patient_conditions = await prisma.patient_conditions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patient_conditionsFindFirstArgs>(args?: SelectSubset<T, patient_conditionsFindFirstArgs<ExtArgs>>): Prisma__patient_conditionsClient<$Result.GetResult<Prisma.$patient_conditionsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Patient_conditions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_conditionsFindFirstOrThrowArgs} args - Arguments to find a Patient_conditions
     * @example
     * // Get one Patient_conditions
     * const patient_conditions = await prisma.patient_conditions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patient_conditionsFindFirstOrThrowArgs>(args?: SelectSubset<T, patient_conditionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__patient_conditionsClient<$Result.GetResult<Prisma.$patient_conditionsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Patient_conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_conditionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patient_conditions
     * const patient_conditions = await prisma.patient_conditions.findMany()
     * 
     * // Get first 10 Patient_conditions
     * const patient_conditions = await prisma.patient_conditions.findMany({ take: 10 })
     * 
     * // Only select the `patient_conditions_id`
     * const patient_conditionsWithPatient_conditions_idOnly = await prisma.patient_conditions.findMany({ select: { patient_conditions_id: true } })
     * 
     */
    findMany<T extends patient_conditionsFindManyArgs>(args?: SelectSubset<T, patient_conditionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_conditionsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Patient_conditions.
     * @param {patient_conditionsCreateArgs} args - Arguments to create a Patient_conditions.
     * @example
     * // Create one Patient_conditions
     * const Patient_conditions = await prisma.patient_conditions.create({
     *   data: {
     *     // ... data to create a Patient_conditions
     *   }
     * })
     * 
     */
    create<T extends patient_conditionsCreateArgs>(args: SelectSubset<T, patient_conditionsCreateArgs<ExtArgs>>): Prisma__patient_conditionsClient<$Result.GetResult<Prisma.$patient_conditionsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Patient_conditions.
     * @param {patient_conditionsCreateManyArgs} args - Arguments to create many Patient_conditions.
     * @example
     * // Create many Patient_conditions
     * const patient_conditions = await prisma.patient_conditions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patient_conditionsCreateManyArgs>(args?: SelectSubset<T, patient_conditionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patient_conditions and returns the data saved in the database.
     * @param {patient_conditionsCreateManyAndReturnArgs} args - Arguments to create many Patient_conditions.
     * @example
     * // Create many Patient_conditions
     * const patient_conditions = await prisma.patient_conditions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patient_conditions and only return the `patient_conditions_id`
     * const patient_conditionsWithPatient_conditions_idOnly = await prisma.patient_conditions.createManyAndReturn({
     *   select: { patient_conditions_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends patient_conditionsCreateManyAndReturnArgs>(args?: SelectSubset<T, patient_conditionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_conditionsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Patient_conditions.
     * @param {patient_conditionsDeleteArgs} args - Arguments to delete one Patient_conditions.
     * @example
     * // Delete one Patient_conditions
     * const Patient_conditions = await prisma.patient_conditions.delete({
     *   where: {
     *     // ... filter to delete one Patient_conditions
     *   }
     * })
     * 
     */
    delete<T extends patient_conditionsDeleteArgs>(args: SelectSubset<T, patient_conditionsDeleteArgs<ExtArgs>>): Prisma__patient_conditionsClient<$Result.GetResult<Prisma.$patient_conditionsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Patient_conditions.
     * @param {patient_conditionsUpdateArgs} args - Arguments to update one Patient_conditions.
     * @example
     * // Update one Patient_conditions
     * const patient_conditions = await prisma.patient_conditions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patient_conditionsUpdateArgs>(args: SelectSubset<T, patient_conditionsUpdateArgs<ExtArgs>>): Prisma__patient_conditionsClient<$Result.GetResult<Prisma.$patient_conditionsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Patient_conditions.
     * @param {patient_conditionsDeleteManyArgs} args - Arguments to filter Patient_conditions to delete.
     * @example
     * // Delete a few Patient_conditions
     * const { count } = await prisma.patient_conditions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patient_conditionsDeleteManyArgs>(args?: SelectSubset<T, patient_conditionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patient_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_conditionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patient_conditions
     * const patient_conditions = await prisma.patient_conditions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patient_conditionsUpdateManyArgs>(args: SelectSubset<T, patient_conditionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patient_conditions and returns the data updated in the database.
     * @param {patient_conditionsUpdateManyAndReturnArgs} args - Arguments to update many Patient_conditions.
     * @example
     * // Update many Patient_conditions
     * const patient_conditions = await prisma.patient_conditions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patient_conditions and only return the `patient_conditions_id`
     * const patient_conditionsWithPatient_conditions_idOnly = await prisma.patient_conditions.updateManyAndReturn({
     *   select: { patient_conditions_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends patient_conditionsUpdateManyAndReturnArgs>(args: SelectSubset<T, patient_conditionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_conditionsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Patient_conditions.
     * @param {patient_conditionsUpsertArgs} args - Arguments to update or create a Patient_conditions.
     * @example
     * // Update or create a Patient_conditions
     * const patient_conditions = await prisma.patient_conditions.upsert({
     *   create: {
     *     // ... data to create a Patient_conditions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient_conditions we want to update
     *   }
     * })
     */
    upsert<T extends patient_conditionsUpsertArgs>(args: SelectSubset<T, patient_conditionsUpsertArgs<ExtArgs>>): Prisma__patient_conditionsClient<$Result.GetResult<Prisma.$patient_conditionsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Patient_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_conditionsCountArgs} args - Arguments to filter Patient_conditions to count.
     * @example
     * // Count the number of Patient_conditions
     * const count = await prisma.patient_conditions.count({
     *   where: {
     *     // ... the filter for the Patient_conditions we want to count
     *   }
     * })
    **/
    count<T extends patient_conditionsCountArgs>(
      args?: Subset<T, patient_conditionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Patient_conditionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Patient_conditionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Patient_conditionsAggregateArgs>(args: Subset<T, Patient_conditionsAggregateArgs>): Prisma.PrismaPromise<GetPatient_conditionsAggregateType<T>>

    /**
     * Group by Patient_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_conditionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patient_conditionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patient_conditionsGroupByArgs['orderBy'] }
        : { orderBy?: patient_conditionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patient_conditionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatient_conditionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patient_conditions model
   */
  readonly fields: patient_conditionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patient_conditions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patient_conditionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient_conditions<T extends patient_conditionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, patient_conditionsDefaultArgs<ExtArgs>>): Prisma__patient_conditionsClient<$Result.GetResult<Prisma.$patient_conditionsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    other_patient_conditions<T extends patient_conditions$other_patient_conditionsArgs<ExtArgs> = {}>(args?: Subset<T, patient_conditions$other_patient_conditionsArgs<ExtArgs>>): Prisma__patient_conditionsClient<$Result.GetResult<Prisma.$patient_conditionsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patient_conditions model
   */ 
  interface patient_conditionsFieldRefs {
    readonly patient_conditions_id: FieldRef<"patient_conditions", 'BigInt'>
    readonly condition_type: FieldRef<"patient_conditions", 'String'>
    readonly condition_description: FieldRef<"patient_conditions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * patient_conditions findUnique
   */
  export type patient_conditionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_conditions
     */
    select?: patient_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_conditions
     */
    omit?: patient_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which patient_conditions to fetch.
     */
    where: patient_conditionsWhereUniqueInput
  }

  /**
   * patient_conditions findUniqueOrThrow
   */
  export type patient_conditionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_conditions
     */
    select?: patient_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_conditions
     */
    omit?: patient_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which patient_conditions to fetch.
     */
    where: patient_conditionsWhereUniqueInput
  }

  /**
   * patient_conditions findFirst
   */
  export type patient_conditionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_conditions
     */
    select?: patient_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_conditions
     */
    omit?: patient_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which patient_conditions to fetch.
     */
    where?: patient_conditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_conditions to fetch.
     */
    orderBy?: patient_conditionsOrderByWithRelationInput | patient_conditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_conditions.
     */
    cursor?: patient_conditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_conditions.
     */
    distinct?: Patient_conditionsScalarFieldEnum | Patient_conditionsScalarFieldEnum[]
  }

  /**
   * patient_conditions findFirstOrThrow
   */
  export type patient_conditionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_conditions
     */
    select?: patient_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_conditions
     */
    omit?: patient_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which patient_conditions to fetch.
     */
    where?: patient_conditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_conditions to fetch.
     */
    orderBy?: patient_conditionsOrderByWithRelationInput | patient_conditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_conditions.
     */
    cursor?: patient_conditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_conditions.
     */
    distinct?: Patient_conditionsScalarFieldEnum | Patient_conditionsScalarFieldEnum[]
  }

  /**
   * patient_conditions findMany
   */
  export type patient_conditionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_conditions
     */
    select?: patient_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_conditions
     */
    omit?: patient_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which patient_conditions to fetch.
     */
    where?: patient_conditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_conditions to fetch.
     */
    orderBy?: patient_conditionsOrderByWithRelationInput | patient_conditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patient_conditions.
     */
    cursor?: patient_conditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_conditions.
     */
    skip?: number
    distinct?: Patient_conditionsScalarFieldEnum | Patient_conditionsScalarFieldEnum[]
  }

  /**
   * patient_conditions create
   */
  export type patient_conditionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_conditions
     */
    select?: patient_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_conditions
     */
    omit?: patient_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_conditionsInclude<ExtArgs> | null
    /**
     * The data needed to create a patient_conditions.
     */
    data: XOR<patient_conditionsCreateInput, patient_conditionsUncheckedCreateInput>
  }

  /**
   * patient_conditions createMany
   */
  export type patient_conditionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patient_conditions.
     */
    data: patient_conditionsCreateManyInput | patient_conditionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patient_conditions createManyAndReturn
   */
  export type patient_conditionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_conditions
     */
    select?: patient_conditionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patient_conditions
     */
    omit?: patient_conditionsOmit<ExtArgs> | null
    /**
     * The data used to create many patient_conditions.
     */
    data: patient_conditionsCreateManyInput | patient_conditionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_conditionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * patient_conditions update
   */
  export type patient_conditionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_conditions
     */
    select?: patient_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_conditions
     */
    omit?: patient_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_conditionsInclude<ExtArgs> | null
    /**
     * The data needed to update a patient_conditions.
     */
    data: XOR<patient_conditionsUpdateInput, patient_conditionsUncheckedUpdateInput>
    /**
     * Choose, which patient_conditions to update.
     */
    where: patient_conditionsWhereUniqueInput
  }

  /**
   * patient_conditions updateMany
   */
  export type patient_conditionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patient_conditions.
     */
    data: XOR<patient_conditionsUpdateManyMutationInput, patient_conditionsUncheckedUpdateManyInput>
    /**
     * Filter which patient_conditions to update
     */
    where?: patient_conditionsWhereInput
    /**
     * Limit how many patient_conditions to update.
     */
    limit?: number
  }

  /**
   * patient_conditions updateManyAndReturn
   */
  export type patient_conditionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_conditions
     */
    select?: patient_conditionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patient_conditions
     */
    omit?: patient_conditionsOmit<ExtArgs> | null
    /**
     * The data used to update patient_conditions.
     */
    data: XOR<patient_conditionsUpdateManyMutationInput, patient_conditionsUncheckedUpdateManyInput>
    /**
     * Filter which patient_conditions to update
     */
    where?: patient_conditionsWhereInput
    /**
     * Limit how many patient_conditions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_conditionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * patient_conditions upsert
   */
  export type patient_conditionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_conditions
     */
    select?: patient_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_conditions
     */
    omit?: patient_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_conditionsInclude<ExtArgs> | null
    /**
     * The filter to search for the patient_conditions to update in case it exists.
     */
    where: patient_conditionsWhereUniqueInput
    /**
     * In case the patient_conditions found by the `where` argument doesn't exist, create a new patient_conditions with this data.
     */
    create: XOR<patient_conditionsCreateInput, patient_conditionsUncheckedCreateInput>
    /**
     * In case the patient_conditions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patient_conditionsUpdateInput, patient_conditionsUncheckedUpdateInput>
  }

  /**
   * patient_conditions delete
   */
  export type patient_conditionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_conditions
     */
    select?: patient_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_conditions
     */
    omit?: patient_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_conditionsInclude<ExtArgs> | null
    /**
     * Filter which patient_conditions to delete.
     */
    where: patient_conditionsWhereUniqueInput
  }

  /**
   * patient_conditions deleteMany
   */
  export type patient_conditionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_conditions to delete
     */
    where?: patient_conditionsWhereInput
    /**
     * Limit how many patient_conditions to delete.
     */
    limit?: number
  }

  /**
   * patient_conditions.other_patient_conditions
   */
  export type patient_conditions$other_patient_conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_conditions
     */
    select?: patient_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_conditions
     */
    omit?: patient_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_conditionsInclude<ExtArgs> | null
    where?: patient_conditionsWhereInput
  }

  /**
   * patient_conditions without action
   */
  export type patient_conditionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_conditions
     */
    select?: patient_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_conditions
     */
    omit?: patient_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_conditionsInclude<ExtArgs> | null
  }


  /**
   * Model patient_details
   */

  export type AggregatePatient_details = {
    _count: Patient_detailsCountAggregateOutputType | null
    _avg: Patient_detailsAvgAggregateOutputType | null
    _sum: Patient_detailsSumAggregateOutputType | null
    _min: Patient_detailsMinAggregateOutputType | null
    _max: Patient_detailsMaxAggregateOutputType | null
  }

  export type Patient_detailsAvgAggregateOutputType = {
    patient_details_id: number | null
    patient_id: number | null
    patient_conditions_id: number | null
  }

  export type Patient_detailsSumAggregateOutputType = {
    patient_details_id: bigint | null
    patient_id: bigint | null
    patient_conditions_id: bigint | null
  }

  export type Patient_detailsMinAggregateOutputType = {
    patient_details_id: bigint | null
    patient_id: bigint | null
    patient_conditions_id: bigint | null
    patient_birth_date: Date | null
  }

  export type Patient_detailsMaxAggregateOutputType = {
    patient_details_id: bigint | null
    patient_id: bigint | null
    patient_conditions_id: bigint | null
    patient_birth_date: Date | null
  }

  export type Patient_detailsCountAggregateOutputType = {
    patient_details_id: number
    patient_id: number
    patient_conditions_id: number
    patient_birth_date: number
    _all: number
  }


  export type Patient_detailsAvgAggregateInputType = {
    patient_details_id?: true
    patient_id?: true
    patient_conditions_id?: true
  }

  export type Patient_detailsSumAggregateInputType = {
    patient_details_id?: true
    patient_id?: true
    patient_conditions_id?: true
  }

  export type Patient_detailsMinAggregateInputType = {
    patient_details_id?: true
    patient_id?: true
    patient_conditions_id?: true
    patient_birth_date?: true
  }

  export type Patient_detailsMaxAggregateInputType = {
    patient_details_id?: true
    patient_id?: true
    patient_conditions_id?: true
    patient_birth_date?: true
  }

  export type Patient_detailsCountAggregateInputType = {
    patient_details_id?: true
    patient_id?: true
    patient_conditions_id?: true
    patient_birth_date?: true
    _all?: true
  }

  export type Patient_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_details to aggregate.
     */
    where?: patient_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_details to fetch.
     */
    orderBy?: patient_detailsOrderByWithRelationInput | patient_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patient_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patient_details
    **/
    _count?: true | Patient_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Patient_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Patient_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Patient_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Patient_detailsMaxAggregateInputType
  }

  export type GetPatient_detailsAggregateType<T extends Patient_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient_details[P]>
      : GetScalarType<T[P], AggregatePatient_details[P]>
  }




  export type patient_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patient_detailsWhereInput
    orderBy?: patient_detailsOrderByWithAggregationInput | patient_detailsOrderByWithAggregationInput[]
    by: Patient_detailsScalarFieldEnum[] | Patient_detailsScalarFieldEnum
    having?: patient_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Patient_detailsCountAggregateInputType | true
    _avg?: Patient_detailsAvgAggregateInputType
    _sum?: Patient_detailsSumAggregateInputType
    _min?: Patient_detailsMinAggregateInputType
    _max?: Patient_detailsMaxAggregateInputType
  }

  export type Patient_detailsGroupByOutputType = {
    patient_details_id: bigint
    patient_id: bigint
    patient_conditions_id: bigint
    patient_birth_date: Date | null
    _count: Patient_detailsCountAggregateOutputType | null
    _avg: Patient_detailsAvgAggregateOutputType | null
    _sum: Patient_detailsSumAggregateOutputType | null
    _min: Patient_detailsMinAggregateOutputType | null
    _max: Patient_detailsMaxAggregateOutputType | null
  }

  type GetPatient_detailsGroupByPayload<T extends patient_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Patient_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Patient_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Patient_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Patient_detailsGroupByOutputType[P]>
        }
      >
    >


  export type patient_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_details_id?: boolean
    patient_id?: boolean
    patient_conditions_id?: boolean
    patient_birth_date?: boolean
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient_details"]>

  export type patient_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_details_id?: boolean
    patient_id?: boolean
    patient_conditions_id?: boolean
    patient_birth_date?: boolean
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient_details"]>

  export type patient_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_details_id?: boolean
    patient_id?: boolean
    patient_conditions_id?: boolean
    patient_birth_date?: boolean
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient_details"]>

  export type patient_detailsSelectScalar = {
    patient_details_id?: boolean
    patient_id?: boolean
    patient_conditions_id?: boolean
    patient_birth_date?: boolean
  }

  export type patient_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"patient_details_id" | "patient_id" | "patient_conditions_id" | "patient_birth_date", ExtArgs["result"]["patient_details"]>
  export type patient_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }
  export type patient_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }
  export type patient_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }

  export type $patient_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patient_details"
    objects: {
      patients: Prisma.$patientsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      patient_details_id: bigint
      patient_id: bigint
      patient_conditions_id: bigint
      patient_birth_date: Date | null
    }, ExtArgs["result"]["patient_details"]>
    composites: {}
  }

  type patient_detailsGetPayload<S extends boolean | null | undefined | patient_detailsDefaultArgs> = $Result.GetResult<Prisma.$patient_detailsPayload, S>

  type patient_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<patient_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Patient_detailsCountAggregateInputType | true
    }

  export interface patient_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patient_details'], meta: { name: 'patient_details' } }
    /**
     * Find zero or one Patient_details that matches the filter.
     * @param {patient_detailsFindUniqueArgs} args - Arguments to find a Patient_details
     * @example
     * // Get one Patient_details
     * const patient_details = await prisma.patient_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patient_detailsFindUniqueArgs>(args: SelectSubset<T, patient_detailsFindUniqueArgs<ExtArgs>>): Prisma__patient_detailsClient<$Result.GetResult<Prisma.$patient_detailsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Patient_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {patient_detailsFindUniqueOrThrowArgs} args - Arguments to find a Patient_details
     * @example
     * // Get one Patient_details
     * const patient_details = await prisma.patient_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patient_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, patient_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patient_detailsClient<$Result.GetResult<Prisma.$patient_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Patient_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_detailsFindFirstArgs} args - Arguments to find a Patient_details
     * @example
     * // Get one Patient_details
     * const patient_details = await prisma.patient_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patient_detailsFindFirstArgs>(args?: SelectSubset<T, patient_detailsFindFirstArgs<ExtArgs>>): Prisma__patient_detailsClient<$Result.GetResult<Prisma.$patient_detailsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Patient_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_detailsFindFirstOrThrowArgs} args - Arguments to find a Patient_details
     * @example
     * // Get one Patient_details
     * const patient_details = await prisma.patient_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patient_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, patient_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__patient_detailsClient<$Result.GetResult<Prisma.$patient_detailsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Patient_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patient_details
     * const patient_details = await prisma.patient_details.findMany()
     * 
     * // Get first 10 Patient_details
     * const patient_details = await prisma.patient_details.findMany({ take: 10 })
     * 
     * // Only select the `patient_details_id`
     * const patient_detailsWithPatient_details_idOnly = await prisma.patient_details.findMany({ select: { patient_details_id: true } })
     * 
     */
    findMany<T extends patient_detailsFindManyArgs>(args?: SelectSubset<T, patient_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_detailsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Patient_details.
     * @param {patient_detailsCreateArgs} args - Arguments to create a Patient_details.
     * @example
     * // Create one Patient_details
     * const Patient_details = await prisma.patient_details.create({
     *   data: {
     *     // ... data to create a Patient_details
     *   }
     * })
     * 
     */
    create<T extends patient_detailsCreateArgs>(args: SelectSubset<T, patient_detailsCreateArgs<ExtArgs>>): Prisma__patient_detailsClient<$Result.GetResult<Prisma.$patient_detailsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Patient_details.
     * @param {patient_detailsCreateManyArgs} args - Arguments to create many Patient_details.
     * @example
     * // Create many Patient_details
     * const patient_details = await prisma.patient_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patient_detailsCreateManyArgs>(args?: SelectSubset<T, patient_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patient_details and returns the data saved in the database.
     * @param {patient_detailsCreateManyAndReturnArgs} args - Arguments to create many Patient_details.
     * @example
     * // Create many Patient_details
     * const patient_details = await prisma.patient_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patient_details and only return the `patient_details_id`
     * const patient_detailsWithPatient_details_idOnly = await prisma.patient_details.createManyAndReturn({
     *   select: { patient_details_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends patient_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, patient_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_detailsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Patient_details.
     * @param {patient_detailsDeleteArgs} args - Arguments to delete one Patient_details.
     * @example
     * // Delete one Patient_details
     * const Patient_details = await prisma.patient_details.delete({
     *   where: {
     *     // ... filter to delete one Patient_details
     *   }
     * })
     * 
     */
    delete<T extends patient_detailsDeleteArgs>(args: SelectSubset<T, patient_detailsDeleteArgs<ExtArgs>>): Prisma__patient_detailsClient<$Result.GetResult<Prisma.$patient_detailsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Patient_details.
     * @param {patient_detailsUpdateArgs} args - Arguments to update one Patient_details.
     * @example
     * // Update one Patient_details
     * const patient_details = await prisma.patient_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patient_detailsUpdateArgs>(args: SelectSubset<T, patient_detailsUpdateArgs<ExtArgs>>): Prisma__patient_detailsClient<$Result.GetResult<Prisma.$patient_detailsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Patient_details.
     * @param {patient_detailsDeleteManyArgs} args - Arguments to filter Patient_details to delete.
     * @example
     * // Delete a few Patient_details
     * const { count } = await prisma.patient_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patient_detailsDeleteManyArgs>(args?: SelectSubset<T, patient_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patient_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patient_details
     * const patient_details = await prisma.patient_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patient_detailsUpdateManyArgs>(args: SelectSubset<T, patient_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patient_details and returns the data updated in the database.
     * @param {patient_detailsUpdateManyAndReturnArgs} args - Arguments to update many Patient_details.
     * @example
     * // Update many Patient_details
     * const patient_details = await prisma.patient_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patient_details and only return the `patient_details_id`
     * const patient_detailsWithPatient_details_idOnly = await prisma.patient_details.updateManyAndReturn({
     *   select: { patient_details_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends patient_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, patient_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_detailsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Patient_details.
     * @param {patient_detailsUpsertArgs} args - Arguments to update or create a Patient_details.
     * @example
     * // Update or create a Patient_details
     * const patient_details = await prisma.patient_details.upsert({
     *   create: {
     *     // ... data to create a Patient_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient_details we want to update
     *   }
     * })
     */
    upsert<T extends patient_detailsUpsertArgs>(args: SelectSubset<T, patient_detailsUpsertArgs<ExtArgs>>): Prisma__patient_detailsClient<$Result.GetResult<Prisma.$patient_detailsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Patient_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_detailsCountArgs} args - Arguments to filter Patient_details to count.
     * @example
     * // Count the number of Patient_details
     * const count = await prisma.patient_details.count({
     *   where: {
     *     // ... the filter for the Patient_details we want to count
     *   }
     * })
    **/
    count<T extends patient_detailsCountArgs>(
      args?: Subset<T, patient_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Patient_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Patient_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Patient_detailsAggregateArgs>(args: Subset<T, Patient_detailsAggregateArgs>): Prisma.PrismaPromise<GetPatient_detailsAggregateType<T>>

    /**
     * Group by Patient_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patient_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patient_detailsGroupByArgs['orderBy'] }
        : { orderBy?: patient_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patient_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatient_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patient_details model
   */
  readonly fields: patient_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patient_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patient_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patients<T extends patientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, patientsDefaultArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patient_details model
   */ 
  interface patient_detailsFieldRefs {
    readonly patient_details_id: FieldRef<"patient_details", 'BigInt'>
    readonly patient_id: FieldRef<"patient_details", 'BigInt'>
    readonly patient_conditions_id: FieldRef<"patient_details", 'BigInt'>
    readonly patient_birth_date: FieldRef<"patient_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * patient_details findUnique
   */
  export type patient_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_details
     */
    select?: patient_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_details
     */
    omit?: patient_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_detailsInclude<ExtArgs> | null
    /**
     * Filter, which patient_details to fetch.
     */
    where: patient_detailsWhereUniqueInput
  }

  /**
   * patient_details findUniqueOrThrow
   */
  export type patient_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_details
     */
    select?: patient_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_details
     */
    omit?: patient_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_detailsInclude<ExtArgs> | null
    /**
     * Filter, which patient_details to fetch.
     */
    where: patient_detailsWhereUniqueInput
  }

  /**
   * patient_details findFirst
   */
  export type patient_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_details
     */
    select?: patient_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_details
     */
    omit?: patient_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_detailsInclude<ExtArgs> | null
    /**
     * Filter, which patient_details to fetch.
     */
    where?: patient_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_details to fetch.
     */
    orderBy?: patient_detailsOrderByWithRelationInput | patient_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_details.
     */
    cursor?: patient_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_details.
     */
    distinct?: Patient_detailsScalarFieldEnum | Patient_detailsScalarFieldEnum[]
  }

  /**
   * patient_details findFirstOrThrow
   */
  export type patient_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_details
     */
    select?: patient_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_details
     */
    omit?: patient_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_detailsInclude<ExtArgs> | null
    /**
     * Filter, which patient_details to fetch.
     */
    where?: patient_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_details to fetch.
     */
    orderBy?: patient_detailsOrderByWithRelationInput | patient_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_details.
     */
    cursor?: patient_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_details.
     */
    distinct?: Patient_detailsScalarFieldEnum | Patient_detailsScalarFieldEnum[]
  }

  /**
   * patient_details findMany
   */
  export type patient_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_details
     */
    select?: patient_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_details
     */
    omit?: patient_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_detailsInclude<ExtArgs> | null
    /**
     * Filter, which patient_details to fetch.
     */
    where?: patient_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_details to fetch.
     */
    orderBy?: patient_detailsOrderByWithRelationInput | patient_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patient_details.
     */
    cursor?: patient_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_details.
     */
    skip?: number
    distinct?: Patient_detailsScalarFieldEnum | Patient_detailsScalarFieldEnum[]
  }

  /**
   * patient_details create
   */
  export type patient_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_details
     */
    select?: patient_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_details
     */
    omit?: patient_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a patient_details.
     */
    data: XOR<patient_detailsCreateInput, patient_detailsUncheckedCreateInput>
  }

  /**
   * patient_details createMany
   */
  export type patient_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patient_details.
     */
    data: patient_detailsCreateManyInput | patient_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patient_details createManyAndReturn
   */
  export type patient_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_details
     */
    select?: patient_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patient_details
     */
    omit?: patient_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many patient_details.
     */
    data: patient_detailsCreateManyInput | patient_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * patient_details update
   */
  export type patient_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_details
     */
    select?: patient_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_details
     */
    omit?: patient_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a patient_details.
     */
    data: XOR<patient_detailsUpdateInput, patient_detailsUncheckedUpdateInput>
    /**
     * Choose, which patient_details to update.
     */
    where: patient_detailsWhereUniqueInput
  }

  /**
   * patient_details updateMany
   */
  export type patient_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patient_details.
     */
    data: XOR<patient_detailsUpdateManyMutationInput, patient_detailsUncheckedUpdateManyInput>
    /**
     * Filter which patient_details to update
     */
    where?: patient_detailsWhereInput
    /**
     * Limit how many patient_details to update.
     */
    limit?: number
  }

  /**
   * patient_details updateManyAndReturn
   */
  export type patient_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_details
     */
    select?: patient_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patient_details
     */
    omit?: patient_detailsOmit<ExtArgs> | null
    /**
     * The data used to update patient_details.
     */
    data: XOR<patient_detailsUpdateManyMutationInput, patient_detailsUncheckedUpdateManyInput>
    /**
     * Filter which patient_details to update
     */
    where?: patient_detailsWhereInput
    /**
     * Limit how many patient_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * patient_details upsert
   */
  export type patient_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_details
     */
    select?: patient_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_details
     */
    omit?: patient_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the patient_details to update in case it exists.
     */
    where: patient_detailsWhereUniqueInput
    /**
     * In case the patient_details found by the `where` argument doesn't exist, create a new patient_details with this data.
     */
    create: XOR<patient_detailsCreateInput, patient_detailsUncheckedCreateInput>
    /**
     * In case the patient_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patient_detailsUpdateInput, patient_detailsUncheckedUpdateInput>
  }

  /**
   * patient_details delete
   */
  export type patient_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_details
     */
    select?: patient_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_details
     */
    omit?: patient_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_detailsInclude<ExtArgs> | null
    /**
     * Filter which patient_details to delete.
     */
    where: patient_detailsWhereUniqueInput
  }

  /**
   * patient_details deleteMany
   */
  export type patient_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_details to delete
     */
    where?: patient_detailsWhereInput
    /**
     * Limit how many patient_details to delete.
     */
    limit?: number
  }

  /**
   * patient_details without action
   */
  export type patient_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_details
     */
    select?: patient_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_details
     */
    omit?: patient_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_detailsInclude<ExtArgs> | null
  }


  /**
   * Model patients
   */

  export type AggregatePatients = {
    _count: PatientsCountAggregateOutputType | null
    _avg: PatientsAvgAggregateOutputType | null
    _sum: PatientsSumAggregateOutputType | null
    _min: PatientsMinAggregateOutputType | null
    _max: PatientsMaxAggregateOutputType | null
  }

  export type PatientsAvgAggregateOutputType = {
    patient_id: number | null
    user_id: number | null
  }

  export type PatientsSumAggregateOutputType = {
    patient_id: bigint | null
    user_id: bigint | null
  }

  export type PatientsMinAggregateOutputType = {
    patient_id: bigint | null
    patient_name: string | null
    user_id: bigint | null
  }

  export type PatientsMaxAggregateOutputType = {
    patient_id: bigint | null
    patient_name: string | null
    user_id: bigint | null
  }

  export type PatientsCountAggregateOutputType = {
    patient_id: number
    patient_name: number
    user_id: number
    _all: number
  }


  export type PatientsAvgAggregateInputType = {
    patient_id?: true
    user_id?: true
  }

  export type PatientsSumAggregateInputType = {
    patient_id?: true
    user_id?: true
  }

  export type PatientsMinAggregateInputType = {
    patient_id?: true
    patient_name?: true
    user_id?: true
  }

  export type PatientsMaxAggregateInputType = {
    patient_id?: true
    patient_name?: true
    user_id?: true
  }

  export type PatientsCountAggregateInputType = {
    patient_id?: true
    patient_name?: true
    user_id?: true
    _all?: true
  }

  export type PatientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patients to aggregate.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patients
    **/
    _count?: true | PatientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientsMaxAggregateInputType
  }

  export type GetPatientsAggregateType<T extends PatientsAggregateArgs> = {
        [P in keyof T & keyof AggregatePatients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatients[P]>
      : GetScalarType<T[P], AggregatePatients[P]>
  }




  export type patientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patientsWhereInput
    orderBy?: patientsOrderByWithAggregationInput | patientsOrderByWithAggregationInput[]
    by: PatientsScalarFieldEnum[] | PatientsScalarFieldEnum
    having?: patientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientsCountAggregateInputType | true
    _avg?: PatientsAvgAggregateInputType
    _sum?: PatientsSumAggregateInputType
    _min?: PatientsMinAggregateInputType
    _max?: PatientsMaxAggregateInputType
  }

  export type PatientsGroupByOutputType = {
    patient_id: bigint
    patient_name: string | null
    user_id: bigint
    _count: PatientsCountAggregateOutputType | null
    _avg: PatientsAvgAggregateOutputType | null
    _sum: PatientsSumAggregateOutputType | null
    _min: PatientsMinAggregateOutputType | null
    _max: PatientsMaxAggregateOutputType | null
  }

  type GetPatientsGroupByPayload<T extends patientsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientsGroupByOutputType[P]>
            : GetScalarType<T[P], PatientsGroupByOutputType[P]>
        }
      >
    >


  export type patientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_id?: boolean
    patient_name?: boolean
    user_id?: boolean
    patient_appointments?: boolean | patients$patient_appointmentsArgs<ExtArgs>
    patient_details?: boolean | patients$patient_detailsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    session?: boolean | patients$sessionArgs<ExtArgs>
    _count?: boolean | PatientsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patients"]>

  export type patientsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_id?: boolean
    patient_name?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patients"]>

  export type patientsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_id?: boolean
    patient_name?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patients"]>

  export type patientsSelectScalar = {
    patient_id?: boolean
    patient_name?: boolean
    user_id?: boolean
  }

  export type patientsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"patient_id" | "patient_name" | "user_id", ExtArgs["result"]["patients"]>
  export type patientsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient_appointments?: boolean | patients$patient_appointmentsArgs<ExtArgs>
    patient_details?: boolean | patients$patient_detailsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    session?: boolean | patients$sessionArgs<ExtArgs>
    _count?: boolean | PatientsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type patientsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type patientsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $patientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patients"
    objects: {
      patient_appointments: Prisma.$patient_appointmentsPayload<ExtArgs>[]
      patient_details: Prisma.$patient_detailsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
      session: Prisma.$sessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      patient_id: bigint
      patient_name: string | null
      user_id: bigint
    }, ExtArgs["result"]["patients"]>
    composites: {}
  }

  type patientsGetPayload<S extends boolean | null | undefined | patientsDefaultArgs> = $Result.GetResult<Prisma.$patientsPayload, S>

  type patientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<patientsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientsCountAggregateInputType | true
    }

  export interface patientsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patients'], meta: { name: 'patients' } }
    /**
     * Find zero or one Patients that matches the filter.
     * @param {patientsFindUniqueArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patientsFindUniqueArgs>(args: SelectSubset<T, patientsFindUniqueArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Patients that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {patientsFindUniqueOrThrowArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patientsFindUniqueOrThrowArgs>(args: SelectSubset<T, patientsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsFindFirstArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patientsFindFirstArgs>(args?: SelectSubset<T, patientsFindFirstArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Patients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsFindFirstOrThrowArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patientsFindFirstOrThrowArgs>(args?: SelectSubset<T, patientsFindFirstOrThrowArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patients.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patients.findMany({ take: 10 })
     * 
     * // Only select the `patient_id`
     * const patientsWithPatient_idOnly = await prisma.patients.findMany({ select: { patient_id: true } })
     * 
     */
    findMany<T extends patientsFindManyArgs>(args?: SelectSubset<T, patientsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Patients.
     * @param {patientsCreateArgs} args - Arguments to create a Patients.
     * @example
     * // Create one Patients
     * const Patients = await prisma.patients.create({
     *   data: {
     *     // ... data to create a Patients
     *   }
     * })
     * 
     */
    create<T extends patientsCreateArgs>(args: SelectSubset<T, patientsCreateArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Patients.
     * @param {patientsCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patients = await prisma.patients.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patientsCreateManyArgs>(args?: SelectSubset<T, patientsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {patientsCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patients = await prisma.patients.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `patient_id`
     * const patientsWithPatient_idOnly = await prisma.patients.createManyAndReturn({
     *   select: { patient_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends patientsCreateManyAndReturnArgs>(args?: SelectSubset<T, patientsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Patients.
     * @param {patientsDeleteArgs} args - Arguments to delete one Patients.
     * @example
     * // Delete one Patients
     * const Patients = await prisma.patients.delete({
     *   where: {
     *     // ... filter to delete one Patients
     *   }
     * })
     * 
     */
    delete<T extends patientsDeleteArgs>(args: SelectSubset<T, patientsDeleteArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Patients.
     * @param {patientsUpdateArgs} args - Arguments to update one Patients.
     * @example
     * // Update one Patients
     * const patients = await prisma.patients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patientsUpdateArgs>(args: SelectSubset<T, patientsUpdateArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Patients.
     * @param {patientsDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patientsDeleteManyArgs>(args?: SelectSubset<T, patientsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patients = await prisma.patients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patientsUpdateManyArgs>(args: SelectSubset<T, patientsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {patientsUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patients = await prisma.patients.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `patient_id`
     * const patientsWithPatient_idOnly = await prisma.patients.updateManyAndReturn({
     *   select: { patient_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends patientsUpdateManyAndReturnArgs>(args: SelectSubset<T, patientsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Patients.
     * @param {patientsUpsertArgs} args - Arguments to update or create a Patients.
     * @example
     * // Update or create a Patients
     * const patients = await prisma.patients.upsert({
     *   create: {
     *     // ... data to create a Patients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patients we want to update
     *   }
     * })
     */
    upsert<T extends patientsUpsertArgs>(args: SelectSubset<T, patientsUpsertArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patients.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends patientsCountArgs>(
      args?: Subset<T, patientsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientsAggregateArgs>(args: Subset<T, PatientsAggregateArgs>): Prisma.PrismaPromise<GetPatientsAggregateType<T>>

    /**
     * Group by Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patientsGroupByArgs['orderBy'] }
        : { orderBy?: patientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patients model
   */
  readonly fields: patientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patientsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient_appointments<T extends patients$patient_appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, patients$patient_appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_appointmentsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    patient_details<T extends patients$patient_detailsArgs<ExtArgs> = {}>(args?: Subset<T, patients$patient_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_detailsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    session<T extends patients$sessionArgs<ExtArgs> = {}>(args?: Subset<T, patients$sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patients model
   */ 
  interface patientsFieldRefs {
    readonly patient_id: FieldRef<"patients", 'BigInt'>
    readonly patient_name: FieldRef<"patients", 'String'>
    readonly user_id: FieldRef<"patients", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * patients findUnique
   */
  export type patientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients findUniqueOrThrow
   */
  export type patientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients findFirst
   */
  export type patientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patients.
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patients.
     */
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * patients findFirstOrThrow
   */
  export type patientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patients.
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patients.
     */
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * patients findMany
   */
  export type patientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patients.
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * patients create
   */
  export type patientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * The data needed to create a patients.
     */
    data: XOR<patientsCreateInput, patientsUncheckedCreateInput>
  }

  /**
   * patients createMany
   */
  export type patientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patients.
     */
    data: patientsCreateManyInput | patientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patients createManyAndReturn
   */
  export type patientsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * The data used to create many patients.
     */
    data: patientsCreateManyInput | patientsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * patients update
   */
  export type patientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * The data needed to update a patients.
     */
    data: XOR<patientsUpdateInput, patientsUncheckedUpdateInput>
    /**
     * Choose, which patients to update.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients updateMany
   */
  export type patientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patients.
     */
    data: XOR<patientsUpdateManyMutationInput, patientsUncheckedUpdateManyInput>
    /**
     * Filter which patients to update
     */
    where?: patientsWhereInput
    /**
     * Limit how many patients to update.
     */
    limit?: number
  }

  /**
   * patients updateManyAndReturn
   */
  export type patientsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * The data used to update patients.
     */
    data: XOR<patientsUpdateManyMutationInput, patientsUncheckedUpdateManyInput>
    /**
     * Filter which patients to update
     */
    where?: patientsWhereInput
    /**
     * Limit how many patients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * patients upsert
   */
  export type patientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * The filter to search for the patients to update in case it exists.
     */
    where: patientsWhereUniqueInput
    /**
     * In case the patients found by the `where` argument doesn't exist, create a new patients with this data.
     */
    create: XOR<patientsCreateInput, patientsUncheckedCreateInput>
    /**
     * In case the patients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patientsUpdateInput, patientsUncheckedUpdateInput>
  }

  /**
   * patients delete
   */
  export type patientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter which patients to delete.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients deleteMany
   */
  export type patientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patients to delete
     */
    where?: patientsWhereInput
    /**
     * Limit how many patients to delete.
     */
    limit?: number
  }

  /**
   * patients.patient_appointments
   */
  export type patients$patient_appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_appointments
     */
    select?: patient_appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_appointments
     */
    omit?: patient_appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_appointmentsInclude<ExtArgs> | null
    where?: patient_appointmentsWhereInput
    orderBy?: patient_appointmentsOrderByWithRelationInput | patient_appointmentsOrderByWithRelationInput[]
    cursor?: patient_appointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Patient_appointmentsScalarFieldEnum | Patient_appointmentsScalarFieldEnum[]
  }

  /**
   * patients.patient_details
   */
  export type patients$patient_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_details
     */
    select?: patient_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_details
     */
    omit?: patient_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_detailsInclude<ExtArgs> | null
    where?: patient_detailsWhereInput
    orderBy?: patient_detailsOrderByWithRelationInput | patient_detailsOrderByWithRelationInput[]
    cursor?: patient_detailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Patient_detailsScalarFieldEnum | Patient_detailsScalarFieldEnum[]
  }

  /**
   * patients.session
   */
  export type patients$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    cursor?: sessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * patients without action
   */
  export type patientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
  }


  /**
   * Model payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    payment_id: number | null
    appoint_id: number | null
    user_id: number | null
  }

  export type PaymentSumAggregateOutputType = {
    payment_id: bigint | null
    appoint_id: bigint | null
    user_id: bigint | null
  }

  export type PaymentMinAggregateOutputType = {
    payment_id: bigint | null
    appoint_id: bigint | null
    user_id: bigint | null
    payment_status: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    payment_id: bigint | null
    appoint_id: bigint | null
    user_id: bigint | null
    payment_status: string | null
  }

  export type PaymentCountAggregateOutputType = {
    payment_id: number
    appoint_id: number
    user_id: number
    payment_status: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    payment_id?: true
    appoint_id?: true
    user_id?: true
  }

  export type PaymentSumAggregateInputType = {
    payment_id?: true
    appoint_id?: true
    user_id?: true
  }

  export type PaymentMinAggregateInputType = {
    payment_id?: true
    appoint_id?: true
    user_id?: true
    payment_status?: true
  }

  export type PaymentMaxAggregateInputType = {
    payment_id?: true
    appoint_id?: true
    user_id?: true
    payment_status?: true
  }

  export type PaymentCountAggregateInputType = {
    payment_id?: true
    appoint_id?: true
    user_id?: true
    payment_status?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment to aggregate.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithAggregationInput | paymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    payment_id: bigint
    appoint_id: bigint
    user_id: bigint
    payment_status: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_id?: boolean
    appoint_id?: boolean
    user_id?: boolean
    payment_status?: boolean
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_id?: boolean
    appoint_id?: boolean
    user_id?: boolean
    payment_status?: boolean
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_id?: boolean
    appoint_id?: boolean
    user_id?: boolean
    payment_status?: boolean
  }, ExtArgs["result"]["payment"]>

  export type paymentSelectScalar = {
    payment_id?: boolean
    appoint_id?: boolean
    user_id?: boolean
    payment_status?: boolean
  }

  export type paymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"payment_id" | "appoint_id" | "user_id" | "payment_status", ExtArgs["result"]["payment"]>

  export type $paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      payment_id: bigint
      appoint_id: bigint
      user_id: bigint
      payment_status: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type paymentGetPayload<S extends boolean | null | undefined | paymentDefaultArgs> = $Result.GetResult<Prisma.$paymentPayload, S>

  type paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment'], meta: { name: 'payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {paymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentFindUniqueArgs>(args: SelectSubset<T, paymentFindUniqueArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentFindFirstArgs>(args?: SelectSubset<T, paymentFindFirstArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `payment_id`
     * const paymentWithPayment_idOnly = await prisma.payment.findMany({ select: { payment_id: true } })
     * 
     */
    findMany<T extends paymentFindManyArgs>(args?: SelectSubset<T, paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Payment.
     * @param {paymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends paymentCreateArgs>(args: SelectSubset<T, paymentCreateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Payments.
     * @param {paymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentCreateManyArgs>(args?: SelectSubset<T, paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `payment_id`
     * const paymentWithPayment_idOnly = await prisma.payment.createManyAndReturn({
     *   select: { payment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Payment.
     * @param {paymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends paymentDeleteArgs>(args: SelectSubset<T, paymentDeleteArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Payment.
     * @param {paymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentUpdateArgs>(args: SelectSubset<T, paymentUpdateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentDeleteManyArgs>(args?: SelectSubset<T, paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentUpdateManyArgs>(args: SelectSubset<T, paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `payment_id`
     * const paymentWithPayment_idOnly = await prisma.payment.updateManyAndReturn({
     *   select: { payment_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Payment.
     * @param {paymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends paymentUpsertArgs>(args: SelectSubset<T, paymentUpsertArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentCountArgs>(
      args?: Subset<T, paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentGroupByArgs['orderBy'] }
        : { orderBy?: paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment model
   */
  readonly fields: paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment model
   */ 
  interface paymentFieldRefs {
    readonly payment_id: FieldRef<"payment", 'BigInt'>
    readonly appoint_id: FieldRef<"payment", 'BigInt'>
    readonly user_id: FieldRef<"payment", 'BigInt'>
    readonly payment_status: FieldRef<"payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payment findUnique
   */
  export type paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findUniqueOrThrow
   */
  export type paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findFirst
   */
  export type paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findFirstOrThrow
   */
  export type paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findMany
   */
  export type paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment create
   */
  export type paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * The data needed to create a payment.
     */
    data: XOR<paymentCreateInput, paymentUncheckedCreateInput>
  }

  /**
   * payment createMany
   */
  export type paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentCreateManyInput | paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment createManyAndReturn
   */
  export type paymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentCreateManyInput | paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment update
   */
  export type paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * The data needed to update a payment.
     */
    data: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
    /**
     * Choose, which payment to update.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment updateMany
   */
  export type paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payment updateManyAndReturn
   */
  export type paymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payment upsert
   */
  export type paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * The filter to search for the payment to update in case it exists.
     */
    where: paymentWhereUniqueInput
    /**
     * In case the payment found by the `where` argument doesn't exist, create a new payment with this data.
     */
    create: XOR<paymentCreateInput, paymentUncheckedCreateInput>
    /**
     * In case the payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
  }

  /**
   * payment delete
   */
  export type paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Filter which payment to delete.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment deleteMany
   */
  export type paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payment without action
   */
  export type paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
  }


  /**
   * Model recurrence
   */

  export type AggregateRecurrence = {
    _count: RecurrenceCountAggregateOutputType | null
    _avg: RecurrenceAvgAggregateOutputType | null
    _sum: RecurrenceSumAggregateOutputType | null
    _min: RecurrenceMinAggregateOutputType | null
    _max: RecurrenceMaxAggregateOutputType | null
  }

  export type RecurrenceAvgAggregateOutputType = {
    recurrence_id: number | null
    occurence_count: number | null
  }

  export type RecurrenceSumAggregateOutputType = {
    recurrence_id: bigint | null
    occurence_count: bigint | null
  }

  export type RecurrenceMinAggregateOutputType = {
    recurrence_id: bigint | null
    recurrence_type: string | null
    interval: string | null
    start_date: Date | null
    end_date: Date | null
    occurence_count: bigint | null
    time: Date | null
  }

  export type RecurrenceMaxAggregateOutputType = {
    recurrence_id: bigint | null
    recurrence_type: string | null
    interval: string | null
    start_date: Date | null
    end_date: Date | null
    occurence_count: bigint | null
    time: Date | null
  }

  export type RecurrenceCountAggregateOutputType = {
    recurrence_id: number
    recurrence_type: number
    interval: number
    start_date: number
    end_date: number
    occurence_count: number
    time: number
    _all: number
  }


  export type RecurrenceAvgAggregateInputType = {
    recurrence_id?: true
    occurence_count?: true
  }

  export type RecurrenceSumAggregateInputType = {
    recurrence_id?: true
    occurence_count?: true
  }

  export type RecurrenceMinAggregateInputType = {
    recurrence_id?: true
    recurrence_type?: true
    interval?: true
    start_date?: true
    end_date?: true
    occurence_count?: true
    time?: true
  }

  export type RecurrenceMaxAggregateInputType = {
    recurrence_id?: true
    recurrence_type?: true
    interval?: true
    start_date?: true
    end_date?: true
    occurence_count?: true
    time?: true
  }

  export type RecurrenceCountAggregateInputType = {
    recurrence_id?: true
    recurrence_type?: true
    interval?: true
    start_date?: true
    end_date?: true
    occurence_count?: true
    time?: true
    _all?: true
  }

  export type RecurrenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recurrence to aggregate.
     */
    where?: recurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recurrences to fetch.
     */
    orderBy?: recurrenceOrderByWithRelationInput | recurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recurrences
    **/
    _count?: true | RecurrenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurrenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurrenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurrenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurrenceMaxAggregateInputType
  }

  export type GetRecurrenceAggregateType<T extends RecurrenceAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurrence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurrence[P]>
      : GetScalarType<T[P], AggregateRecurrence[P]>
  }




  export type recurrenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recurrenceWhereInput
    orderBy?: recurrenceOrderByWithAggregationInput | recurrenceOrderByWithAggregationInput[]
    by: RecurrenceScalarFieldEnum[] | RecurrenceScalarFieldEnum
    having?: recurrenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurrenceCountAggregateInputType | true
    _avg?: RecurrenceAvgAggregateInputType
    _sum?: RecurrenceSumAggregateInputType
    _min?: RecurrenceMinAggregateInputType
    _max?: RecurrenceMaxAggregateInputType
  }

  export type RecurrenceGroupByOutputType = {
    recurrence_id: bigint
    recurrence_type: string | null
    interval: string | null
    start_date: Date | null
    end_date: Date | null
    occurence_count: bigint | null
    time: Date | null
    _count: RecurrenceCountAggregateOutputType | null
    _avg: RecurrenceAvgAggregateOutputType | null
    _sum: RecurrenceSumAggregateOutputType | null
    _min: RecurrenceMinAggregateOutputType | null
    _max: RecurrenceMaxAggregateOutputType | null
  }

  type GetRecurrenceGroupByPayload<T extends recurrenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurrenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurrenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurrenceGroupByOutputType[P]>
            : GetScalarType<T[P], RecurrenceGroupByOutputType[P]>
        }
      >
    >


  export type recurrenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recurrence_id?: boolean
    recurrence_type?: boolean
    interval?: boolean
    start_date?: boolean
    end_date?: boolean
    occurence_count?: boolean
    time?: boolean
    recurring_instances?: boolean | recurrence$recurring_instancesArgs<ExtArgs>
    _count?: boolean | RecurrenceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurrence"]>

  export type recurrenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recurrence_id?: boolean
    recurrence_type?: boolean
    interval?: boolean
    start_date?: boolean
    end_date?: boolean
    occurence_count?: boolean
    time?: boolean
  }, ExtArgs["result"]["recurrence"]>

  export type recurrenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recurrence_id?: boolean
    recurrence_type?: boolean
    interval?: boolean
    start_date?: boolean
    end_date?: boolean
    occurence_count?: boolean
    time?: boolean
  }, ExtArgs["result"]["recurrence"]>

  export type recurrenceSelectScalar = {
    recurrence_id?: boolean
    recurrence_type?: boolean
    interval?: boolean
    start_date?: boolean
    end_date?: boolean
    occurence_count?: boolean
    time?: boolean
  }

  export type recurrenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"recurrence_id" | "recurrence_type" | "interval" | "start_date" | "end_date" | "occurence_count" | "time", ExtArgs["result"]["recurrence"]>
  export type recurrenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recurring_instances?: boolean | recurrence$recurring_instancesArgs<ExtArgs>
    _count?: boolean | RecurrenceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type recurrenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type recurrenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $recurrencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "recurrence"
    objects: {
      recurring_instances: Prisma.$recurring_instancesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      recurrence_id: bigint
      recurrence_type: string | null
      interval: string | null
      start_date: Date | null
      end_date: Date | null
      occurence_count: bigint | null
      time: Date | null
    }, ExtArgs["result"]["recurrence"]>
    composites: {}
  }

  type recurrenceGetPayload<S extends boolean | null | undefined | recurrenceDefaultArgs> = $Result.GetResult<Prisma.$recurrencePayload, S>

  type recurrenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<recurrenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecurrenceCountAggregateInputType | true
    }

  export interface recurrenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['recurrence'], meta: { name: 'recurrence' } }
    /**
     * Find zero or one Recurrence that matches the filter.
     * @param {recurrenceFindUniqueArgs} args - Arguments to find a Recurrence
     * @example
     * // Get one Recurrence
     * const recurrence = await prisma.recurrence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends recurrenceFindUniqueArgs>(args: SelectSubset<T, recurrenceFindUniqueArgs<ExtArgs>>): Prisma__recurrenceClient<$Result.GetResult<Prisma.$recurrencePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Recurrence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {recurrenceFindUniqueOrThrowArgs} args - Arguments to find a Recurrence
     * @example
     * // Get one Recurrence
     * const recurrence = await prisma.recurrence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends recurrenceFindUniqueOrThrowArgs>(args: SelectSubset<T, recurrenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__recurrenceClient<$Result.GetResult<Prisma.$recurrencePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Recurrence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recurrenceFindFirstArgs} args - Arguments to find a Recurrence
     * @example
     * // Get one Recurrence
     * const recurrence = await prisma.recurrence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends recurrenceFindFirstArgs>(args?: SelectSubset<T, recurrenceFindFirstArgs<ExtArgs>>): Prisma__recurrenceClient<$Result.GetResult<Prisma.$recurrencePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Recurrence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recurrenceFindFirstOrThrowArgs} args - Arguments to find a Recurrence
     * @example
     * // Get one Recurrence
     * const recurrence = await prisma.recurrence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends recurrenceFindFirstOrThrowArgs>(args?: SelectSubset<T, recurrenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__recurrenceClient<$Result.GetResult<Prisma.$recurrencePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Recurrences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recurrenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recurrences
     * const recurrences = await prisma.recurrence.findMany()
     * 
     * // Get first 10 Recurrences
     * const recurrences = await prisma.recurrence.findMany({ take: 10 })
     * 
     * // Only select the `recurrence_id`
     * const recurrenceWithRecurrence_idOnly = await prisma.recurrence.findMany({ select: { recurrence_id: true } })
     * 
     */
    findMany<T extends recurrenceFindManyArgs>(args?: SelectSubset<T, recurrenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recurrencePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Recurrence.
     * @param {recurrenceCreateArgs} args - Arguments to create a Recurrence.
     * @example
     * // Create one Recurrence
     * const Recurrence = await prisma.recurrence.create({
     *   data: {
     *     // ... data to create a Recurrence
     *   }
     * })
     * 
     */
    create<T extends recurrenceCreateArgs>(args: SelectSubset<T, recurrenceCreateArgs<ExtArgs>>): Prisma__recurrenceClient<$Result.GetResult<Prisma.$recurrencePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Recurrences.
     * @param {recurrenceCreateManyArgs} args - Arguments to create many Recurrences.
     * @example
     * // Create many Recurrences
     * const recurrence = await prisma.recurrence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends recurrenceCreateManyArgs>(args?: SelectSubset<T, recurrenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recurrences and returns the data saved in the database.
     * @param {recurrenceCreateManyAndReturnArgs} args - Arguments to create many Recurrences.
     * @example
     * // Create many Recurrences
     * const recurrence = await prisma.recurrence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recurrences and only return the `recurrence_id`
     * const recurrenceWithRecurrence_idOnly = await prisma.recurrence.createManyAndReturn({
     *   select: { recurrence_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends recurrenceCreateManyAndReturnArgs>(args?: SelectSubset<T, recurrenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recurrencePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Recurrence.
     * @param {recurrenceDeleteArgs} args - Arguments to delete one Recurrence.
     * @example
     * // Delete one Recurrence
     * const Recurrence = await prisma.recurrence.delete({
     *   where: {
     *     // ... filter to delete one Recurrence
     *   }
     * })
     * 
     */
    delete<T extends recurrenceDeleteArgs>(args: SelectSubset<T, recurrenceDeleteArgs<ExtArgs>>): Prisma__recurrenceClient<$Result.GetResult<Prisma.$recurrencePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Recurrence.
     * @param {recurrenceUpdateArgs} args - Arguments to update one Recurrence.
     * @example
     * // Update one Recurrence
     * const recurrence = await prisma.recurrence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends recurrenceUpdateArgs>(args: SelectSubset<T, recurrenceUpdateArgs<ExtArgs>>): Prisma__recurrenceClient<$Result.GetResult<Prisma.$recurrencePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Recurrences.
     * @param {recurrenceDeleteManyArgs} args - Arguments to filter Recurrences to delete.
     * @example
     * // Delete a few Recurrences
     * const { count } = await prisma.recurrence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends recurrenceDeleteManyArgs>(args?: SelectSubset<T, recurrenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recurrenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recurrences
     * const recurrence = await prisma.recurrence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends recurrenceUpdateManyArgs>(args: SelectSubset<T, recurrenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recurrences and returns the data updated in the database.
     * @param {recurrenceUpdateManyAndReturnArgs} args - Arguments to update many Recurrences.
     * @example
     * // Update many Recurrences
     * const recurrence = await prisma.recurrence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recurrences and only return the `recurrence_id`
     * const recurrenceWithRecurrence_idOnly = await prisma.recurrence.updateManyAndReturn({
     *   select: { recurrence_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends recurrenceUpdateManyAndReturnArgs>(args: SelectSubset<T, recurrenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recurrencePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Recurrence.
     * @param {recurrenceUpsertArgs} args - Arguments to update or create a Recurrence.
     * @example
     * // Update or create a Recurrence
     * const recurrence = await prisma.recurrence.upsert({
     *   create: {
     *     // ... data to create a Recurrence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recurrence we want to update
     *   }
     * })
     */
    upsert<T extends recurrenceUpsertArgs>(args: SelectSubset<T, recurrenceUpsertArgs<ExtArgs>>): Prisma__recurrenceClient<$Result.GetResult<Prisma.$recurrencePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Recurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recurrenceCountArgs} args - Arguments to filter Recurrences to count.
     * @example
     * // Count the number of Recurrences
     * const count = await prisma.recurrence.count({
     *   where: {
     *     // ... the filter for the Recurrences we want to count
     *   }
     * })
    **/
    count<T extends recurrenceCountArgs>(
      args?: Subset<T, recurrenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurrenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recurrence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurrenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurrenceAggregateArgs>(args: Subset<T, RecurrenceAggregateArgs>): Prisma.PrismaPromise<GetRecurrenceAggregateType<T>>

    /**
     * Group by Recurrence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recurrenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends recurrenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recurrenceGroupByArgs['orderBy'] }
        : { orderBy?: recurrenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, recurrenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurrenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the recurrence model
   */
  readonly fields: recurrenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for recurrence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recurrenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recurring_instances<T extends recurrence$recurring_instancesArgs<ExtArgs> = {}>(args?: Subset<T, recurrence$recurring_instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recurring_instancesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the recurrence model
   */ 
  interface recurrenceFieldRefs {
    readonly recurrence_id: FieldRef<"recurrence", 'BigInt'>
    readonly recurrence_type: FieldRef<"recurrence", 'String'>
    readonly interval: FieldRef<"recurrence", 'String'>
    readonly start_date: FieldRef<"recurrence", 'DateTime'>
    readonly end_date: FieldRef<"recurrence", 'DateTime'>
    readonly occurence_count: FieldRef<"recurrence", 'BigInt'>
    readonly time: FieldRef<"recurrence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * recurrence findUnique
   */
  export type recurrenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurrence
     */
    select?: recurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurrence
     */
    omit?: recurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurrenceInclude<ExtArgs> | null
    /**
     * Filter, which recurrence to fetch.
     */
    where: recurrenceWhereUniqueInput
  }

  /**
   * recurrence findUniqueOrThrow
   */
  export type recurrenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurrence
     */
    select?: recurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurrence
     */
    omit?: recurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurrenceInclude<ExtArgs> | null
    /**
     * Filter, which recurrence to fetch.
     */
    where: recurrenceWhereUniqueInput
  }

  /**
   * recurrence findFirst
   */
  export type recurrenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurrence
     */
    select?: recurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurrence
     */
    omit?: recurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurrenceInclude<ExtArgs> | null
    /**
     * Filter, which recurrence to fetch.
     */
    where?: recurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recurrences to fetch.
     */
    orderBy?: recurrenceOrderByWithRelationInput | recurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recurrences.
     */
    cursor?: recurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recurrences.
     */
    distinct?: RecurrenceScalarFieldEnum | RecurrenceScalarFieldEnum[]
  }

  /**
   * recurrence findFirstOrThrow
   */
  export type recurrenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurrence
     */
    select?: recurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurrence
     */
    omit?: recurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurrenceInclude<ExtArgs> | null
    /**
     * Filter, which recurrence to fetch.
     */
    where?: recurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recurrences to fetch.
     */
    orderBy?: recurrenceOrderByWithRelationInput | recurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recurrences.
     */
    cursor?: recurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recurrences.
     */
    distinct?: RecurrenceScalarFieldEnum | RecurrenceScalarFieldEnum[]
  }

  /**
   * recurrence findMany
   */
  export type recurrenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurrence
     */
    select?: recurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurrence
     */
    omit?: recurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurrenceInclude<ExtArgs> | null
    /**
     * Filter, which recurrences to fetch.
     */
    where?: recurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recurrences to fetch.
     */
    orderBy?: recurrenceOrderByWithRelationInput | recurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recurrences.
     */
    cursor?: recurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recurrences.
     */
    skip?: number
    distinct?: RecurrenceScalarFieldEnum | RecurrenceScalarFieldEnum[]
  }

  /**
   * recurrence create
   */
  export type recurrenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurrence
     */
    select?: recurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurrence
     */
    omit?: recurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurrenceInclude<ExtArgs> | null
    /**
     * The data needed to create a recurrence.
     */
    data?: XOR<recurrenceCreateInput, recurrenceUncheckedCreateInput>
  }

  /**
   * recurrence createMany
   */
  export type recurrenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many recurrences.
     */
    data: recurrenceCreateManyInput | recurrenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * recurrence createManyAndReturn
   */
  export type recurrenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurrence
     */
    select?: recurrenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the recurrence
     */
    omit?: recurrenceOmit<ExtArgs> | null
    /**
     * The data used to create many recurrences.
     */
    data: recurrenceCreateManyInput | recurrenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * recurrence update
   */
  export type recurrenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurrence
     */
    select?: recurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurrence
     */
    omit?: recurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurrenceInclude<ExtArgs> | null
    /**
     * The data needed to update a recurrence.
     */
    data: XOR<recurrenceUpdateInput, recurrenceUncheckedUpdateInput>
    /**
     * Choose, which recurrence to update.
     */
    where: recurrenceWhereUniqueInput
  }

  /**
   * recurrence updateMany
   */
  export type recurrenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update recurrences.
     */
    data: XOR<recurrenceUpdateManyMutationInput, recurrenceUncheckedUpdateManyInput>
    /**
     * Filter which recurrences to update
     */
    where?: recurrenceWhereInput
    /**
     * Limit how many recurrences to update.
     */
    limit?: number
  }

  /**
   * recurrence updateManyAndReturn
   */
  export type recurrenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurrence
     */
    select?: recurrenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the recurrence
     */
    omit?: recurrenceOmit<ExtArgs> | null
    /**
     * The data used to update recurrences.
     */
    data: XOR<recurrenceUpdateManyMutationInput, recurrenceUncheckedUpdateManyInput>
    /**
     * Filter which recurrences to update
     */
    where?: recurrenceWhereInput
    /**
     * Limit how many recurrences to update.
     */
    limit?: number
  }

  /**
   * recurrence upsert
   */
  export type recurrenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurrence
     */
    select?: recurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurrence
     */
    omit?: recurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurrenceInclude<ExtArgs> | null
    /**
     * The filter to search for the recurrence to update in case it exists.
     */
    where: recurrenceWhereUniqueInput
    /**
     * In case the recurrence found by the `where` argument doesn't exist, create a new recurrence with this data.
     */
    create: XOR<recurrenceCreateInput, recurrenceUncheckedCreateInput>
    /**
     * In case the recurrence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recurrenceUpdateInput, recurrenceUncheckedUpdateInput>
  }

  /**
   * recurrence delete
   */
  export type recurrenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurrence
     */
    select?: recurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurrence
     */
    omit?: recurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurrenceInclude<ExtArgs> | null
    /**
     * Filter which recurrence to delete.
     */
    where: recurrenceWhereUniqueInput
  }

  /**
   * recurrence deleteMany
   */
  export type recurrenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recurrences to delete
     */
    where?: recurrenceWhereInput
    /**
     * Limit how many recurrences to delete.
     */
    limit?: number
  }

  /**
   * recurrence.recurring_instances
   */
  export type recurrence$recurring_instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesInclude<ExtArgs> | null
    where?: recurring_instancesWhereInput
    orderBy?: recurring_instancesOrderByWithRelationInput | recurring_instancesOrderByWithRelationInput[]
    cursor?: recurring_instancesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Recurring_instancesScalarFieldEnum | Recurring_instancesScalarFieldEnum[]
  }

  /**
   * recurrence without action
   */
  export type recurrenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurrence
     */
    select?: recurrenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurrence
     */
    omit?: recurrenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurrenceInclude<ExtArgs> | null
  }


  /**
   * Model recurring_instances
   */

  export type AggregateRecurring_instances = {
    _count: Recurring_instancesCountAggregateOutputType | null
    _avg: Recurring_instancesAvgAggregateOutputType | null
    _sum: Recurring_instancesSumAggregateOutputType | null
    _min: Recurring_instancesMinAggregateOutputType | null
    _max: Recurring_instancesMaxAggregateOutputType | null
  }

  export type Recurring_instancesAvgAggregateOutputType = {
    instance_id: number | null
    appoint_id: number | null
    recurrence_id: number | null
  }

  export type Recurring_instancesSumAggregateOutputType = {
    instance_id: bigint | null
    appoint_id: bigint | null
    recurrence_id: bigint | null
  }

  export type Recurring_instancesMinAggregateOutputType = {
    instance_id: bigint | null
    appoint_id: bigint | null
    recurrence_id: bigint | null
    appoint_date: Date | null
    appoint_time: Date | null
    instance_status: string | null
  }

  export type Recurring_instancesMaxAggregateOutputType = {
    instance_id: bigint | null
    appoint_id: bigint | null
    recurrence_id: bigint | null
    appoint_date: Date | null
    appoint_time: Date | null
    instance_status: string | null
  }

  export type Recurring_instancesCountAggregateOutputType = {
    instance_id: number
    appoint_id: number
    recurrence_id: number
    appoint_date: number
    appoint_time: number
    instance_status: number
    _all: number
  }


  export type Recurring_instancesAvgAggregateInputType = {
    instance_id?: true
    appoint_id?: true
    recurrence_id?: true
  }

  export type Recurring_instancesSumAggregateInputType = {
    instance_id?: true
    appoint_id?: true
    recurrence_id?: true
  }

  export type Recurring_instancesMinAggregateInputType = {
    instance_id?: true
    appoint_id?: true
    recurrence_id?: true
    appoint_date?: true
    appoint_time?: true
    instance_status?: true
  }

  export type Recurring_instancesMaxAggregateInputType = {
    instance_id?: true
    appoint_id?: true
    recurrence_id?: true
    appoint_date?: true
    appoint_time?: true
    instance_status?: true
  }

  export type Recurring_instancesCountAggregateInputType = {
    instance_id?: true
    appoint_id?: true
    recurrence_id?: true
    appoint_date?: true
    appoint_time?: true
    instance_status?: true
    _all?: true
  }

  export type Recurring_instancesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recurring_instances to aggregate.
     */
    where?: recurring_instancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recurring_instances to fetch.
     */
    orderBy?: recurring_instancesOrderByWithRelationInput | recurring_instancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recurring_instancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recurring_instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recurring_instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recurring_instances
    **/
    _count?: true | Recurring_instancesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Recurring_instancesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Recurring_instancesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Recurring_instancesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Recurring_instancesMaxAggregateInputType
  }

  export type GetRecurring_instancesAggregateType<T extends Recurring_instancesAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurring_instances]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurring_instances[P]>
      : GetScalarType<T[P], AggregateRecurring_instances[P]>
  }




  export type recurring_instancesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recurring_instancesWhereInput
    orderBy?: recurring_instancesOrderByWithAggregationInput | recurring_instancesOrderByWithAggregationInput[]
    by: Recurring_instancesScalarFieldEnum[] | Recurring_instancesScalarFieldEnum
    having?: recurring_instancesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Recurring_instancesCountAggregateInputType | true
    _avg?: Recurring_instancesAvgAggregateInputType
    _sum?: Recurring_instancesSumAggregateInputType
    _min?: Recurring_instancesMinAggregateInputType
    _max?: Recurring_instancesMaxAggregateInputType
  }

  export type Recurring_instancesGroupByOutputType = {
    instance_id: bigint
    appoint_id: bigint
    recurrence_id: bigint
    appoint_date: Date | null
    appoint_time: Date | null
    instance_status: string | null
    _count: Recurring_instancesCountAggregateOutputType | null
    _avg: Recurring_instancesAvgAggregateOutputType | null
    _sum: Recurring_instancesSumAggregateOutputType | null
    _min: Recurring_instancesMinAggregateOutputType | null
    _max: Recurring_instancesMaxAggregateOutputType | null
  }

  type GetRecurring_instancesGroupByPayload<T extends recurring_instancesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Recurring_instancesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Recurring_instancesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Recurring_instancesGroupByOutputType[P]>
            : GetScalarType<T[P], Recurring_instancesGroupByOutputType[P]>
        }
      >
    >


  export type recurring_instancesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instance_id?: boolean
    appoint_id?: boolean
    recurrence_id?: boolean
    appoint_date?: boolean
    appoint_time?: boolean
    instance_status?: boolean
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    recurrence?: boolean | recurrenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurring_instances"]>

  export type recurring_instancesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instance_id?: boolean
    appoint_id?: boolean
    recurrence_id?: boolean
    appoint_date?: boolean
    appoint_time?: boolean
    instance_status?: boolean
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    recurrence?: boolean | recurrenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurring_instances"]>

  export type recurring_instancesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instance_id?: boolean
    appoint_id?: boolean
    recurrence_id?: boolean
    appoint_date?: boolean
    appoint_time?: boolean
    instance_status?: boolean
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    recurrence?: boolean | recurrenceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurring_instances"]>

  export type recurring_instancesSelectScalar = {
    instance_id?: boolean
    appoint_id?: boolean
    recurrence_id?: boolean
    appoint_date?: boolean
    appoint_time?: boolean
    instance_status?: boolean
  }

  export type recurring_instancesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"instance_id" | "appoint_id" | "recurrence_id" | "appoint_date" | "appoint_time" | "instance_status", ExtArgs["result"]["recurring_instances"]>
  export type recurring_instancesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    recurrence?: boolean | recurrenceDefaultArgs<ExtArgs>
  }
  export type recurring_instancesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    recurrence?: boolean | recurrenceDefaultArgs<ExtArgs>
  }
  export type recurring_instancesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    recurrence?: boolean | recurrenceDefaultArgs<ExtArgs>
  }

  export type $recurring_instancesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "recurring_instances"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs>
      recurrence: Prisma.$recurrencePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      instance_id: bigint
      appoint_id: bigint
      recurrence_id: bigint
      appoint_date: Date | null
      appoint_time: Date | null
      instance_status: string | null
    }, ExtArgs["result"]["recurring_instances"]>
    composites: {}
  }

  type recurring_instancesGetPayload<S extends boolean | null | undefined | recurring_instancesDefaultArgs> = $Result.GetResult<Prisma.$recurring_instancesPayload, S>

  type recurring_instancesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<recurring_instancesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Recurring_instancesCountAggregateInputType | true
    }

  export interface recurring_instancesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['recurring_instances'], meta: { name: 'recurring_instances' } }
    /**
     * Find zero or one Recurring_instances that matches the filter.
     * @param {recurring_instancesFindUniqueArgs} args - Arguments to find a Recurring_instances
     * @example
     * // Get one Recurring_instances
     * const recurring_instances = await prisma.recurring_instances.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends recurring_instancesFindUniqueArgs>(args: SelectSubset<T, recurring_instancesFindUniqueArgs<ExtArgs>>): Prisma__recurring_instancesClient<$Result.GetResult<Prisma.$recurring_instancesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Recurring_instances that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {recurring_instancesFindUniqueOrThrowArgs} args - Arguments to find a Recurring_instances
     * @example
     * // Get one Recurring_instances
     * const recurring_instances = await prisma.recurring_instances.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends recurring_instancesFindUniqueOrThrowArgs>(args: SelectSubset<T, recurring_instancesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__recurring_instancesClient<$Result.GetResult<Prisma.$recurring_instancesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Recurring_instances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recurring_instancesFindFirstArgs} args - Arguments to find a Recurring_instances
     * @example
     * // Get one Recurring_instances
     * const recurring_instances = await prisma.recurring_instances.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends recurring_instancesFindFirstArgs>(args?: SelectSubset<T, recurring_instancesFindFirstArgs<ExtArgs>>): Prisma__recurring_instancesClient<$Result.GetResult<Prisma.$recurring_instancesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Recurring_instances that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recurring_instancesFindFirstOrThrowArgs} args - Arguments to find a Recurring_instances
     * @example
     * // Get one Recurring_instances
     * const recurring_instances = await prisma.recurring_instances.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends recurring_instancesFindFirstOrThrowArgs>(args?: SelectSubset<T, recurring_instancesFindFirstOrThrowArgs<ExtArgs>>): Prisma__recurring_instancesClient<$Result.GetResult<Prisma.$recurring_instancesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Recurring_instances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recurring_instancesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recurring_instances
     * const recurring_instances = await prisma.recurring_instances.findMany()
     * 
     * // Get first 10 Recurring_instances
     * const recurring_instances = await prisma.recurring_instances.findMany({ take: 10 })
     * 
     * // Only select the `instance_id`
     * const recurring_instancesWithInstance_idOnly = await prisma.recurring_instances.findMany({ select: { instance_id: true } })
     * 
     */
    findMany<T extends recurring_instancesFindManyArgs>(args?: SelectSubset<T, recurring_instancesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recurring_instancesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Recurring_instances.
     * @param {recurring_instancesCreateArgs} args - Arguments to create a Recurring_instances.
     * @example
     * // Create one Recurring_instances
     * const Recurring_instances = await prisma.recurring_instances.create({
     *   data: {
     *     // ... data to create a Recurring_instances
     *   }
     * })
     * 
     */
    create<T extends recurring_instancesCreateArgs>(args: SelectSubset<T, recurring_instancesCreateArgs<ExtArgs>>): Prisma__recurring_instancesClient<$Result.GetResult<Prisma.$recurring_instancesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Recurring_instances.
     * @param {recurring_instancesCreateManyArgs} args - Arguments to create many Recurring_instances.
     * @example
     * // Create many Recurring_instances
     * const recurring_instances = await prisma.recurring_instances.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends recurring_instancesCreateManyArgs>(args?: SelectSubset<T, recurring_instancesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recurring_instances and returns the data saved in the database.
     * @param {recurring_instancesCreateManyAndReturnArgs} args - Arguments to create many Recurring_instances.
     * @example
     * // Create many Recurring_instances
     * const recurring_instances = await prisma.recurring_instances.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recurring_instances and only return the `instance_id`
     * const recurring_instancesWithInstance_idOnly = await prisma.recurring_instances.createManyAndReturn({
     *   select: { instance_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends recurring_instancesCreateManyAndReturnArgs>(args?: SelectSubset<T, recurring_instancesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recurring_instancesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Recurring_instances.
     * @param {recurring_instancesDeleteArgs} args - Arguments to delete one Recurring_instances.
     * @example
     * // Delete one Recurring_instances
     * const Recurring_instances = await prisma.recurring_instances.delete({
     *   where: {
     *     // ... filter to delete one Recurring_instances
     *   }
     * })
     * 
     */
    delete<T extends recurring_instancesDeleteArgs>(args: SelectSubset<T, recurring_instancesDeleteArgs<ExtArgs>>): Prisma__recurring_instancesClient<$Result.GetResult<Prisma.$recurring_instancesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Recurring_instances.
     * @param {recurring_instancesUpdateArgs} args - Arguments to update one Recurring_instances.
     * @example
     * // Update one Recurring_instances
     * const recurring_instances = await prisma.recurring_instances.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends recurring_instancesUpdateArgs>(args: SelectSubset<T, recurring_instancesUpdateArgs<ExtArgs>>): Prisma__recurring_instancesClient<$Result.GetResult<Prisma.$recurring_instancesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Recurring_instances.
     * @param {recurring_instancesDeleteManyArgs} args - Arguments to filter Recurring_instances to delete.
     * @example
     * // Delete a few Recurring_instances
     * const { count } = await prisma.recurring_instances.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends recurring_instancesDeleteManyArgs>(args?: SelectSubset<T, recurring_instancesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recurring_instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recurring_instancesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recurring_instances
     * const recurring_instances = await prisma.recurring_instances.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends recurring_instancesUpdateManyArgs>(args: SelectSubset<T, recurring_instancesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recurring_instances and returns the data updated in the database.
     * @param {recurring_instancesUpdateManyAndReturnArgs} args - Arguments to update many Recurring_instances.
     * @example
     * // Update many Recurring_instances
     * const recurring_instances = await prisma.recurring_instances.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recurring_instances and only return the `instance_id`
     * const recurring_instancesWithInstance_idOnly = await prisma.recurring_instances.updateManyAndReturn({
     *   select: { instance_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends recurring_instancesUpdateManyAndReturnArgs>(args: SelectSubset<T, recurring_instancesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recurring_instancesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Recurring_instances.
     * @param {recurring_instancesUpsertArgs} args - Arguments to update or create a Recurring_instances.
     * @example
     * // Update or create a Recurring_instances
     * const recurring_instances = await prisma.recurring_instances.upsert({
     *   create: {
     *     // ... data to create a Recurring_instances
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recurring_instances we want to update
     *   }
     * })
     */
    upsert<T extends recurring_instancesUpsertArgs>(args: SelectSubset<T, recurring_instancesUpsertArgs<ExtArgs>>): Prisma__recurring_instancesClient<$Result.GetResult<Prisma.$recurring_instancesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Recurring_instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recurring_instancesCountArgs} args - Arguments to filter Recurring_instances to count.
     * @example
     * // Count the number of Recurring_instances
     * const count = await prisma.recurring_instances.count({
     *   where: {
     *     // ... the filter for the Recurring_instances we want to count
     *   }
     * })
    **/
    count<T extends recurring_instancesCountArgs>(
      args?: Subset<T, recurring_instancesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Recurring_instancesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recurring_instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Recurring_instancesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Recurring_instancesAggregateArgs>(args: Subset<T, Recurring_instancesAggregateArgs>): Prisma.PrismaPromise<GetRecurring_instancesAggregateType<T>>

    /**
     * Group by Recurring_instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recurring_instancesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends recurring_instancesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recurring_instancesGroupByArgs['orderBy'] }
        : { orderBy?: recurring_instancesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, recurring_instancesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurring_instancesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the recurring_instances model
   */
  readonly fields: recurring_instancesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for recurring_instances.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recurring_instancesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends appointmentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, appointmentsDefaultArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    recurrence<T extends recurrenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, recurrenceDefaultArgs<ExtArgs>>): Prisma__recurrenceClient<$Result.GetResult<Prisma.$recurrencePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the recurring_instances model
   */ 
  interface recurring_instancesFieldRefs {
    readonly instance_id: FieldRef<"recurring_instances", 'BigInt'>
    readonly appoint_id: FieldRef<"recurring_instances", 'BigInt'>
    readonly recurrence_id: FieldRef<"recurring_instances", 'BigInt'>
    readonly appoint_date: FieldRef<"recurring_instances", 'DateTime'>
    readonly appoint_time: FieldRef<"recurring_instances", 'DateTime'>
    readonly instance_status: FieldRef<"recurring_instances", 'String'>
  }
    

  // Custom InputTypes
  /**
   * recurring_instances findUnique
   */
  export type recurring_instancesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesInclude<ExtArgs> | null
    /**
     * Filter, which recurring_instances to fetch.
     */
    where: recurring_instancesWhereUniqueInput
  }

  /**
   * recurring_instances findUniqueOrThrow
   */
  export type recurring_instancesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesInclude<ExtArgs> | null
    /**
     * Filter, which recurring_instances to fetch.
     */
    where: recurring_instancesWhereUniqueInput
  }

  /**
   * recurring_instances findFirst
   */
  export type recurring_instancesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesInclude<ExtArgs> | null
    /**
     * Filter, which recurring_instances to fetch.
     */
    where?: recurring_instancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recurring_instances to fetch.
     */
    orderBy?: recurring_instancesOrderByWithRelationInput | recurring_instancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recurring_instances.
     */
    cursor?: recurring_instancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recurring_instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recurring_instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recurring_instances.
     */
    distinct?: Recurring_instancesScalarFieldEnum | Recurring_instancesScalarFieldEnum[]
  }

  /**
   * recurring_instances findFirstOrThrow
   */
  export type recurring_instancesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesInclude<ExtArgs> | null
    /**
     * Filter, which recurring_instances to fetch.
     */
    where?: recurring_instancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recurring_instances to fetch.
     */
    orderBy?: recurring_instancesOrderByWithRelationInput | recurring_instancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recurring_instances.
     */
    cursor?: recurring_instancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recurring_instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recurring_instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recurring_instances.
     */
    distinct?: Recurring_instancesScalarFieldEnum | Recurring_instancesScalarFieldEnum[]
  }

  /**
   * recurring_instances findMany
   */
  export type recurring_instancesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesInclude<ExtArgs> | null
    /**
     * Filter, which recurring_instances to fetch.
     */
    where?: recurring_instancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recurring_instances to fetch.
     */
    orderBy?: recurring_instancesOrderByWithRelationInput | recurring_instancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recurring_instances.
     */
    cursor?: recurring_instancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recurring_instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recurring_instances.
     */
    skip?: number
    distinct?: Recurring_instancesScalarFieldEnum | Recurring_instancesScalarFieldEnum[]
  }

  /**
   * recurring_instances create
   */
  export type recurring_instancesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesInclude<ExtArgs> | null
    /**
     * The data needed to create a recurring_instances.
     */
    data: XOR<recurring_instancesCreateInput, recurring_instancesUncheckedCreateInput>
  }

  /**
   * recurring_instances createMany
   */
  export type recurring_instancesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many recurring_instances.
     */
    data: recurring_instancesCreateManyInput | recurring_instancesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * recurring_instances createManyAndReturn
   */
  export type recurring_instancesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * The data used to create many recurring_instances.
     */
    data: recurring_instancesCreateManyInput | recurring_instancesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * recurring_instances update
   */
  export type recurring_instancesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesInclude<ExtArgs> | null
    /**
     * The data needed to update a recurring_instances.
     */
    data: XOR<recurring_instancesUpdateInput, recurring_instancesUncheckedUpdateInput>
    /**
     * Choose, which recurring_instances to update.
     */
    where: recurring_instancesWhereUniqueInput
  }

  /**
   * recurring_instances updateMany
   */
  export type recurring_instancesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update recurring_instances.
     */
    data: XOR<recurring_instancesUpdateManyMutationInput, recurring_instancesUncheckedUpdateManyInput>
    /**
     * Filter which recurring_instances to update
     */
    where?: recurring_instancesWhereInput
    /**
     * Limit how many recurring_instances to update.
     */
    limit?: number
  }

  /**
   * recurring_instances updateManyAndReturn
   */
  export type recurring_instancesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * The data used to update recurring_instances.
     */
    data: XOR<recurring_instancesUpdateManyMutationInput, recurring_instancesUncheckedUpdateManyInput>
    /**
     * Filter which recurring_instances to update
     */
    where?: recurring_instancesWhereInput
    /**
     * Limit how many recurring_instances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * recurring_instances upsert
   */
  export type recurring_instancesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesInclude<ExtArgs> | null
    /**
     * The filter to search for the recurring_instances to update in case it exists.
     */
    where: recurring_instancesWhereUniqueInput
    /**
     * In case the recurring_instances found by the `where` argument doesn't exist, create a new recurring_instances with this data.
     */
    create: XOR<recurring_instancesCreateInput, recurring_instancesUncheckedCreateInput>
    /**
     * In case the recurring_instances was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recurring_instancesUpdateInput, recurring_instancesUncheckedUpdateInput>
  }

  /**
   * recurring_instances delete
   */
  export type recurring_instancesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesInclude<ExtArgs> | null
    /**
     * Filter which recurring_instances to delete.
     */
    where: recurring_instancesWhereUniqueInput
  }

  /**
   * recurring_instances deleteMany
   */
  export type recurring_instancesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recurring_instances to delete
     */
    where?: recurring_instancesWhereInput
    /**
     * Limit how many recurring_instances to delete.
     */
    limit?: number
  }

  /**
   * recurring_instances without action
   */
  export type recurring_instancesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurring_instances
     */
    select?: recurring_instancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recurring_instances
     */
    omit?: recurring_instancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recurring_instancesInclude<ExtArgs> | null
  }


  /**
   * Model session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    session_id: number | null
    patient_id: number | null
    staff_id: number | null
    appoint_id: number | null
  }

  export type SessionSumAggregateOutputType = {
    session_id: bigint | null
    patient_id: bigint | null
    staff_id: bigint | null
    appoint_id: bigint | null
  }

  export type SessionMinAggregateOutputType = {
    session_id: bigint | null
    patient_id: bigint | null
    staff_id: bigint | null
    appoint_id: bigint | null
  }

  export type SessionMaxAggregateOutputType = {
    session_id: bigint | null
    patient_id: bigint | null
    staff_id: bigint | null
    appoint_id: bigint | null
  }

  export type SessionCountAggregateOutputType = {
    session_id: number
    patient_id: number
    staff_id: number
    appoint_id: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    session_id?: true
    patient_id?: true
    staff_id?: true
    appoint_id?: true
  }

  export type SessionSumAggregateInputType = {
    session_id?: true
    patient_id?: true
    staff_id?: true
    appoint_id?: true
  }

  export type SessionMinAggregateInputType = {
    session_id?: true
    patient_id?: true
    staff_id?: true
    appoint_id?: true
  }

  export type SessionMaxAggregateInputType = {
    session_id?: true
    patient_id?: true
    staff_id?: true
    appoint_id?: true
  }

  export type SessionCountAggregateInputType = {
    session_id?: true
    patient_id?: true
    staff_id?: true
    appoint_id?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session to aggregate.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type sessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithAggregationInput | sessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    session_id: bigint
    patient_id: bigint
    staff_id: bigint
    appoint_id: bigint
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type sessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_id?: boolean
    patient_id?: boolean
    staff_id?: boolean
    appoint_id?: boolean
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
    session_details?: boolean | session$session_detailsArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type sessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_id?: boolean
    patient_id?: boolean
    staff_id?: boolean
    appoint_id?: boolean
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type sessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_id?: boolean
    patient_id?: boolean
    staff_id?: boolean
    appoint_id?: boolean
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type sessionSelectScalar = {
    session_id?: boolean
    patient_id?: boolean
    staff_id?: boolean
    appoint_id?: boolean
  }

  export type sessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"session_id" | "patient_id" | "staff_id" | "appoint_id", ExtArgs["result"]["session"]>
  export type sessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
    session_details?: boolean | session$session_detailsArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type sessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }
  export type sessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | appointmentsDefaultArgs<ExtArgs>
    patients?: boolean | patientsDefaultArgs<ExtArgs>
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }

  export type $sessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs>
      patients: Prisma.$patientsPayload<ExtArgs>
      clinic_staff: Prisma.$clinic_staffPayload<ExtArgs>
      session_details: Prisma.$session_detailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      session_id: bigint
      patient_id: bigint
      staff_id: bigint
      appoint_id: bigint
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type sessionGetPayload<S extends boolean | null | undefined | sessionDefaultArgs> = $Result.GetResult<Prisma.$sessionPayload, S>

  type sessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface sessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session'], meta: { name: 'session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {sessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionFindUniqueArgs>(args: SelectSubset<T, sessionFindUniqueArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionFindFirstArgs>(args?: SelectSubset<T, sessionFindFirstArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `session_id`
     * const sessionWithSession_idOnly = await prisma.session.findMany({ select: { session_id: true } })
     * 
     */
    findMany<T extends sessionFindManyArgs>(args?: SelectSubset<T, sessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Session.
     * @param {sessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends sessionCreateArgs>(args: SelectSubset<T, sessionCreateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sessions.
     * @param {sessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionCreateManyArgs>(args?: SelectSubset<T, sessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {sessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `session_id`
     * const sessionWithSession_idOnly = await prisma.session.createManyAndReturn({
     *   select: { session_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sessionCreateManyAndReturnArgs>(args?: SelectSubset<T, sessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Session.
     * @param {sessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends sessionDeleteArgs>(args: SelectSubset<T, sessionDeleteArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Session.
     * @param {sessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionUpdateArgs>(args: SelectSubset<T, sessionUpdateArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionDeleteManyArgs>(args?: SelectSubset<T, sessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionUpdateManyArgs>(args: SelectSubset<T, sessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {sessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `session_id`
     * const sessionWithSession_idOnly = await prisma.session.updateManyAndReturn({
     *   select: { session_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sessionUpdateManyAndReturnArgs>(args: SelectSubset<T, sessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Session.
     * @param {sessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends sessionUpsertArgs>(args: SelectSubset<T, sessionUpsertArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionCountArgs>(
      args?: Subset<T, sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionGroupByArgs['orderBy'] }
        : { orderBy?: sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session model
   */
  readonly fields: sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends appointmentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, appointmentsDefaultArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    patients<T extends patientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, patientsDefaultArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    clinic_staff<T extends clinic_staffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clinic_staffDefaultArgs<ExtArgs>>): Prisma__clinic_staffClient<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    session_details<T extends session$session_detailsArgs<ExtArgs> = {}>(args?: Subset<T, session$session_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_detailsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session model
   */ 
  interface sessionFieldRefs {
    readonly session_id: FieldRef<"session", 'BigInt'>
    readonly patient_id: FieldRef<"session", 'BigInt'>
    readonly staff_id: FieldRef<"session", 'BigInt'>
    readonly appoint_id: FieldRef<"session", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * session findUnique
   */
  export type sessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findUniqueOrThrow
   */
  export type sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session findFirst
   */
  export type sessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findFirstOrThrow
   */
  export type sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session findMany
   */
  export type sessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * session create
   */
  export type sessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The data needed to create a session.
     */
    data: XOR<sessionCreateInput, sessionUncheckedCreateInput>
  }

  /**
   * session createMany
   */
  export type sessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session createManyAndReturn
   */
  export type sessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * session update
   */
  export type sessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The data needed to update a session.
     */
    data: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
    /**
     * Choose, which session to update.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session updateMany
   */
  export type sessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * session updateManyAndReturn
   */
  export type sessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * session upsert
   */
  export type sessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * The filter to search for the session to update in case it exists.
     */
    where: sessionWhereUniqueInput
    /**
     * In case the session found by the `where` argument doesn't exist, create a new session with this data.
     */
    create: XOR<sessionCreateInput, sessionUncheckedCreateInput>
    /**
     * In case the session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
  }

  /**
   * session delete
   */
  export type sessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
    /**
     * Filter which session to delete.
     */
    where: sessionWhereUniqueInput
  }

  /**
   * session deleteMany
   */
  export type sessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * session.session_details
   */
  export type session$session_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_details
     */
    select?: session_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_details
     */
    omit?: session_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_detailsInclude<ExtArgs> | null
    where?: session_detailsWhereInput
    orderBy?: session_detailsOrderByWithRelationInput | session_detailsOrderByWithRelationInput[]
    cursor?: session_detailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Session_detailsScalarFieldEnum | Session_detailsScalarFieldEnum[]
  }

  /**
   * session without action
   */
  export type sessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null
  }


  /**
   * Model session_details
   */

  export type AggregateSession_details = {
    _count: Session_detailsCountAggregateOutputType | null
    _avg: Session_detailsAvgAggregateOutputType | null
    _sum: Session_detailsSumAggregateOutputType | null
    _min: Session_detailsMinAggregateOutputType | null
    _max: Session_detailsMaxAggregateOutputType | null
  }

  export type Session_detailsAvgAggregateOutputType = {
    session_details_id: number | null
    session_id: number | null
  }

  export type Session_detailsSumAggregateOutputType = {
    session_details_id: bigint | null
    session_id: bigint | null
  }

  export type Session_detailsMinAggregateOutputType = {
    session_details_id: bigint | null
    session_id: bigint | null
    session_description: string | null
    session_date: Date | null
    session_time: Date | null
    session_document: Uint8Array | null
  }

  export type Session_detailsMaxAggregateOutputType = {
    session_details_id: bigint | null
    session_id: bigint | null
    session_description: string | null
    session_date: Date | null
    session_time: Date | null
    session_document: Uint8Array | null
  }

  export type Session_detailsCountAggregateOutputType = {
    session_details_id: number
    session_id: number
    session_description: number
    session_date: number
    session_time: number
    session_document: number
    _all: number
  }


  export type Session_detailsAvgAggregateInputType = {
    session_details_id?: true
    session_id?: true
  }

  export type Session_detailsSumAggregateInputType = {
    session_details_id?: true
    session_id?: true
  }

  export type Session_detailsMinAggregateInputType = {
    session_details_id?: true
    session_id?: true
    session_description?: true
    session_date?: true
    session_time?: true
    session_document?: true
  }

  export type Session_detailsMaxAggregateInputType = {
    session_details_id?: true
    session_id?: true
    session_description?: true
    session_date?: true
    session_time?: true
    session_document?: true
  }

  export type Session_detailsCountAggregateInputType = {
    session_details_id?: true
    session_id?: true
    session_description?: true
    session_date?: true
    session_time?: true
    session_document?: true
    _all?: true
  }

  export type Session_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_details to aggregate.
     */
    where?: session_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_details to fetch.
     */
    orderBy?: session_detailsOrderByWithRelationInput | session_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: session_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned session_details
    **/
    _count?: true | Session_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Session_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Session_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Session_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Session_detailsMaxAggregateInputType
  }

  export type GetSession_detailsAggregateType<T extends Session_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateSession_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession_details[P]>
      : GetScalarType<T[P], AggregateSession_details[P]>
  }




  export type session_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: session_detailsWhereInput
    orderBy?: session_detailsOrderByWithAggregationInput | session_detailsOrderByWithAggregationInput[]
    by: Session_detailsScalarFieldEnum[] | Session_detailsScalarFieldEnum
    having?: session_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Session_detailsCountAggregateInputType | true
    _avg?: Session_detailsAvgAggregateInputType
    _sum?: Session_detailsSumAggregateInputType
    _min?: Session_detailsMinAggregateInputType
    _max?: Session_detailsMaxAggregateInputType
  }

  export type Session_detailsGroupByOutputType = {
    session_details_id: bigint
    session_id: bigint
    session_description: string | null
    session_date: Date | null
    session_time: Date | null
    session_document: Uint8Array | null
    _count: Session_detailsCountAggregateOutputType | null
    _avg: Session_detailsAvgAggregateOutputType | null
    _sum: Session_detailsSumAggregateOutputType | null
    _min: Session_detailsMinAggregateOutputType | null
    _max: Session_detailsMaxAggregateOutputType | null
  }

  type GetSession_detailsGroupByPayload<T extends session_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Session_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Session_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Session_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Session_detailsGroupByOutputType[P]>
        }
      >
    >


  export type session_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_details_id?: boolean
    session_id?: boolean
    session_description?: boolean
    session_date?: boolean
    session_time?: boolean
    session_document?: boolean
    session?: boolean | sessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session_details"]>

  export type session_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_details_id?: boolean
    session_id?: boolean
    session_description?: boolean
    session_date?: boolean
    session_time?: boolean
    session_document?: boolean
    session?: boolean | sessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session_details"]>

  export type session_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_details_id?: boolean
    session_id?: boolean
    session_description?: boolean
    session_date?: boolean
    session_time?: boolean
    session_document?: boolean
    session?: boolean | sessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session_details"]>

  export type session_detailsSelectScalar = {
    session_details_id?: boolean
    session_id?: boolean
    session_description?: boolean
    session_date?: boolean
    session_time?: boolean
    session_document?: boolean
  }

  export type session_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"session_details_id" | "session_id" | "session_description" | "session_date" | "session_time" | "session_document", ExtArgs["result"]["session_details"]>
  export type session_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | sessionDefaultArgs<ExtArgs>
  }
  export type session_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | sessionDefaultArgs<ExtArgs>
  }
  export type session_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | sessionDefaultArgs<ExtArgs>
  }

  export type $session_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session_details"
    objects: {
      session: Prisma.$sessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      session_details_id: bigint
      session_id: bigint
      session_description: string | null
      session_date: Date | null
      session_time: Date | null
      session_document: Uint8Array | null
    }, ExtArgs["result"]["session_details"]>
    composites: {}
  }

  type session_detailsGetPayload<S extends boolean | null | undefined | session_detailsDefaultArgs> = $Result.GetResult<Prisma.$session_detailsPayload, S>

  type session_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<session_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Session_detailsCountAggregateInputType | true
    }

  export interface session_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session_details'], meta: { name: 'session_details' } }
    /**
     * Find zero or one Session_details that matches the filter.
     * @param {session_detailsFindUniqueArgs} args - Arguments to find a Session_details
     * @example
     * // Get one Session_details
     * const session_details = await prisma.session_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends session_detailsFindUniqueArgs>(args: SelectSubset<T, session_detailsFindUniqueArgs<ExtArgs>>): Prisma__session_detailsClient<$Result.GetResult<Prisma.$session_detailsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Session_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {session_detailsFindUniqueOrThrowArgs} args - Arguments to find a Session_details
     * @example
     * // Get one Session_details
     * const session_details = await prisma.session_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends session_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, session_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__session_detailsClient<$Result.GetResult<Prisma.$session_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Session_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_detailsFindFirstArgs} args - Arguments to find a Session_details
     * @example
     * // Get one Session_details
     * const session_details = await prisma.session_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends session_detailsFindFirstArgs>(args?: SelectSubset<T, session_detailsFindFirstArgs<ExtArgs>>): Prisma__session_detailsClient<$Result.GetResult<Prisma.$session_detailsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Session_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_detailsFindFirstOrThrowArgs} args - Arguments to find a Session_details
     * @example
     * // Get one Session_details
     * const session_details = await prisma.session_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends session_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, session_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__session_detailsClient<$Result.GetResult<Prisma.$session_detailsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Session_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Session_details
     * const session_details = await prisma.session_details.findMany()
     * 
     * // Get first 10 Session_details
     * const session_details = await prisma.session_details.findMany({ take: 10 })
     * 
     * // Only select the `session_details_id`
     * const session_detailsWithSession_details_idOnly = await prisma.session_details.findMany({ select: { session_details_id: true } })
     * 
     */
    findMany<T extends session_detailsFindManyArgs>(args?: SelectSubset<T, session_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_detailsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Session_details.
     * @param {session_detailsCreateArgs} args - Arguments to create a Session_details.
     * @example
     * // Create one Session_details
     * const Session_details = await prisma.session_details.create({
     *   data: {
     *     // ... data to create a Session_details
     *   }
     * })
     * 
     */
    create<T extends session_detailsCreateArgs>(args: SelectSubset<T, session_detailsCreateArgs<ExtArgs>>): Prisma__session_detailsClient<$Result.GetResult<Prisma.$session_detailsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Session_details.
     * @param {session_detailsCreateManyArgs} args - Arguments to create many Session_details.
     * @example
     * // Create many Session_details
     * const session_details = await prisma.session_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends session_detailsCreateManyArgs>(args?: SelectSubset<T, session_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Session_details and returns the data saved in the database.
     * @param {session_detailsCreateManyAndReturnArgs} args - Arguments to create many Session_details.
     * @example
     * // Create many Session_details
     * const session_details = await prisma.session_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Session_details and only return the `session_details_id`
     * const session_detailsWithSession_details_idOnly = await prisma.session_details.createManyAndReturn({
     *   select: { session_details_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends session_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, session_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_detailsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Session_details.
     * @param {session_detailsDeleteArgs} args - Arguments to delete one Session_details.
     * @example
     * // Delete one Session_details
     * const Session_details = await prisma.session_details.delete({
     *   where: {
     *     // ... filter to delete one Session_details
     *   }
     * })
     * 
     */
    delete<T extends session_detailsDeleteArgs>(args: SelectSubset<T, session_detailsDeleteArgs<ExtArgs>>): Prisma__session_detailsClient<$Result.GetResult<Prisma.$session_detailsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Session_details.
     * @param {session_detailsUpdateArgs} args - Arguments to update one Session_details.
     * @example
     * // Update one Session_details
     * const session_details = await prisma.session_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends session_detailsUpdateArgs>(args: SelectSubset<T, session_detailsUpdateArgs<ExtArgs>>): Prisma__session_detailsClient<$Result.GetResult<Prisma.$session_detailsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Session_details.
     * @param {session_detailsDeleteManyArgs} args - Arguments to filter Session_details to delete.
     * @example
     * // Delete a few Session_details
     * const { count } = await prisma.session_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends session_detailsDeleteManyArgs>(args?: SelectSubset<T, session_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Session_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Session_details
     * const session_details = await prisma.session_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends session_detailsUpdateManyArgs>(args: SelectSubset<T, session_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Session_details and returns the data updated in the database.
     * @param {session_detailsUpdateManyAndReturnArgs} args - Arguments to update many Session_details.
     * @example
     * // Update many Session_details
     * const session_details = await prisma.session_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Session_details and only return the `session_details_id`
     * const session_detailsWithSession_details_idOnly = await prisma.session_details.updateManyAndReturn({
     *   select: { session_details_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends session_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, session_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$session_detailsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Session_details.
     * @param {session_detailsUpsertArgs} args - Arguments to update or create a Session_details.
     * @example
     * // Update or create a Session_details
     * const session_details = await prisma.session_details.upsert({
     *   create: {
     *     // ... data to create a Session_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session_details we want to update
     *   }
     * })
     */
    upsert<T extends session_detailsUpsertArgs>(args: SelectSubset<T, session_detailsUpsertArgs<ExtArgs>>): Prisma__session_detailsClient<$Result.GetResult<Prisma.$session_detailsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Session_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_detailsCountArgs} args - Arguments to filter Session_details to count.
     * @example
     * // Count the number of Session_details
     * const count = await prisma.session_details.count({
     *   where: {
     *     // ... the filter for the Session_details we want to count
     *   }
     * })
    **/
    count<T extends session_detailsCountArgs>(
      args?: Subset<T, session_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Session_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Session_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Session_detailsAggregateArgs>(args: Subset<T, Session_detailsAggregateArgs>): Prisma.PrismaPromise<GetSession_detailsAggregateType<T>>

    /**
     * Group by Session_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {session_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends session_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: session_detailsGroupByArgs['orderBy'] }
        : { orderBy?: session_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, session_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSession_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session_details model
   */
  readonly fields: session_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__session_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends sessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sessionDefaultArgs<ExtArgs>>): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the session_details model
   */ 
  interface session_detailsFieldRefs {
    readonly session_details_id: FieldRef<"session_details", 'BigInt'>
    readonly session_id: FieldRef<"session_details", 'BigInt'>
    readonly session_description: FieldRef<"session_details", 'String'>
    readonly session_date: FieldRef<"session_details", 'DateTime'>
    readonly session_time: FieldRef<"session_details", 'DateTime'>
    readonly session_document: FieldRef<"session_details", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * session_details findUnique
   */
  export type session_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_details
     */
    select?: session_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_details
     */
    omit?: session_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_detailsInclude<ExtArgs> | null
    /**
     * Filter, which session_details to fetch.
     */
    where: session_detailsWhereUniqueInput
  }

  /**
   * session_details findUniqueOrThrow
   */
  export type session_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_details
     */
    select?: session_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_details
     */
    omit?: session_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_detailsInclude<ExtArgs> | null
    /**
     * Filter, which session_details to fetch.
     */
    where: session_detailsWhereUniqueInput
  }

  /**
   * session_details findFirst
   */
  export type session_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_details
     */
    select?: session_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_details
     */
    omit?: session_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_detailsInclude<ExtArgs> | null
    /**
     * Filter, which session_details to fetch.
     */
    where?: session_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_details to fetch.
     */
    orderBy?: session_detailsOrderByWithRelationInput | session_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_details.
     */
    cursor?: session_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_details.
     */
    distinct?: Session_detailsScalarFieldEnum | Session_detailsScalarFieldEnum[]
  }

  /**
   * session_details findFirstOrThrow
   */
  export type session_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_details
     */
    select?: session_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_details
     */
    omit?: session_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_detailsInclude<ExtArgs> | null
    /**
     * Filter, which session_details to fetch.
     */
    where?: session_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_details to fetch.
     */
    orderBy?: session_detailsOrderByWithRelationInput | session_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for session_details.
     */
    cursor?: session_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of session_details.
     */
    distinct?: Session_detailsScalarFieldEnum | Session_detailsScalarFieldEnum[]
  }

  /**
   * session_details findMany
   */
  export type session_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_details
     */
    select?: session_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_details
     */
    omit?: session_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_detailsInclude<ExtArgs> | null
    /**
     * Filter, which session_details to fetch.
     */
    where?: session_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of session_details to fetch.
     */
    orderBy?: session_detailsOrderByWithRelationInput | session_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing session_details.
     */
    cursor?: session_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` session_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` session_details.
     */
    skip?: number
    distinct?: Session_detailsScalarFieldEnum | Session_detailsScalarFieldEnum[]
  }

  /**
   * session_details create
   */
  export type session_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_details
     */
    select?: session_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_details
     */
    omit?: session_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a session_details.
     */
    data: XOR<session_detailsCreateInput, session_detailsUncheckedCreateInput>
  }

  /**
   * session_details createMany
   */
  export type session_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many session_details.
     */
    data: session_detailsCreateManyInput | session_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * session_details createManyAndReturn
   */
  export type session_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_details
     */
    select?: session_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session_details
     */
    omit?: session_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many session_details.
     */
    data: session_detailsCreateManyInput | session_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * session_details update
   */
  export type session_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_details
     */
    select?: session_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_details
     */
    omit?: session_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a session_details.
     */
    data: XOR<session_detailsUpdateInput, session_detailsUncheckedUpdateInput>
    /**
     * Choose, which session_details to update.
     */
    where: session_detailsWhereUniqueInput
  }

  /**
   * session_details updateMany
   */
  export type session_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update session_details.
     */
    data: XOR<session_detailsUpdateManyMutationInput, session_detailsUncheckedUpdateManyInput>
    /**
     * Filter which session_details to update
     */
    where?: session_detailsWhereInput
    /**
     * Limit how many session_details to update.
     */
    limit?: number
  }

  /**
   * session_details updateManyAndReturn
   */
  export type session_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_details
     */
    select?: session_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the session_details
     */
    omit?: session_detailsOmit<ExtArgs> | null
    /**
     * The data used to update session_details.
     */
    data: XOR<session_detailsUpdateManyMutationInput, session_detailsUncheckedUpdateManyInput>
    /**
     * Filter which session_details to update
     */
    where?: session_detailsWhereInput
    /**
     * Limit how many session_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * session_details upsert
   */
  export type session_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_details
     */
    select?: session_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_details
     */
    omit?: session_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the session_details to update in case it exists.
     */
    where: session_detailsWhereUniqueInput
    /**
     * In case the session_details found by the `where` argument doesn't exist, create a new session_details with this data.
     */
    create: XOR<session_detailsCreateInput, session_detailsUncheckedCreateInput>
    /**
     * In case the session_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<session_detailsUpdateInput, session_detailsUncheckedUpdateInput>
  }

  /**
   * session_details delete
   */
  export type session_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_details
     */
    select?: session_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_details
     */
    omit?: session_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_detailsInclude<ExtArgs> | null
    /**
     * Filter which session_details to delete.
     */
    where: session_detailsWhereUniqueInput
  }

  /**
   * session_details deleteMany
   */
  export type session_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session_details to delete
     */
    where?: session_detailsWhereInput
    /**
     * Limit how many session_details to delete.
     */
    limit?: number
  }

  /**
   * session_details without action
   */
  export type session_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session_details
     */
    select?: session_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the session_details
     */
    omit?: session_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: session_detailsInclude<ExtArgs> | null
  }


  /**
   * Model staff_role
   */

  export type AggregateStaff_role = {
    _count: Staff_roleCountAggregateOutputType | null
    _avg: Staff_roleAvgAggregateOutputType | null
    _sum: Staff_roleSumAggregateOutputType | null
    _min: Staff_roleMinAggregateOutputType | null
    _max: Staff_roleMaxAggregateOutputType | null
  }

  export type Staff_roleAvgAggregateOutputType = {
    staff_role_id: number | null
    staff_id: number | null
  }

  export type Staff_roleSumAggregateOutputType = {
    staff_role_id: bigint | null
    staff_id: bigint | null
  }

  export type Staff_roleMinAggregateOutputType = {
    staff_role_id: bigint | null
    staff_id: bigint | null
    staff_role: string | null
  }

  export type Staff_roleMaxAggregateOutputType = {
    staff_role_id: bigint | null
    staff_id: bigint | null
    staff_role: string | null
  }

  export type Staff_roleCountAggregateOutputType = {
    staff_role_id: number
    staff_id: number
    staff_role: number
    _all: number
  }


  export type Staff_roleAvgAggregateInputType = {
    staff_role_id?: true
    staff_id?: true
  }

  export type Staff_roleSumAggregateInputType = {
    staff_role_id?: true
    staff_id?: true
  }

  export type Staff_roleMinAggregateInputType = {
    staff_role_id?: true
    staff_id?: true
    staff_role?: true
  }

  export type Staff_roleMaxAggregateInputType = {
    staff_role_id?: true
    staff_id?: true
    staff_role?: true
  }

  export type Staff_roleCountAggregateInputType = {
    staff_role_id?: true
    staff_id?: true
    staff_role?: true
    _all?: true
  }

  export type Staff_roleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which staff_role to aggregate.
     */
    where?: staff_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staff_roles to fetch.
     */
    orderBy?: staff_roleOrderByWithRelationInput | staff_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: staff_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staff_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staff_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned staff_roles
    **/
    _count?: true | Staff_roleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Staff_roleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Staff_roleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Staff_roleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Staff_roleMaxAggregateInputType
  }

  export type GetStaff_roleAggregateType<T extends Staff_roleAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff_role]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff_role[P]>
      : GetScalarType<T[P], AggregateStaff_role[P]>
  }




  export type staff_roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: staff_roleWhereInput
    orderBy?: staff_roleOrderByWithAggregationInput | staff_roleOrderByWithAggregationInput[]
    by: Staff_roleScalarFieldEnum[] | Staff_roleScalarFieldEnum
    having?: staff_roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Staff_roleCountAggregateInputType | true
    _avg?: Staff_roleAvgAggregateInputType
    _sum?: Staff_roleSumAggregateInputType
    _min?: Staff_roleMinAggregateInputType
    _max?: Staff_roleMaxAggregateInputType
  }

  export type Staff_roleGroupByOutputType = {
    staff_role_id: bigint
    staff_id: bigint
    staff_role: string | null
    _count: Staff_roleCountAggregateOutputType | null
    _avg: Staff_roleAvgAggregateOutputType | null
    _sum: Staff_roleSumAggregateOutputType | null
    _min: Staff_roleMinAggregateOutputType | null
    _max: Staff_roleMaxAggregateOutputType | null
  }

  type GetStaff_roleGroupByPayload<T extends staff_roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Staff_roleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Staff_roleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Staff_roleGroupByOutputType[P]>
            : GetScalarType<T[P], Staff_roleGroupByOutputType[P]>
        }
      >
    >


  export type staff_roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    staff_role_id?: boolean
    staff_id?: boolean
    staff_role?: boolean
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff_role"]>

  export type staff_roleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    staff_role_id?: boolean
    staff_id?: boolean
    staff_role?: boolean
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff_role"]>

  export type staff_roleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    staff_role_id?: boolean
    staff_id?: boolean
    staff_role?: boolean
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff_role"]>

  export type staff_roleSelectScalar = {
    staff_role_id?: boolean
    staff_id?: boolean
    staff_role?: boolean
  }

  export type staff_roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"staff_role_id" | "staff_id" | "staff_role", ExtArgs["result"]["staff_role"]>
  export type staff_roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }
  export type staff_roleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }
  export type staff_roleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic_staff?: boolean | clinic_staffDefaultArgs<ExtArgs>
  }

  export type $staff_rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "staff_role"
    objects: {
      clinic_staff: Prisma.$clinic_staffPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      staff_role_id: bigint
      staff_id: bigint
      staff_role: string | null
    }, ExtArgs["result"]["staff_role"]>
    composites: {}
  }

  type staff_roleGetPayload<S extends boolean | null | undefined | staff_roleDefaultArgs> = $Result.GetResult<Prisma.$staff_rolePayload, S>

  type staff_roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<staff_roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Staff_roleCountAggregateInputType | true
    }

  export interface staff_roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['staff_role'], meta: { name: 'staff_role' } }
    /**
     * Find zero or one Staff_role that matches the filter.
     * @param {staff_roleFindUniqueArgs} args - Arguments to find a Staff_role
     * @example
     * // Get one Staff_role
     * const staff_role = await prisma.staff_role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends staff_roleFindUniqueArgs>(args: SelectSubset<T, staff_roleFindUniqueArgs<ExtArgs>>): Prisma__staff_roleClient<$Result.GetResult<Prisma.$staff_rolePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Staff_role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {staff_roleFindUniqueOrThrowArgs} args - Arguments to find a Staff_role
     * @example
     * // Get one Staff_role
     * const staff_role = await prisma.staff_role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends staff_roleFindUniqueOrThrowArgs>(args: SelectSubset<T, staff_roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__staff_roleClient<$Result.GetResult<Prisma.$staff_rolePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Staff_role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staff_roleFindFirstArgs} args - Arguments to find a Staff_role
     * @example
     * // Get one Staff_role
     * const staff_role = await prisma.staff_role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends staff_roleFindFirstArgs>(args?: SelectSubset<T, staff_roleFindFirstArgs<ExtArgs>>): Prisma__staff_roleClient<$Result.GetResult<Prisma.$staff_rolePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Staff_role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staff_roleFindFirstOrThrowArgs} args - Arguments to find a Staff_role
     * @example
     * // Get one Staff_role
     * const staff_role = await prisma.staff_role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends staff_roleFindFirstOrThrowArgs>(args?: SelectSubset<T, staff_roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__staff_roleClient<$Result.GetResult<Prisma.$staff_rolePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Staff_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staff_roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff_roles
     * const staff_roles = await prisma.staff_role.findMany()
     * 
     * // Get first 10 Staff_roles
     * const staff_roles = await prisma.staff_role.findMany({ take: 10 })
     * 
     * // Only select the `staff_role_id`
     * const staff_roleWithStaff_role_idOnly = await prisma.staff_role.findMany({ select: { staff_role_id: true } })
     * 
     */
    findMany<T extends staff_roleFindManyArgs>(args?: SelectSubset<T, staff_roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staff_rolePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Staff_role.
     * @param {staff_roleCreateArgs} args - Arguments to create a Staff_role.
     * @example
     * // Create one Staff_role
     * const Staff_role = await prisma.staff_role.create({
     *   data: {
     *     // ... data to create a Staff_role
     *   }
     * })
     * 
     */
    create<T extends staff_roleCreateArgs>(args: SelectSubset<T, staff_roleCreateArgs<ExtArgs>>): Prisma__staff_roleClient<$Result.GetResult<Prisma.$staff_rolePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Staff_roles.
     * @param {staff_roleCreateManyArgs} args - Arguments to create many Staff_roles.
     * @example
     * // Create many Staff_roles
     * const staff_role = await prisma.staff_role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends staff_roleCreateManyArgs>(args?: SelectSubset<T, staff_roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Staff_roles and returns the data saved in the database.
     * @param {staff_roleCreateManyAndReturnArgs} args - Arguments to create many Staff_roles.
     * @example
     * // Create many Staff_roles
     * const staff_role = await prisma.staff_role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Staff_roles and only return the `staff_role_id`
     * const staff_roleWithStaff_role_idOnly = await prisma.staff_role.createManyAndReturn({
     *   select: { staff_role_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends staff_roleCreateManyAndReturnArgs>(args?: SelectSubset<T, staff_roleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staff_rolePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Staff_role.
     * @param {staff_roleDeleteArgs} args - Arguments to delete one Staff_role.
     * @example
     * // Delete one Staff_role
     * const Staff_role = await prisma.staff_role.delete({
     *   where: {
     *     // ... filter to delete one Staff_role
     *   }
     * })
     * 
     */
    delete<T extends staff_roleDeleteArgs>(args: SelectSubset<T, staff_roleDeleteArgs<ExtArgs>>): Prisma__staff_roleClient<$Result.GetResult<Prisma.$staff_rolePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Staff_role.
     * @param {staff_roleUpdateArgs} args - Arguments to update one Staff_role.
     * @example
     * // Update one Staff_role
     * const staff_role = await prisma.staff_role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends staff_roleUpdateArgs>(args: SelectSubset<T, staff_roleUpdateArgs<ExtArgs>>): Prisma__staff_roleClient<$Result.GetResult<Prisma.$staff_rolePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Staff_roles.
     * @param {staff_roleDeleteManyArgs} args - Arguments to filter Staff_roles to delete.
     * @example
     * // Delete a few Staff_roles
     * const { count } = await prisma.staff_role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends staff_roleDeleteManyArgs>(args?: SelectSubset<T, staff_roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staff_roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff_roles
     * const staff_role = await prisma.staff_role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends staff_roleUpdateManyArgs>(args: SelectSubset<T, staff_roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff_roles and returns the data updated in the database.
     * @param {staff_roleUpdateManyAndReturnArgs} args - Arguments to update many Staff_roles.
     * @example
     * // Update many Staff_roles
     * const staff_role = await prisma.staff_role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Staff_roles and only return the `staff_role_id`
     * const staff_roleWithStaff_role_idOnly = await prisma.staff_role.updateManyAndReturn({
     *   select: { staff_role_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends staff_roleUpdateManyAndReturnArgs>(args: SelectSubset<T, staff_roleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$staff_rolePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Staff_role.
     * @param {staff_roleUpsertArgs} args - Arguments to update or create a Staff_role.
     * @example
     * // Update or create a Staff_role
     * const staff_role = await prisma.staff_role.upsert({
     *   create: {
     *     // ... data to create a Staff_role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff_role we want to update
     *   }
     * })
     */
    upsert<T extends staff_roleUpsertArgs>(args: SelectSubset<T, staff_roleUpsertArgs<ExtArgs>>): Prisma__staff_roleClient<$Result.GetResult<Prisma.$staff_rolePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Staff_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staff_roleCountArgs} args - Arguments to filter Staff_roles to count.
     * @example
     * // Count the number of Staff_roles
     * const count = await prisma.staff_role.count({
     *   where: {
     *     // ... the filter for the Staff_roles we want to count
     *   }
     * })
    **/
    count<T extends staff_roleCountArgs>(
      args?: Subset<T, staff_roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Staff_roleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Staff_roleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Staff_roleAggregateArgs>(args: Subset<T, Staff_roleAggregateArgs>): Prisma.PrismaPromise<GetStaff_roleAggregateType<T>>

    /**
     * Group by Staff_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {staff_roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends staff_roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: staff_roleGroupByArgs['orderBy'] }
        : { orderBy?: staff_roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, staff_roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaff_roleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the staff_role model
   */
  readonly fields: staff_roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for staff_role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__staff_roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic_staff<T extends clinic_staffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clinic_staffDefaultArgs<ExtArgs>>): Prisma__clinic_staffClient<$Result.GetResult<Prisma.$clinic_staffPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the staff_role model
   */ 
  interface staff_roleFieldRefs {
    readonly staff_role_id: FieldRef<"staff_role", 'BigInt'>
    readonly staff_id: FieldRef<"staff_role", 'BigInt'>
    readonly staff_role: FieldRef<"staff_role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * staff_role findUnique
   */
  export type staff_roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff_role
     */
    select?: staff_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staff_role
     */
    omit?: staff_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staff_roleInclude<ExtArgs> | null
    /**
     * Filter, which staff_role to fetch.
     */
    where: staff_roleWhereUniqueInput
  }

  /**
   * staff_role findUniqueOrThrow
   */
  export type staff_roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff_role
     */
    select?: staff_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staff_role
     */
    omit?: staff_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staff_roleInclude<ExtArgs> | null
    /**
     * Filter, which staff_role to fetch.
     */
    where: staff_roleWhereUniqueInput
  }

  /**
   * staff_role findFirst
   */
  export type staff_roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff_role
     */
    select?: staff_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staff_role
     */
    omit?: staff_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staff_roleInclude<ExtArgs> | null
    /**
     * Filter, which staff_role to fetch.
     */
    where?: staff_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staff_roles to fetch.
     */
    orderBy?: staff_roleOrderByWithRelationInput | staff_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staff_roles.
     */
    cursor?: staff_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staff_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staff_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staff_roles.
     */
    distinct?: Staff_roleScalarFieldEnum | Staff_roleScalarFieldEnum[]
  }

  /**
   * staff_role findFirstOrThrow
   */
  export type staff_roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff_role
     */
    select?: staff_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staff_role
     */
    omit?: staff_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staff_roleInclude<ExtArgs> | null
    /**
     * Filter, which staff_role to fetch.
     */
    where?: staff_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staff_roles to fetch.
     */
    orderBy?: staff_roleOrderByWithRelationInput | staff_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for staff_roles.
     */
    cursor?: staff_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staff_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staff_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of staff_roles.
     */
    distinct?: Staff_roleScalarFieldEnum | Staff_roleScalarFieldEnum[]
  }

  /**
   * staff_role findMany
   */
  export type staff_roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff_role
     */
    select?: staff_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staff_role
     */
    omit?: staff_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staff_roleInclude<ExtArgs> | null
    /**
     * Filter, which staff_roles to fetch.
     */
    where?: staff_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of staff_roles to fetch.
     */
    orderBy?: staff_roleOrderByWithRelationInput | staff_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing staff_roles.
     */
    cursor?: staff_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` staff_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` staff_roles.
     */
    skip?: number
    distinct?: Staff_roleScalarFieldEnum | Staff_roleScalarFieldEnum[]
  }

  /**
   * staff_role create
   */
  export type staff_roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff_role
     */
    select?: staff_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staff_role
     */
    omit?: staff_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staff_roleInclude<ExtArgs> | null
    /**
     * The data needed to create a staff_role.
     */
    data: XOR<staff_roleCreateInput, staff_roleUncheckedCreateInput>
  }

  /**
   * staff_role createMany
   */
  export type staff_roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many staff_roles.
     */
    data: staff_roleCreateManyInput | staff_roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * staff_role createManyAndReturn
   */
  export type staff_roleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff_role
     */
    select?: staff_roleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the staff_role
     */
    omit?: staff_roleOmit<ExtArgs> | null
    /**
     * The data used to create many staff_roles.
     */
    data: staff_roleCreateManyInput | staff_roleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staff_roleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * staff_role update
   */
  export type staff_roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff_role
     */
    select?: staff_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staff_role
     */
    omit?: staff_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staff_roleInclude<ExtArgs> | null
    /**
     * The data needed to update a staff_role.
     */
    data: XOR<staff_roleUpdateInput, staff_roleUncheckedUpdateInput>
    /**
     * Choose, which staff_role to update.
     */
    where: staff_roleWhereUniqueInput
  }

  /**
   * staff_role updateMany
   */
  export type staff_roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update staff_roles.
     */
    data: XOR<staff_roleUpdateManyMutationInput, staff_roleUncheckedUpdateManyInput>
    /**
     * Filter which staff_roles to update
     */
    where?: staff_roleWhereInput
    /**
     * Limit how many staff_roles to update.
     */
    limit?: number
  }

  /**
   * staff_role updateManyAndReturn
   */
  export type staff_roleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff_role
     */
    select?: staff_roleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the staff_role
     */
    omit?: staff_roleOmit<ExtArgs> | null
    /**
     * The data used to update staff_roles.
     */
    data: XOR<staff_roleUpdateManyMutationInput, staff_roleUncheckedUpdateManyInput>
    /**
     * Filter which staff_roles to update
     */
    where?: staff_roleWhereInput
    /**
     * Limit how many staff_roles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staff_roleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * staff_role upsert
   */
  export type staff_roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff_role
     */
    select?: staff_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staff_role
     */
    omit?: staff_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staff_roleInclude<ExtArgs> | null
    /**
     * The filter to search for the staff_role to update in case it exists.
     */
    where: staff_roleWhereUniqueInput
    /**
     * In case the staff_role found by the `where` argument doesn't exist, create a new staff_role with this data.
     */
    create: XOR<staff_roleCreateInput, staff_roleUncheckedCreateInput>
    /**
     * In case the staff_role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<staff_roleUpdateInput, staff_roleUncheckedUpdateInput>
  }

  /**
   * staff_role delete
   */
  export type staff_roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff_role
     */
    select?: staff_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staff_role
     */
    omit?: staff_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staff_roleInclude<ExtArgs> | null
    /**
     * Filter which staff_role to delete.
     */
    where: staff_roleWhereUniqueInput
  }

  /**
   * staff_role deleteMany
   */
  export type staff_roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which staff_roles to delete
     */
    where?: staff_roleWhereInput
    /**
     * Limit how many staff_roles to delete.
     */
    limit?: number
  }

  /**
   * staff_role without action
   */
  export type staff_roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the staff_role
     */
    select?: staff_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the staff_role
     */
    omit?: staff_roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: staff_roleInclude<ExtArgs> | null
  }


  /**
   * Model type_of_payment
   */

  export type AggregateType_of_payment = {
    _count: Type_of_paymentCountAggregateOutputType | null
    _avg: Type_of_paymentAvgAggregateOutputType | null
    _sum: Type_of_paymentSumAggregateOutputType | null
    _min: Type_of_paymentMinAggregateOutputType | null
    _max: Type_of_paymentMaxAggregateOutputType | null
  }

  export type Type_of_paymentAvgAggregateOutputType = {
    type_of_payment_id: number | null
  }

  export type Type_of_paymentSumAggregateOutputType = {
    type_of_payment_id: bigint | null
  }

  export type Type_of_paymentMinAggregateOutputType = {
    type_of_payment_id: bigint | null
    type_of_payment: string | null
  }

  export type Type_of_paymentMaxAggregateOutputType = {
    type_of_payment_id: bigint | null
    type_of_payment: string | null
  }

  export type Type_of_paymentCountAggregateOutputType = {
    type_of_payment_id: number
    type_of_payment: number
    _all: number
  }


  export type Type_of_paymentAvgAggregateInputType = {
    type_of_payment_id?: true
  }

  export type Type_of_paymentSumAggregateInputType = {
    type_of_payment_id?: true
  }

  export type Type_of_paymentMinAggregateInputType = {
    type_of_payment_id?: true
    type_of_payment?: true
  }

  export type Type_of_paymentMaxAggregateInputType = {
    type_of_payment_id?: true
    type_of_payment?: true
  }

  export type Type_of_paymentCountAggregateInputType = {
    type_of_payment_id?: true
    type_of_payment?: true
    _all?: true
  }

  export type Type_of_paymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which type_of_payment to aggregate.
     */
    where?: type_of_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_of_payments to fetch.
     */
    orderBy?: type_of_paymentOrderByWithRelationInput | type_of_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: type_of_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_of_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_of_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned type_of_payments
    **/
    _count?: true | Type_of_paymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Type_of_paymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Type_of_paymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Type_of_paymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Type_of_paymentMaxAggregateInputType
  }

  export type GetType_of_paymentAggregateType<T extends Type_of_paymentAggregateArgs> = {
        [P in keyof T & keyof AggregateType_of_payment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateType_of_payment[P]>
      : GetScalarType<T[P], AggregateType_of_payment[P]>
  }




  export type type_of_paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: type_of_paymentWhereInput
    orderBy?: type_of_paymentOrderByWithAggregationInput | type_of_paymentOrderByWithAggregationInput[]
    by: Type_of_paymentScalarFieldEnum[] | Type_of_paymentScalarFieldEnum
    having?: type_of_paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Type_of_paymentCountAggregateInputType | true
    _avg?: Type_of_paymentAvgAggregateInputType
    _sum?: Type_of_paymentSumAggregateInputType
    _min?: Type_of_paymentMinAggregateInputType
    _max?: Type_of_paymentMaxAggregateInputType
  }

  export type Type_of_paymentGroupByOutputType = {
    type_of_payment_id: bigint
    type_of_payment: string | null
    _count: Type_of_paymentCountAggregateOutputType | null
    _avg: Type_of_paymentAvgAggregateOutputType | null
    _sum: Type_of_paymentSumAggregateOutputType | null
    _min: Type_of_paymentMinAggregateOutputType | null
    _max: Type_of_paymentMaxAggregateOutputType | null
  }

  type GetType_of_paymentGroupByPayload<T extends type_of_paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Type_of_paymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Type_of_paymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Type_of_paymentGroupByOutputType[P]>
            : GetScalarType<T[P], Type_of_paymentGroupByOutputType[P]>
        }
      >
    >


  export type type_of_paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type_of_payment_id?: boolean
    type_of_payment?: boolean
  }, ExtArgs["result"]["type_of_payment"]>

  export type type_of_paymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type_of_payment_id?: boolean
    type_of_payment?: boolean
  }, ExtArgs["result"]["type_of_payment"]>

  export type type_of_paymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    type_of_payment_id?: boolean
    type_of_payment?: boolean
  }, ExtArgs["result"]["type_of_payment"]>

  export type type_of_paymentSelectScalar = {
    type_of_payment_id?: boolean
    type_of_payment?: boolean
  }

  export type type_of_paymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"type_of_payment_id" | "type_of_payment", ExtArgs["result"]["type_of_payment"]>

  export type $type_of_paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "type_of_payment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      type_of_payment_id: bigint
      type_of_payment: string | null
    }, ExtArgs["result"]["type_of_payment"]>
    composites: {}
  }

  type type_of_paymentGetPayload<S extends boolean | null | undefined | type_of_paymentDefaultArgs> = $Result.GetResult<Prisma.$type_of_paymentPayload, S>

  type type_of_paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<type_of_paymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Type_of_paymentCountAggregateInputType | true
    }

  export interface type_of_paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['type_of_payment'], meta: { name: 'type_of_payment' } }
    /**
     * Find zero or one Type_of_payment that matches the filter.
     * @param {type_of_paymentFindUniqueArgs} args - Arguments to find a Type_of_payment
     * @example
     * // Get one Type_of_payment
     * const type_of_payment = await prisma.type_of_payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends type_of_paymentFindUniqueArgs>(args: SelectSubset<T, type_of_paymentFindUniqueArgs<ExtArgs>>): Prisma__type_of_paymentClient<$Result.GetResult<Prisma.$type_of_paymentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Type_of_payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {type_of_paymentFindUniqueOrThrowArgs} args - Arguments to find a Type_of_payment
     * @example
     * // Get one Type_of_payment
     * const type_of_payment = await prisma.type_of_payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends type_of_paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, type_of_paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__type_of_paymentClient<$Result.GetResult<Prisma.$type_of_paymentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Type_of_payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_paymentFindFirstArgs} args - Arguments to find a Type_of_payment
     * @example
     * // Get one Type_of_payment
     * const type_of_payment = await prisma.type_of_payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends type_of_paymentFindFirstArgs>(args?: SelectSubset<T, type_of_paymentFindFirstArgs<ExtArgs>>): Prisma__type_of_paymentClient<$Result.GetResult<Prisma.$type_of_paymentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Type_of_payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_paymentFindFirstOrThrowArgs} args - Arguments to find a Type_of_payment
     * @example
     * // Get one Type_of_payment
     * const type_of_payment = await prisma.type_of_payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends type_of_paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, type_of_paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__type_of_paymentClient<$Result.GetResult<Prisma.$type_of_paymentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Type_of_payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Type_of_payments
     * const type_of_payments = await prisma.type_of_payment.findMany()
     * 
     * // Get first 10 Type_of_payments
     * const type_of_payments = await prisma.type_of_payment.findMany({ take: 10 })
     * 
     * // Only select the `type_of_payment_id`
     * const type_of_paymentWithType_of_payment_idOnly = await prisma.type_of_payment.findMany({ select: { type_of_payment_id: true } })
     * 
     */
    findMany<T extends type_of_paymentFindManyArgs>(args?: SelectSubset<T, type_of_paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$type_of_paymentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Type_of_payment.
     * @param {type_of_paymentCreateArgs} args - Arguments to create a Type_of_payment.
     * @example
     * // Create one Type_of_payment
     * const Type_of_payment = await prisma.type_of_payment.create({
     *   data: {
     *     // ... data to create a Type_of_payment
     *   }
     * })
     * 
     */
    create<T extends type_of_paymentCreateArgs>(args: SelectSubset<T, type_of_paymentCreateArgs<ExtArgs>>): Prisma__type_of_paymentClient<$Result.GetResult<Prisma.$type_of_paymentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Type_of_payments.
     * @param {type_of_paymentCreateManyArgs} args - Arguments to create many Type_of_payments.
     * @example
     * // Create many Type_of_payments
     * const type_of_payment = await prisma.type_of_payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends type_of_paymentCreateManyArgs>(args?: SelectSubset<T, type_of_paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Type_of_payments and returns the data saved in the database.
     * @param {type_of_paymentCreateManyAndReturnArgs} args - Arguments to create many Type_of_payments.
     * @example
     * // Create many Type_of_payments
     * const type_of_payment = await prisma.type_of_payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Type_of_payments and only return the `type_of_payment_id`
     * const type_of_paymentWithType_of_payment_idOnly = await prisma.type_of_payment.createManyAndReturn({
     *   select: { type_of_payment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends type_of_paymentCreateManyAndReturnArgs>(args?: SelectSubset<T, type_of_paymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$type_of_paymentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Type_of_payment.
     * @param {type_of_paymentDeleteArgs} args - Arguments to delete one Type_of_payment.
     * @example
     * // Delete one Type_of_payment
     * const Type_of_payment = await prisma.type_of_payment.delete({
     *   where: {
     *     // ... filter to delete one Type_of_payment
     *   }
     * })
     * 
     */
    delete<T extends type_of_paymentDeleteArgs>(args: SelectSubset<T, type_of_paymentDeleteArgs<ExtArgs>>): Prisma__type_of_paymentClient<$Result.GetResult<Prisma.$type_of_paymentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Type_of_payment.
     * @param {type_of_paymentUpdateArgs} args - Arguments to update one Type_of_payment.
     * @example
     * // Update one Type_of_payment
     * const type_of_payment = await prisma.type_of_payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends type_of_paymentUpdateArgs>(args: SelectSubset<T, type_of_paymentUpdateArgs<ExtArgs>>): Prisma__type_of_paymentClient<$Result.GetResult<Prisma.$type_of_paymentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Type_of_payments.
     * @param {type_of_paymentDeleteManyArgs} args - Arguments to filter Type_of_payments to delete.
     * @example
     * // Delete a few Type_of_payments
     * const { count } = await prisma.type_of_payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends type_of_paymentDeleteManyArgs>(args?: SelectSubset<T, type_of_paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Type_of_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Type_of_payments
     * const type_of_payment = await prisma.type_of_payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends type_of_paymentUpdateManyArgs>(args: SelectSubset<T, type_of_paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Type_of_payments and returns the data updated in the database.
     * @param {type_of_paymentUpdateManyAndReturnArgs} args - Arguments to update many Type_of_payments.
     * @example
     * // Update many Type_of_payments
     * const type_of_payment = await prisma.type_of_payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Type_of_payments and only return the `type_of_payment_id`
     * const type_of_paymentWithType_of_payment_idOnly = await prisma.type_of_payment.updateManyAndReturn({
     *   select: { type_of_payment_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends type_of_paymentUpdateManyAndReturnArgs>(args: SelectSubset<T, type_of_paymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$type_of_paymentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Type_of_payment.
     * @param {type_of_paymentUpsertArgs} args - Arguments to update or create a Type_of_payment.
     * @example
     * // Update or create a Type_of_payment
     * const type_of_payment = await prisma.type_of_payment.upsert({
     *   create: {
     *     // ... data to create a Type_of_payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Type_of_payment we want to update
     *   }
     * })
     */
    upsert<T extends type_of_paymentUpsertArgs>(args: SelectSubset<T, type_of_paymentUpsertArgs<ExtArgs>>): Prisma__type_of_paymentClient<$Result.GetResult<Prisma.$type_of_paymentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Type_of_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_paymentCountArgs} args - Arguments to filter Type_of_payments to count.
     * @example
     * // Count the number of Type_of_payments
     * const count = await prisma.type_of_payment.count({
     *   where: {
     *     // ... the filter for the Type_of_payments we want to count
     *   }
     * })
    **/
    count<T extends type_of_paymentCountArgs>(
      args?: Subset<T, type_of_paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Type_of_paymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Type_of_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Type_of_paymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Type_of_paymentAggregateArgs>(args: Subset<T, Type_of_paymentAggregateArgs>): Prisma.PrismaPromise<GetType_of_paymentAggregateType<T>>

    /**
     * Group by Type_of_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends type_of_paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: type_of_paymentGroupByArgs['orderBy'] }
        : { orderBy?: type_of_paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, type_of_paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetType_of_paymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the type_of_payment model
   */
  readonly fields: type_of_paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for type_of_payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__type_of_paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the type_of_payment model
   */ 
  interface type_of_paymentFieldRefs {
    readonly type_of_payment_id: FieldRef<"type_of_payment", 'BigInt'>
    readonly type_of_payment: FieldRef<"type_of_payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * type_of_payment findUnique
   */
  export type type_of_paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_payment
     */
    select?: type_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_payment
     */
    omit?: type_of_paymentOmit<ExtArgs> | null
    /**
     * Filter, which type_of_payment to fetch.
     */
    where: type_of_paymentWhereUniqueInput
  }

  /**
   * type_of_payment findUniqueOrThrow
   */
  export type type_of_paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_payment
     */
    select?: type_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_payment
     */
    omit?: type_of_paymentOmit<ExtArgs> | null
    /**
     * Filter, which type_of_payment to fetch.
     */
    where: type_of_paymentWhereUniqueInput
  }

  /**
   * type_of_payment findFirst
   */
  export type type_of_paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_payment
     */
    select?: type_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_payment
     */
    omit?: type_of_paymentOmit<ExtArgs> | null
    /**
     * Filter, which type_of_payment to fetch.
     */
    where?: type_of_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_of_payments to fetch.
     */
    orderBy?: type_of_paymentOrderByWithRelationInput | type_of_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for type_of_payments.
     */
    cursor?: type_of_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_of_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_of_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of type_of_payments.
     */
    distinct?: Type_of_paymentScalarFieldEnum | Type_of_paymentScalarFieldEnum[]
  }

  /**
   * type_of_payment findFirstOrThrow
   */
  export type type_of_paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_payment
     */
    select?: type_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_payment
     */
    omit?: type_of_paymentOmit<ExtArgs> | null
    /**
     * Filter, which type_of_payment to fetch.
     */
    where?: type_of_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_of_payments to fetch.
     */
    orderBy?: type_of_paymentOrderByWithRelationInput | type_of_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for type_of_payments.
     */
    cursor?: type_of_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_of_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_of_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of type_of_payments.
     */
    distinct?: Type_of_paymentScalarFieldEnum | Type_of_paymentScalarFieldEnum[]
  }

  /**
   * type_of_payment findMany
   */
  export type type_of_paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_payment
     */
    select?: type_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_payment
     */
    omit?: type_of_paymentOmit<ExtArgs> | null
    /**
     * Filter, which type_of_payments to fetch.
     */
    where?: type_of_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_of_payments to fetch.
     */
    orderBy?: type_of_paymentOrderByWithRelationInput | type_of_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing type_of_payments.
     */
    cursor?: type_of_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_of_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_of_payments.
     */
    skip?: number
    distinct?: Type_of_paymentScalarFieldEnum | Type_of_paymentScalarFieldEnum[]
  }

  /**
   * type_of_payment create
   */
  export type type_of_paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_payment
     */
    select?: type_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_payment
     */
    omit?: type_of_paymentOmit<ExtArgs> | null
    /**
     * The data needed to create a type_of_payment.
     */
    data?: XOR<type_of_paymentCreateInput, type_of_paymentUncheckedCreateInput>
  }

  /**
   * type_of_payment createMany
   */
  export type type_of_paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many type_of_payments.
     */
    data: type_of_paymentCreateManyInput | type_of_paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * type_of_payment createManyAndReturn
   */
  export type type_of_paymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_payment
     */
    select?: type_of_paymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_payment
     */
    omit?: type_of_paymentOmit<ExtArgs> | null
    /**
     * The data used to create many type_of_payments.
     */
    data: type_of_paymentCreateManyInput | type_of_paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * type_of_payment update
   */
  export type type_of_paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_payment
     */
    select?: type_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_payment
     */
    omit?: type_of_paymentOmit<ExtArgs> | null
    /**
     * The data needed to update a type_of_payment.
     */
    data: XOR<type_of_paymentUpdateInput, type_of_paymentUncheckedUpdateInput>
    /**
     * Choose, which type_of_payment to update.
     */
    where: type_of_paymentWhereUniqueInput
  }

  /**
   * type_of_payment updateMany
   */
  export type type_of_paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update type_of_payments.
     */
    data: XOR<type_of_paymentUpdateManyMutationInput, type_of_paymentUncheckedUpdateManyInput>
    /**
     * Filter which type_of_payments to update
     */
    where?: type_of_paymentWhereInput
    /**
     * Limit how many type_of_payments to update.
     */
    limit?: number
  }

  /**
   * type_of_payment updateManyAndReturn
   */
  export type type_of_paymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_payment
     */
    select?: type_of_paymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_payment
     */
    omit?: type_of_paymentOmit<ExtArgs> | null
    /**
     * The data used to update type_of_payments.
     */
    data: XOR<type_of_paymentUpdateManyMutationInput, type_of_paymentUncheckedUpdateManyInput>
    /**
     * Filter which type_of_payments to update
     */
    where?: type_of_paymentWhereInput
    /**
     * Limit how many type_of_payments to update.
     */
    limit?: number
  }

  /**
   * type_of_payment upsert
   */
  export type type_of_paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_payment
     */
    select?: type_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_payment
     */
    omit?: type_of_paymentOmit<ExtArgs> | null
    /**
     * The filter to search for the type_of_payment to update in case it exists.
     */
    where: type_of_paymentWhereUniqueInput
    /**
     * In case the type_of_payment found by the `where` argument doesn't exist, create a new type_of_payment with this data.
     */
    create: XOR<type_of_paymentCreateInput, type_of_paymentUncheckedCreateInput>
    /**
     * In case the type_of_payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<type_of_paymentUpdateInput, type_of_paymentUncheckedUpdateInput>
  }

  /**
   * type_of_payment delete
   */
  export type type_of_paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_payment
     */
    select?: type_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_payment
     */
    omit?: type_of_paymentOmit<ExtArgs> | null
    /**
     * Filter which type_of_payment to delete.
     */
    where: type_of_paymentWhereUniqueInput
  }

  /**
   * type_of_payment deleteMany
   */
  export type type_of_paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which type_of_payments to delete
     */
    where?: type_of_paymentWhereInput
    /**
     * Limit how many type_of_payments to delete.
     */
    limit?: number
  }

  /**
   * type_of_payment without action
   */
  export type type_of_paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the type_of_payment
     */
    select?: type_of_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the type_of_payment
     */
    omit?: type_of_paymentOmit<ExtArgs> | null
  }


  /**
   * Model user_contacts
   */

  export type AggregateUser_contacts = {
    _count: User_contactsCountAggregateOutputType | null
    _avg: User_contactsAvgAggregateOutputType | null
    _sum: User_contactsSumAggregateOutputType | null
    _min: User_contactsMinAggregateOutputType | null
    _max: User_contactsMaxAggregateOutputType | null
  }

  export type User_contactsAvgAggregateOutputType = {
    user_contact_id: number | null
    user_id: number | null
  }

  export type User_contactsSumAggregateOutputType = {
    user_contact_id: bigint | null
    user_id: bigint | null
  }

  export type User_contactsMinAggregateOutputType = {
    user_contact_id: bigint | null
    user_id: bigint | null
    user_email: string | null
    user_contact_number: string | null
  }

  export type User_contactsMaxAggregateOutputType = {
    user_contact_id: bigint | null
    user_id: bigint | null
    user_email: string | null
    user_contact_number: string | null
  }

  export type User_contactsCountAggregateOutputType = {
    user_contact_id: number
    user_id: number
    user_email: number
    user_contact_number: number
    _all: number
  }


  export type User_contactsAvgAggregateInputType = {
    user_contact_id?: true
    user_id?: true
  }

  export type User_contactsSumAggregateInputType = {
    user_contact_id?: true
    user_id?: true
  }

  export type User_contactsMinAggregateInputType = {
    user_contact_id?: true
    user_id?: true
    user_email?: true
    user_contact_number?: true
  }

  export type User_contactsMaxAggregateInputType = {
    user_contact_id?: true
    user_id?: true
    user_email?: true
    user_contact_number?: true
  }

  export type User_contactsCountAggregateInputType = {
    user_contact_id?: true
    user_id?: true
    user_email?: true
    user_contact_number?: true
    _all?: true
  }

  export type User_contactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_contacts to aggregate.
     */
    where?: user_contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_contacts to fetch.
     */
    orderBy?: user_contactsOrderByWithRelationInput | user_contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_contacts
    **/
    _count?: true | User_contactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_contactsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_contactsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_contactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_contactsMaxAggregateInputType
  }

  export type GetUser_contactsAggregateType<T extends User_contactsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_contacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_contacts[P]>
      : GetScalarType<T[P], AggregateUser_contacts[P]>
  }




  export type user_contactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_contactsWhereInput
    orderBy?: user_contactsOrderByWithAggregationInput | user_contactsOrderByWithAggregationInput[]
    by: User_contactsScalarFieldEnum[] | User_contactsScalarFieldEnum
    having?: user_contactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_contactsCountAggregateInputType | true
    _avg?: User_contactsAvgAggregateInputType
    _sum?: User_contactsSumAggregateInputType
    _min?: User_contactsMinAggregateInputType
    _max?: User_contactsMaxAggregateInputType
  }

  export type User_contactsGroupByOutputType = {
    user_contact_id: bigint
    user_id: bigint
    user_email: string | null
    user_contact_number: string | null
    _count: User_contactsCountAggregateOutputType | null
    _avg: User_contactsAvgAggregateOutputType | null
    _sum: User_contactsSumAggregateOutputType | null
    _min: User_contactsMinAggregateOutputType | null
    _max: User_contactsMaxAggregateOutputType | null
  }

  type GetUser_contactsGroupByPayload<T extends user_contactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_contactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_contactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_contactsGroupByOutputType[P]>
            : GetScalarType<T[P], User_contactsGroupByOutputType[P]>
        }
      >
    >


  export type user_contactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_contact_id?: boolean
    user_id?: boolean
    user_email?: boolean
    user_contact_number?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_contacts"]>

  export type user_contactsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_contact_id?: boolean
    user_id?: boolean
    user_email?: boolean
    user_contact_number?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_contacts"]>

  export type user_contactsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_contact_id?: boolean
    user_id?: boolean
    user_email?: boolean
    user_contact_number?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_contacts"]>

  export type user_contactsSelectScalar = {
    user_contact_id?: boolean
    user_id?: boolean
    user_email?: boolean
    user_contact_number?: boolean
  }

  export type user_contactsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_contact_id" | "user_id" | "user_email" | "user_contact_number", ExtArgs["result"]["user_contacts"]>
  export type user_contactsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_contactsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_contactsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_contactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_contacts"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_contact_id: bigint
      user_id: bigint
      user_email: string | null
      user_contact_number: string | null
    }, ExtArgs["result"]["user_contacts"]>
    composites: {}
  }

  type user_contactsGetPayload<S extends boolean | null | undefined | user_contactsDefaultArgs> = $Result.GetResult<Prisma.$user_contactsPayload, S>

  type user_contactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_contactsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_contactsCountAggregateInputType | true
    }

  export interface user_contactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_contacts'], meta: { name: 'user_contacts' } }
    /**
     * Find zero or one User_contacts that matches the filter.
     * @param {user_contactsFindUniqueArgs} args - Arguments to find a User_contacts
     * @example
     * // Get one User_contacts
     * const user_contacts = await prisma.user_contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_contactsFindUniqueArgs>(args: SelectSubset<T, user_contactsFindUniqueArgs<ExtArgs>>): Prisma__user_contactsClient<$Result.GetResult<Prisma.$user_contactsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User_contacts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_contactsFindUniqueOrThrowArgs} args - Arguments to find a User_contacts
     * @example
     * // Get one User_contacts
     * const user_contacts = await prisma.user_contacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_contactsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_contactsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_contactsClient<$Result.GetResult<Prisma.$user_contactsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User_contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_contactsFindFirstArgs} args - Arguments to find a User_contacts
     * @example
     * // Get one User_contacts
     * const user_contacts = await prisma.user_contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_contactsFindFirstArgs>(args?: SelectSubset<T, user_contactsFindFirstArgs<ExtArgs>>): Prisma__user_contactsClient<$Result.GetResult<Prisma.$user_contactsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User_contacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_contactsFindFirstOrThrowArgs} args - Arguments to find a User_contacts
     * @example
     * // Get one User_contacts
     * const user_contacts = await prisma.user_contacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_contactsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_contactsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_contactsClient<$Result.GetResult<Prisma.$user_contactsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more User_contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_contactsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_contacts
     * const user_contacts = await prisma.user_contacts.findMany()
     * 
     * // Get first 10 User_contacts
     * const user_contacts = await prisma.user_contacts.findMany({ take: 10 })
     * 
     * // Only select the `user_contact_id`
     * const user_contactsWithUser_contact_idOnly = await prisma.user_contacts.findMany({ select: { user_contact_id: true } })
     * 
     */
    findMany<T extends user_contactsFindManyArgs>(args?: SelectSubset<T, user_contactsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_contactsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User_contacts.
     * @param {user_contactsCreateArgs} args - Arguments to create a User_contacts.
     * @example
     * // Create one User_contacts
     * const User_contacts = await prisma.user_contacts.create({
     *   data: {
     *     // ... data to create a User_contacts
     *   }
     * })
     * 
     */
    create<T extends user_contactsCreateArgs>(args: SelectSubset<T, user_contactsCreateArgs<ExtArgs>>): Prisma__user_contactsClient<$Result.GetResult<Prisma.$user_contactsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many User_contacts.
     * @param {user_contactsCreateManyArgs} args - Arguments to create many User_contacts.
     * @example
     * // Create many User_contacts
     * const user_contacts = await prisma.user_contacts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_contactsCreateManyArgs>(args?: SelectSubset<T, user_contactsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_contacts and returns the data saved in the database.
     * @param {user_contactsCreateManyAndReturnArgs} args - Arguments to create many User_contacts.
     * @example
     * // Create many User_contacts
     * const user_contacts = await prisma.user_contacts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_contacts and only return the `user_contact_id`
     * const user_contactsWithUser_contact_idOnly = await prisma.user_contacts.createManyAndReturn({
     *   select: { user_contact_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_contactsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_contactsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_contactsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User_contacts.
     * @param {user_contactsDeleteArgs} args - Arguments to delete one User_contacts.
     * @example
     * // Delete one User_contacts
     * const User_contacts = await prisma.user_contacts.delete({
     *   where: {
     *     // ... filter to delete one User_contacts
     *   }
     * })
     * 
     */
    delete<T extends user_contactsDeleteArgs>(args: SelectSubset<T, user_contactsDeleteArgs<ExtArgs>>): Prisma__user_contactsClient<$Result.GetResult<Prisma.$user_contactsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User_contacts.
     * @param {user_contactsUpdateArgs} args - Arguments to update one User_contacts.
     * @example
     * // Update one User_contacts
     * const user_contacts = await prisma.user_contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_contactsUpdateArgs>(args: SelectSubset<T, user_contactsUpdateArgs<ExtArgs>>): Prisma__user_contactsClient<$Result.GetResult<Prisma.$user_contactsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more User_contacts.
     * @param {user_contactsDeleteManyArgs} args - Arguments to filter User_contacts to delete.
     * @example
     * // Delete a few User_contacts
     * const { count } = await prisma.user_contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_contactsDeleteManyArgs>(args?: SelectSubset<T, user_contactsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_contactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_contacts
     * const user_contacts = await prisma.user_contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_contactsUpdateManyArgs>(args: SelectSubset<T, user_contactsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_contacts and returns the data updated in the database.
     * @param {user_contactsUpdateManyAndReturnArgs} args - Arguments to update many User_contacts.
     * @example
     * // Update many User_contacts
     * const user_contacts = await prisma.user_contacts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_contacts and only return the `user_contact_id`
     * const user_contactsWithUser_contact_idOnly = await prisma.user_contacts.updateManyAndReturn({
     *   select: { user_contact_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_contactsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_contactsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_contactsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User_contacts.
     * @param {user_contactsUpsertArgs} args - Arguments to update or create a User_contacts.
     * @example
     * // Update or create a User_contacts
     * const user_contacts = await prisma.user_contacts.upsert({
     *   create: {
     *     // ... data to create a User_contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_contacts we want to update
     *   }
     * })
     */
    upsert<T extends user_contactsUpsertArgs>(args: SelectSubset<T, user_contactsUpsertArgs<ExtArgs>>): Prisma__user_contactsClient<$Result.GetResult<Prisma.$user_contactsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of User_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_contactsCountArgs} args - Arguments to filter User_contacts to count.
     * @example
     * // Count the number of User_contacts
     * const count = await prisma.user_contacts.count({
     *   where: {
     *     // ... the filter for the User_contacts we want to count
     *   }
     * })
    **/
    count<T extends user_contactsCountArgs>(
      args?: Subset<T, user_contactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_contactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_contactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_contactsAggregateArgs>(args: Subset<T, User_contactsAggregateArgs>): Prisma.PrismaPromise<GetUser_contactsAggregateType<T>>

    /**
     * Group by User_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_contactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_contactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_contactsGroupByArgs['orderBy'] }
        : { orderBy?: user_contactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_contactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_contactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_contacts model
   */
  readonly fields: user_contactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_contactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_contacts model
   */ 
  interface user_contactsFieldRefs {
    readonly user_contact_id: FieldRef<"user_contacts", 'BigInt'>
    readonly user_id: FieldRef<"user_contacts", 'BigInt'>
    readonly user_email: FieldRef<"user_contacts", 'String'>
    readonly user_contact_number: FieldRef<"user_contacts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user_contacts findUnique
   */
  export type user_contactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_contacts
     */
    select?: user_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_contacts
     */
    omit?: user_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_contactsInclude<ExtArgs> | null
    /**
     * Filter, which user_contacts to fetch.
     */
    where: user_contactsWhereUniqueInput
  }

  /**
   * user_contacts findUniqueOrThrow
   */
  export type user_contactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_contacts
     */
    select?: user_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_contacts
     */
    omit?: user_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_contactsInclude<ExtArgs> | null
    /**
     * Filter, which user_contacts to fetch.
     */
    where: user_contactsWhereUniqueInput
  }

  /**
   * user_contacts findFirst
   */
  export type user_contactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_contacts
     */
    select?: user_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_contacts
     */
    omit?: user_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_contactsInclude<ExtArgs> | null
    /**
     * Filter, which user_contacts to fetch.
     */
    where?: user_contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_contacts to fetch.
     */
    orderBy?: user_contactsOrderByWithRelationInput | user_contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_contacts.
     */
    cursor?: user_contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_contacts.
     */
    distinct?: User_contactsScalarFieldEnum | User_contactsScalarFieldEnum[]
  }

  /**
   * user_contacts findFirstOrThrow
   */
  export type user_contactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_contacts
     */
    select?: user_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_contacts
     */
    omit?: user_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_contactsInclude<ExtArgs> | null
    /**
     * Filter, which user_contacts to fetch.
     */
    where?: user_contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_contacts to fetch.
     */
    orderBy?: user_contactsOrderByWithRelationInput | user_contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_contacts.
     */
    cursor?: user_contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_contacts.
     */
    distinct?: User_contactsScalarFieldEnum | User_contactsScalarFieldEnum[]
  }

  /**
   * user_contacts findMany
   */
  export type user_contactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_contacts
     */
    select?: user_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_contacts
     */
    omit?: user_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_contactsInclude<ExtArgs> | null
    /**
     * Filter, which user_contacts to fetch.
     */
    where?: user_contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_contacts to fetch.
     */
    orderBy?: user_contactsOrderByWithRelationInput | user_contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_contacts.
     */
    cursor?: user_contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_contacts.
     */
    skip?: number
    distinct?: User_contactsScalarFieldEnum | User_contactsScalarFieldEnum[]
  }

  /**
   * user_contacts create
   */
  export type user_contactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_contacts
     */
    select?: user_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_contacts
     */
    omit?: user_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_contactsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_contacts.
     */
    data: XOR<user_contactsCreateInput, user_contactsUncheckedCreateInput>
  }

  /**
   * user_contacts createMany
   */
  export type user_contactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_contacts.
     */
    data: user_contactsCreateManyInput | user_contactsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_contacts createManyAndReturn
   */
  export type user_contactsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_contacts
     */
    select?: user_contactsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_contacts
     */
    omit?: user_contactsOmit<ExtArgs> | null
    /**
     * The data used to create many user_contacts.
     */
    data: user_contactsCreateManyInput | user_contactsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_contactsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_contacts update
   */
  export type user_contactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_contacts
     */
    select?: user_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_contacts
     */
    omit?: user_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_contactsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_contacts.
     */
    data: XOR<user_contactsUpdateInput, user_contactsUncheckedUpdateInput>
    /**
     * Choose, which user_contacts to update.
     */
    where: user_contactsWhereUniqueInput
  }

  /**
   * user_contacts updateMany
   */
  export type user_contactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_contacts.
     */
    data: XOR<user_contactsUpdateManyMutationInput, user_contactsUncheckedUpdateManyInput>
    /**
     * Filter which user_contacts to update
     */
    where?: user_contactsWhereInput
    /**
     * Limit how many user_contacts to update.
     */
    limit?: number
  }

  /**
   * user_contacts updateManyAndReturn
   */
  export type user_contactsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_contacts
     */
    select?: user_contactsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_contacts
     */
    omit?: user_contactsOmit<ExtArgs> | null
    /**
     * The data used to update user_contacts.
     */
    data: XOR<user_contactsUpdateManyMutationInput, user_contactsUncheckedUpdateManyInput>
    /**
     * Filter which user_contacts to update
     */
    where?: user_contactsWhereInput
    /**
     * Limit how many user_contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_contactsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_contacts upsert
   */
  export type user_contactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_contacts
     */
    select?: user_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_contacts
     */
    omit?: user_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_contactsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_contacts to update in case it exists.
     */
    where: user_contactsWhereUniqueInput
    /**
     * In case the user_contacts found by the `where` argument doesn't exist, create a new user_contacts with this data.
     */
    create: XOR<user_contactsCreateInput, user_contactsUncheckedCreateInput>
    /**
     * In case the user_contacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_contactsUpdateInput, user_contactsUncheckedUpdateInput>
  }

  /**
   * user_contacts delete
   */
  export type user_contactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_contacts
     */
    select?: user_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_contacts
     */
    omit?: user_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_contactsInclude<ExtArgs> | null
    /**
     * Filter which user_contacts to delete.
     */
    where: user_contactsWhereUniqueInput
  }

  /**
   * user_contacts deleteMany
   */
  export type user_contactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_contacts to delete
     */
    where?: user_contactsWhereInput
    /**
     * Limit how many user_contacts to delete.
     */
    limit?: number
  }

  /**
   * user_contacts without action
   */
  export type user_contactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_contacts
     */
    select?: user_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_contacts
     */
    omit?: user_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_contactsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    user_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    user_id: bigint | null
  }

  export type UsersMinAggregateOutputType = {
    user_id: bigint | null
    user_full_name: string | null
    user_password: string | null
    username: string | null
  }

  export type UsersMaxAggregateOutputType = {
    user_id: bigint | null
    user_full_name: string | null
    user_password: string | null
    username: string | null
  }

  export type UsersCountAggregateOutputType = {
    user_id: number
    user_full_name: number
    user_password: number
    username: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    user_id?: true
  }

  export type UsersSumAggregateInputType = {
    user_id?: true
  }

  export type UsersMinAggregateInputType = {
    user_id?: true
    user_full_name?: true
    user_password?: true
    username?: true
  }

  export type UsersMaxAggregateInputType = {
    user_id?: true
    user_full_name?: true
    user_password?: true
    username?: true
  }

  export type UsersCountAggregateInputType = {
    user_id?: true
    user_full_name?: true
    user_password?: true
    username?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    user_id: bigint
    user_full_name: string | null
    user_password: string | null
    username: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    user_full_name?: boolean
    user_password?: boolean
    username?: boolean
    appointments?: boolean | users$appointmentsArgs<ExtArgs>
    patients?: boolean | users$patientsArgs<ExtArgs>
    user_contacts?: boolean | users$user_contactsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    user_full_name?: boolean
    user_password?: boolean
    username?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    user_full_name?: boolean
    user_password?: boolean
    username?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    user_id?: boolean
    user_full_name?: boolean
    user_password?: boolean
    username?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "user_full_name" | "user_password" | "username", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | users$appointmentsArgs<ExtArgs>
    patients?: boolean | users$patientsArgs<ExtArgs>
    user_contacts?: boolean | users$user_contactsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs>[]
      patients: Prisma.$patientsPayload<ExtArgs>[]
      user_contacts: Prisma.$user_contactsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: bigint
      user_full_name: string | null
      user_password: string | null
      username: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const usersWithUser_idOnly = await prisma.users.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `user_id`
     * const usersWithUser_idOnly = await prisma.users.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `user_id`
     * const usersWithUser_idOnly = await prisma.users.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends users$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, users$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    patients<T extends users$patientsArgs<ExtArgs> = {}>(args?: Subset<T, users$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    user_contacts<T extends users$user_contactsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_contactsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly user_id: FieldRef<"users", 'BigInt'>
    readonly user_full_name: FieldRef<"users", 'String'>
    readonly user_password: FieldRef<"users", 'String'>
    readonly username: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data?: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.appointments
   */
  export type users$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    cursor?: appointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * users.patients
   */
  export type users$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    where?: patientsWhereInput
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    cursor?: patientsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * users.user_contacts
   */
  export type users$user_contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_contacts
     */
    select?: user_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_contacts
     */
    omit?: user_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_contactsInclude<ExtArgs> | null
    where?: user_contactsWhereInput
    orderBy?: user_contactsOrderByWithRelationInput | user_contactsOrderByWithRelationInput[]
    cursor?: user_contactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_contactsScalarFieldEnum | User_contactsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Appointment_statusScalarFieldEnum: {
    appointment_status_id: 'appointment_status_id',
    appointment_status: 'appointment_status'
  };

  export type Appointment_statusScalarFieldEnum = (typeof Appointment_statusScalarFieldEnum)[keyof typeof Appointment_statusScalarFieldEnum]


  export const AppointmentsScalarFieldEnum: {
    appoint_id: 'appoint_id',
    preferred_time: 'preferred_time',
    preferred_date: 'preferred_date',
    staff_id: 'staff_id',
    appointment_status_id: 'appointment_status_id',
    final_date: 'final_date',
    final_time: 'final_time',
    user_id: 'user_id'
  };

  export type AppointmentsScalarFieldEnum = (typeof AppointmentsScalarFieldEnum)[keyof typeof AppointmentsScalarFieldEnum]


  export const Clinic_staffScalarFieldEnum: {
    staff_id: 'staff_id',
    staff_name: 'staff_name',
    staff_birthdate: 'staff_birthdate'
  };

  export type Clinic_staffScalarFieldEnum = (typeof Clinic_staffScalarFieldEnum)[keyof typeof Clinic_staffScalarFieldEnum]


  export const Clinic_staff_detailsScalarFieldEnum: {
    clinic_staff_contact_id: 'clinic_staff_contact_id',
    staff_id: 'staff_id',
    staff_contact: 'staff_contact',
    staff_address: 'staff_address'
  };

  export type Clinic_staff_detailsScalarFieldEnum = (typeof Clinic_staff_detailsScalarFieldEnum)[keyof typeof Clinic_staff_detailsScalarFieldEnum]


  export const GuardianScalarFieldEnum: {
    guardian_id: 'guardian_id',
    patient_details_id: 'patient_details_id',
    guardian_name: 'guardian_name',
    guardian_contact: 'guardian_contact'
  };

  export type GuardianScalarFieldEnum = (typeof GuardianScalarFieldEnum)[keyof typeof GuardianScalarFieldEnum]


  export const Mode_of_paymentScalarFieldEnum: {
    mode_of_payment_id: 'mode_of_payment_id',
    mode_of_payment: 'mode_of_payment'
  };

  export type Mode_of_paymentScalarFieldEnum = (typeof Mode_of_paymentScalarFieldEnum)[keyof typeof Mode_of_paymentScalarFieldEnum]


  export const Patient_appointmentsScalarFieldEnum: {
    patient_appointments_id: 'patient_appointments_id',
    patient_id: 'patient_id',
    appoint_id: 'appoint_id',
    booking_date: 'booking_date'
  };

  export type Patient_appointmentsScalarFieldEnum = (typeof Patient_appointmentsScalarFieldEnum)[keyof typeof Patient_appointmentsScalarFieldEnum]


  export const Patient_conditionsScalarFieldEnum: {
    patient_conditions_id: 'patient_conditions_id',
    condition_type: 'condition_type',
    condition_description: 'condition_description'
  };

  export type Patient_conditionsScalarFieldEnum = (typeof Patient_conditionsScalarFieldEnum)[keyof typeof Patient_conditionsScalarFieldEnum]


  export const Patient_detailsScalarFieldEnum: {
    patient_details_id: 'patient_details_id',
    patient_id: 'patient_id',
    patient_conditions_id: 'patient_conditions_id',
    patient_birth_date: 'patient_birth_date'
  };

  export type Patient_detailsScalarFieldEnum = (typeof Patient_detailsScalarFieldEnum)[keyof typeof Patient_detailsScalarFieldEnum]


  export const PatientsScalarFieldEnum: {
    patient_id: 'patient_id',
    patient_name: 'patient_name',
    user_id: 'user_id'
  };

  export type PatientsScalarFieldEnum = (typeof PatientsScalarFieldEnum)[keyof typeof PatientsScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    payment_id: 'payment_id',
    appoint_id: 'appoint_id',
    user_id: 'user_id',
    payment_status: 'payment_status'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const RecurrenceScalarFieldEnum: {
    recurrence_id: 'recurrence_id',
    recurrence_type: 'recurrence_type',
    interval: 'interval',
    start_date: 'start_date',
    end_date: 'end_date',
    occurence_count: 'occurence_count',
    time: 'time'
  };

  export type RecurrenceScalarFieldEnum = (typeof RecurrenceScalarFieldEnum)[keyof typeof RecurrenceScalarFieldEnum]


  export const Recurring_instancesScalarFieldEnum: {
    instance_id: 'instance_id',
    appoint_id: 'appoint_id',
    recurrence_id: 'recurrence_id',
    appoint_date: 'appoint_date',
    appoint_time: 'appoint_time',
    instance_status: 'instance_status'
  };

  export type Recurring_instancesScalarFieldEnum = (typeof Recurring_instancesScalarFieldEnum)[keyof typeof Recurring_instancesScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    session_id: 'session_id',
    patient_id: 'patient_id',
    staff_id: 'staff_id',
    appoint_id: 'appoint_id'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const Session_detailsScalarFieldEnum: {
    session_details_id: 'session_details_id',
    session_id: 'session_id',
    session_description: 'session_description',
    session_date: 'session_date',
    session_time: 'session_time',
    session_document: 'session_document'
  };

  export type Session_detailsScalarFieldEnum = (typeof Session_detailsScalarFieldEnum)[keyof typeof Session_detailsScalarFieldEnum]


  export const Staff_roleScalarFieldEnum: {
    staff_role_id: 'staff_role_id',
    staff_id: 'staff_id',
    staff_role: 'staff_role'
  };

  export type Staff_roleScalarFieldEnum = (typeof Staff_roleScalarFieldEnum)[keyof typeof Staff_roleScalarFieldEnum]


  export const Type_of_paymentScalarFieldEnum: {
    type_of_payment_id: 'type_of_payment_id',
    type_of_payment: 'type_of_payment'
  };

  export type Type_of_paymentScalarFieldEnum = (typeof Type_of_paymentScalarFieldEnum)[keyof typeof Type_of_paymentScalarFieldEnum]


  export const User_contactsScalarFieldEnum: {
    user_contact_id: 'user_contact_id',
    user_id: 'user_id',
    user_email: 'user_email',
    user_contact_number: 'user_contact_number'
  };

  export type User_contactsScalarFieldEnum = (typeof User_contactsScalarFieldEnum)[keyof typeof User_contactsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    user_id: 'user_id',
    user_full_name: 'user_full_name',
    user_password: 'user_password',
    username: 'username'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type appointment_statusWhereInput = {
    AND?: appointment_statusWhereInput | appointment_statusWhereInput[]
    OR?: appointment_statusWhereInput[]
    NOT?: appointment_statusWhereInput | appointment_statusWhereInput[]
    appointment_status_id?: BigIntFilter<"appointment_status"> | bigint | number
    appointment_status?: StringNullableFilter<"appointment_status"> | string | null
    appointments?: AppointmentsListRelationFilter
  }

  export type appointment_statusOrderByWithRelationInput = {
    appointment_status_id?: SortOrder
    appointment_status?: SortOrderInput | SortOrder
    appointments?: appointmentsOrderByRelationAggregateInput
  }

  export type appointment_statusWhereUniqueInput = Prisma.AtLeast<{
    appointment_status_id?: bigint | number
    AND?: appointment_statusWhereInput | appointment_statusWhereInput[]
    OR?: appointment_statusWhereInput[]
    NOT?: appointment_statusWhereInput | appointment_statusWhereInput[]
    appointment_status?: StringNullableFilter<"appointment_status"> | string | null
    appointments?: AppointmentsListRelationFilter
  }, "appointment_status_id">

  export type appointment_statusOrderByWithAggregationInput = {
    appointment_status_id?: SortOrder
    appointment_status?: SortOrderInput | SortOrder
    _count?: appointment_statusCountOrderByAggregateInput
    _avg?: appointment_statusAvgOrderByAggregateInput
    _max?: appointment_statusMaxOrderByAggregateInput
    _min?: appointment_statusMinOrderByAggregateInput
    _sum?: appointment_statusSumOrderByAggregateInput
  }

  export type appointment_statusScalarWhereWithAggregatesInput = {
    AND?: appointment_statusScalarWhereWithAggregatesInput | appointment_statusScalarWhereWithAggregatesInput[]
    OR?: appointment_statusScalarWhereWithAggregatesInput[]
    NOT?: appointment_statusScalarWhereWithAggregatesInput | appointment_statusScalarWhereWithAggregatesInput[]
    appointment_status_id?: BigIntWithAggregatesFilter<"appointment_status"> | bigint | number
    appointment_status?: StringNullableWithAggregatesFilter<"appointment_status"> | string | null
  }

  export type appointmentsWhereInput = {
    AND?: appointmentsWhereInput | appointmentsWhereInput[]
    OR?: appointmentsWhereInput[]
    NOT?: appointmentsWhereInput | appointmentsWhereInput[]
    appoint_id?: BigIntFilter<"appointments"> | bigint | number
    preferred_time?: DateTimeNullableFilter<"appointments"> | Date | string | null
    preferred_date?: DateTimeNullableFilter<"appointments"> | Date | string | null
    staff_id?: BigIntNullableFilter<"appointments"> | bigint | number | null
    appointment_status_id?: BigIntNullableFilter<"appointments"> | bigint | number | null
    final_date?: DateTimeNullableFilter<"appointments"> | Date | string | null
    final_time?: DateTimeNullableFilter<"appointments"> | Date | string | null
    user_id?: BigIntNullableFilter<"appointments"> | bigint | number | null
    appointment_status?: XOR<Appointment_statusNullableScalarRelationFilter, appointment_statusWhereInput> | null
    clinic_staff?: XOR<Clinic_staffNullableScalarRelationFilter, clinic_staffWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    patient_appointments?: Patient_appointmentsListRelationFilter
    recurring_instances?: Recurring_instancesListRelationFilter
    session?: SessionListRelationFilter
  }

  export type appointmentsOrderByWithRelationInput = {
    appoint_id?: SortOrder
    preferred_time?: SortOrderInput | SortOrder
    preferred_date?: SortOrderInput | SortOrder
    staff_id?: SortOrderInput | SortOrder
    appointment_status_id?: SortOrderInput | SortOrder
    final_date?: SortOrderInput | SortOrder
    final_time?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    appointment_status?: appointment_statusOrderByWithRelationInput
    clinic_staff?: clinic_staffOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    patient_appointments?: patient_appointmentsOrderByRelationAggregateInput
    recurring_instances?: recurring_instancesOrderByRelationAggregateInput
    session?: sessionOrderByRelationAggregateInput
  }

  export type appointmentsWhereUniqueInput = Prisma.AtLeast<{
    appoint_id?: bigint | number
    AND?: appointmentsWhereInput | appointmentsWhereInput[]
    OR?: appointmentsWhereInput[]
    NOT?: appointmentsWhereInput | appointmentsWhereInput[]
    preferred_time?: DateTimeNullableFilter<"appointments"> | Date | string | null
    preferred_date?: DateTimeNullableFilter<"appointments"> | Date | string | null
    staff_id?: BigIntNullableFilter<"appointments"> | bigint | number | null
    appointment_status_id?: BigIntNullableFilter<"appointments"> | bigint | number | null
    final_date?: DateTimeNullableFilter<"appointments"> | Date | string | null
    final_time?: DateTimeNullableFilter<"appointments"> | Date | string | null
    user_id?: BigIntNullableFilter<"appointments"> | bigint | number | null
    appointment_status?: XOR<Appointment_statusNullableScalarRelationFilter, appointment_statusWhereInput> | null
    clinic_staff?: XOR<Clinic_staffNullableScalarRelationFilter, clinic_staffWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    patient_appointments?: Patient_appointmentsListRelationFilter
    recurring_instances?: Recurring_instancesListRelationFilter
    session?: SessionListRelationFilter
  }, "appoint_id">

  export type appointmentsOrderByWithAggregationInput = {
    appoint_id?: SortOrder
    preferred_time?: SortOrderInput | SortOrder
    preferred_date?: SortOrderInput | SortOrder
    staff_id?: SortOrderInput | SortOrder
    appointment_status_id?: SortOrderInput | SortOrder
    final_date?: SortOrderInput | SortOrder
    final_time?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: appointmentsCountOrderByAggregateInput
    _avg?: appointmentsAvgOrderByAggregateInput
    _max?: appointmentsMaxOrderByAggregateInput
    _min?: appointmentsMinOrderByAggregateInput
    _sum?: appointmentsSumOrderByAggregateInput
  }

  export type appointmentsScalarWhereWithAggregatesInput = {
    AND?: appointmentsScalarWhereWithAggregatesInput | appointmentsScalarWhereWithAggregatesInput[]
    OR?: appointmentsScalarWhereWithAggregatesInput[]
    NOT?: appointmentsScalarWhereWithAggregatesInput | appointmentsScalarWhereWithAggregatesInput[]
    appoint_id?: BigIntWithAggregatesFilter<"appointments"> | bigint | number
    preferred_time?: DateTimeNullableWithAggregatesFilter<"appointments"> | Date | string | null
    preferred_date?: DateTimeNullableWithAggregatesFilter<"appointments"> | Date | string | null
    staff_id?: BigIntNullableWithAggregatesFilter<"appointments"> | bigint | number | null
    appointment_status_id?: BigIntNullableWithAggregatesFilter<"appointments"> | bigint | number | null
    final_date?: DateTimeNullableWithAggregatesFilter<"appointments"> | Date | string | null
    final_time?: DateTimeNullableWithAggregatesFilter<"appointments"> | Date | string | null
    user_id?: BigIntNullableWithAggregatesFilter<"appointments"> | bigint | number | null
  }

  export type clinic_staffWhereInput = {
    AND?: clinic_staffWhereInput | clinic_staffWhereInput[]
    OR?: clinic_staffWhereInput[]
    NOT?: clinic_staffWhereInput | clinic_staffWhereInput[]
    staff_id?: BigIntFilter<"clinic_staff"> | bigint | number
    staff_name?: StringNullableFilter<"clinic_staff"> | string | null
    staff_birthdate?: DateTimeNullableFilter<"clinic_staff"> | Date | string | null
    appointments?: AppointmentsListRelationFilter
    clinic_staff_details?: Clinic_staff_detailsListRelationFilter
    session?: SessionListRelationFilter
    staff_role?: Staff_roleListRelationFilter
  }

  export type clinic_staffOrderByWithRelationInput = {
    staff_id?: SortOrder
    staff_name?: SortOrderInput | SortOrder
    staff_birthdate?: SortOrderInput | SortOrder
    appointments?: appointmentsOrderByRelationAggregateInput
    clinic_staff_details?: clinic_staff_detailsOrderByRelationAggregateInput
    session?: sessionOrderByRelationAggregateInput
    staff_role?: staff_roleOrderByRelationAggregateInput
  }

  export type clinic_staffWhereUniqueInput = Prisma.AtLeast<{
    staff_id?: bigint | number
    AND?: clinic_staffWhereInput | clinic_staffWhereInput[]
    OR?: clinic_staffWhereInput[]
    NOT?: clinic_staffWhereInput | clinic_staffWhereInput[]
    staff_name?: StringNullableFilter<"clinic_staff"> | string | null
    staff_birthdate?: DateTimeNullableFilter<"clinic_staff"> | Date | string | null
    appointments?: AppointmentsListRelationFilter
    clinic_staff_details?: Clinic_staff_detailsListRelationFilter
    session?: SessionListRelationFilter
    staff_role?: Staff_roleListRelationFilter
  }, "staff_id">

  export type clinic_staffOrderByWithAggregationInput = {
    staff_id?: SortOrder
    staff_name?: SortOrderInput | SortOrder
    staff_birthdate?: SortOrderInput | SortOrder
    _count?: clinic_staffCountOrderByAggregateInput
    _avg?: clinic_staffAvgOrderByAggregateInput
    _max?: clinic_staffMaxOrderByAggregateInput
    _min?: clinic_staffMinOrderByAggregateInput
    _sum?: clinic_staffSumOrderByAggregateInput
  }

  export type clinic_staffScalarWhereWithAggregatesInput = {
    AND?: clinic_staffScalarWhereWithAggregatesInput | clinic_staffScalarWhereWithAggregatesInput[]
    OR?: clinic_staffScalarWhereWithAggregatesInput[]
    NOT?: clinic_staffScalarWhereWithAggregatesInput | clinic_staffScalarWhereWithAggregatesInput[]
    staff_id?: BigIntWithAggregatesFilter<"clinic_staff"> | bigint | number
    staff_name?: StringNullableWithAggregatesFilter<"clinic_staff"> | string | null
    staff_birthdate?: DateTimeNullableWithAggregatesFilter<"clinic_staff"> | Date | string | null
  }

  export type clinic_staff_detailsWhereInput = {
    AND?: clinic_staff_detailsWhereInput | clinic_staff_detailsWhereInput[]
    OR?: clinic_staff_detailsWhereInput[]
    NOT?: clinic_staff_detailsWhereInput | clinic_staff_detailsWhereInput[]
    clinic_staff_contact_id?: BigIntFilter<"clinic_staff_details"> | bigint | number
    staff_id?: BigIntFilter<"clinic_staff_details"> | bigint | number
    staff_contact?: StringNullableFilter<"clinic_staff_details"> | string | null
    staff_address?: StringNullableFilter<"clinic_staff_details"> | string | null
    clinic_staff?: XOR<Clinic_staffScalarRelationFilter, clinic_staffWhereInput>
  }

  export type clinic_staff_detailsOrderByWithRelationInput = {
    clinic_staff_contact_id?: SortOrder
    staff_id?: SortOrder
    staff_contact?: SortOrderInput | SortOrder
    staff_address?: SortOrderInput | SortOrder
    clinic_staff?: clinic_staffOrderByWithRelationInput
  }

  export type clinic_staff_detailsWhereUniqueInput = Prisma.AtLeast<{
    clinic_staff_contact_id?: bigint | number
    AND?: clinic_staff_detailsWhereInput | clinic_staff_detailsWhereInput[]
    OR?: clinic_staff_detailsWhereInput[]
    NOT?: clinic_staff_detailsWhereInput | clinic_staff_detailsWhereInput[]
    staff_id?: BigIntFilter<"clinic_staff_details"> | bigint | number
    staff_contact?: StringNullableFilter<"clinic_staff_details"> | string | null
    staff_address?: StringNullableFilter<"clinic_staff_details"> | string | null
    clinic_staff?: XOR<Clinic_staffScalarRelationFilter, clinic_staffWhereInput>
  }, "clinic_staff_contact_id">

  export type clinic_staff_detailsOrderByWithAggregationInput = {
    clinic_staff_contact_id?: SortOrder
    staff_id?: SortOrder
    staff_contact?: SortOrderInput | SortOrder
    staff_address?: SortOrderInput | SortOrder
    _count?: clinic_staff_detailsCountOrderByAggregateInput
    _avg?: clinic_staff_detailsAvgOrderByAggregateInput
    _max?: clinic_staff_detailsMaxOrderByAggregateInput
    _min?: clinic_staff_detailsMinOrderByAggregateInput
    _sum?: clinic_staff_detailsSumOrderByAggregateInput
  }

  export type clinic_staff_detailsScalarWhereWithAggregatesInput = {
    AND?: clinic_staff_detailsScalarWhereWithAggregatesInput | clinic_staff_detailsScalarWhereWithAggregatesInput[]
    OR?: clinic_staff_detailsScalarWhereWithAggregatesInput[]
    NOT?: clinic_staff_detailsScalarWhereWithAggregatesInput | clinic_staff_detailsScalarWhereWithAggregatesInput[]
    clinic_staff_contact_id?: BigIntWithAggregatesFilter<"clinic_staff_details"> | bigint | number
    staff_id?: BigIntWithAggregatesFilter<"clinic_staff_details"> | bigint | number
    staff_contact?: StringNullableWithAggregatesFilter<"clinic_staff_details"> | string | null
    staff_address?: StringNullableWithAggregatesFilter<"clinic_staff_details"> | string | null
  }

  export type guardianWhereInput = {
    AND?: guardianWhereInput | guardianWhereInput[]
    OR?: guardianWhereInput[]
    NOT?: guardianWhereInput | guardianWhereInput[]
    guardian_id?: BigIntFilter<"guardian"> | bigint | number
    patient_details_id?: BigIntFilter<"guardian"> | bigint | number
    guardian_name?: StringNullableFilter<"guardian"> | string | null
    guardian_contact?: StringNullableFilter<"guardian"> | string | null
  }

  export type guardianOrderByWithRelationInput = {
    guardian_id?: SortOrder
    patient_details_id?: SortOrder
    guardian_name?: SortOrderInput | SortOrder
    guardian_contact?: SortOrderInput | SortOrder
  }

  export type guardianWhereUniqueInput = Prisma.AtLeast<{
    guardian_id?: bigint | number
    AND?: guardianWhereInput | guardianWhereInput[]
    OR?: guardianWhereInput[]
    NOT?: guardianWhereInput | guardianWhereInput[]
    patient_details_id?: BigIntFilter<"guardian"> | bigint | number
    guardian_name?: StringNullableFilter<"guardian"> | string | null
    guardian_contact?: StringNullableFilter<"guardian"> | string | null
  }, "guardian_id">

  export type guardianOrderByWithAggregationInput = {
    guardian_id?: SortOrder
    patient_details_id?: SortOrder
    guardian_name?: SortOrderInput | SortOrder
    guardian_contact?: SortOrderInput | SortOrder
    _count?: guardianCountOrderByAggregateInput
    _avg?: guardianAvgOrderByAggregateInput
    _max?: guardianMaxOrderByAggregateInput
    _min?: guardianMinOrderByAggregateInput
    _sum?: guardianSumOrderByAggregateInput
  }

  export type guardianScalarWhereWithAggregatesInput = {
    AND?: guardianScalarWhereWithAggregatesInput | guardianScalarWhereWithAggregatesInput[]
    OR?: guardianScalarWhereWithAggregatesInput[]
    NOT?: guardianScalarWhereWithAggregatesInput | guardianScalarWhereWithAggregatesInput[]
    guardian_id?: BigIntWithAggregatesFilter<"guardian"> | bigint | number
    patient_details_id?: BigIntWithAggregatesFilter<"guardian"> | bigint | number
    guardian_name?: StringNullableWithAggregatesFilter<"guardian"> | string | null
    guardian_contact?: StringNullableWithAggregatesFilter<"guardian"> | string | null
  }

  export type mode_of_paymentWhereInput = {
    AND?: mode_of_paymentWhereInput | mode_of_paymentWhereInput[]
    OR?: mode_of_paymentWhereInput[]
    NOT?: mode_of_paymentWhereInput | mode_of_paymentWhereInput[]
    mode_of_payment_id?: BigIntFilter<"mode_of_payment"> | bigint | number
    mode_of_payment?: StringNullableFilter<"mode_of_payment"> | string | null
  }

  export type mode_of_paymentOrderByWithRelationInput = {
    mode_of_payment_id?: SortOrder
    mode_of_payment?: SortOrderInput | SortOrder
  }

  export type mode_of_paymentWhereUniqueInput = Prisma.AtLeast<{
    mode_of_payment_id?: bigint | number
    AND?: mode_of_paymentWhereInput | mode_of_paymentWhereInput[]
    OR?: mode_of_paymentWhereInput[]
    NOT?: mode_of_paymentWhereInput | mode_of_paymentWhereInput[]
    mode_of_payment?: StringNullableFilter<"mode_of_payment"> | string | null
  }, "mode_of_payment_id">

  export type mode_of_paymentOrderByWithAggregationInput = {
    mode_of_payment_id?: SortOrder
    mode_of_payment?: SortOrderInput | SortOrder
    _count?: mode_of_paymentCountOrderByAggregateInput
    _avg?: mode_of_paymentAvgOrderByAggregateInput
    _max?: mode_of_paymentMaxOrderByAggregateInput
    _min?: mode_of_paymentMinOrderByAggregateInput
    _sum?: mode_of_paymentSumOrderByAggregateInput
  }

  export type mode_of_paymentScalarWhereWithAggregatesInput = {
    AND?: mode_of_paymentScalarWhereWithAggregatesInput | mode_of_paymentScalarWhereWithAggregatesInput[]
    OR?: mode_of_paymentScalarWhereWithAggregatesInput[]
    NOT?: mode_of_paymentScalarWhereWithAggregatesInput | mode_of_paymentScalarWhereWithAggregatesInput[]
    mode_of_payment_id?: BigIntWithAggregatesFilter<"mode_of_payment"> | bigint | number
    mode_of_payment?: StringNullableWithAggregatesFilter<"mode_of_payment"> | string | null
  }

  export type patient_appointmentsWhereInput = {
    AND?: patient_appointmentsWhereInput | patient_appointmentsWhereInput[]
    OR?: patient_appointmentsWhereInput[]
    NOT?: patient_appointmentsWhereInput | patient_appointmentsWhereInput[]
    patient_appointments_id?: BigIntFilter<"patient_appointments"> | bigint | number
    patient_id?: BigIntFilter<"patient_appointments"> | bigint | number
    appoint_id?: BigIntFilter<"patient_appointments"> | bigint | number
    booking_date?: DateTimeNullableFilter<"patient_appointments"> | Date | string | null
    appointments?: XOR<AppointmentsScalarRelationFilter, appointmentsWhereInput>
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
  }

  export type patient_appointmentsOrderByWithRelationInput = {
    patient_appointments_id?: SortOrder
    patient_id?: SortOrder
    appoint_id?: SortOrder
    booking_date?: SortOrderInput | SortOrder
    appointments?: appointmentsOrderByWithRelationInput
    patients?: patientsOrderByWithRelationInput
  }

  export type patient_appointmentsWhereUniqueInput = Prisma.AtLeast<{
    patient_appointments_id?: bigint | number
    AND?: patient_appointmentsWhereInput | patient_appointmentsWhereInput[]
    OR?: patient_appointmentsWhereInput[]
    NOT?: patient_appointmentsWhereInput | patient_appointmentsWhereInput[]
    patient_id?: BigIntFilter<"patient_appointments"> | bigint | number
    appoint_id?: BigIntFilter<"patient_appointments"> | bigint | number
    booking_date?: DateTimeNullableFilter<"patient_appointments"> | Date | string | null
    appointments?: XOR<AppointmentsScalarRelationFilter, appointmentsWhereInput>
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
  }, "patient_appointments_id">

  export type patient_appointmentsOrderByWithAggregationInput = {
    patient_appointments_id?: SortOrder
    patient_id?: SortOrder
    appoint_id?: SortOrder
    booking_date?: SortOrderInput | SortOrder
    _count?: patient_appointmentsCountOrderByAggregateInput
    _avg?: patient_appointmentsAvgOrderByAggregateInput
    _max?: patient_appointmentsMaxOrderByAggregateInput
    _min?: patient_appointmentsMinOrderByAggregateInput
    _sum?: patient_appointmentsSumOrderByAggregateInput
  }

  export type patient_appointmentsScalarWhereWithAggregatesInput = {
    AND?: patient_appointmentsScalarWhereWithAggregatesInput | patient_appointmentsScalarWhereWithAggregatesInput[]
    OR?: patient_appointmentsScalarWhereWithAggregatesInput[]
    NOT?: patient_appointmentsScalarWhereWithAggregatesInput | patient_appointmentsScalarWhereWithAggregatesInput[]
    patient_appointments_id?: BigIntWithAggregatesFilter<"patient_appointments"> | bigint | number
    patient_id?: BigIntWithAggregatesFilter<"patient_appointments"> | bigint | number
    appoint_id?: BigIntWithAggregatesFilter<"patient_appointments"> | bigint | number
    booking_date?: DateTimeNullableWithAggregatesFilter<"patient_appointments"> | Date | string | null
  }

  export type patient_conditionsWhereInput = {
    AND?: patient_conditionsWhereInput | patient_conditionsWhereInput[]
    OR?: patient_conditionsWhereInput[]
    NOT?: patient_conditionsWhereInput | patient_conditionsWhereInput[]
    patient_conditions_id?: BigIntFilter<"patient_conditions"> | bigint | number
    condition_type?: StringNullableFilter<"patient_conditions"> | string | null
    condition_description?: StringNullableFilter<"patient_conditions"> | string | null
    patient_conditions?: XOR<Patient_conditionsScalarRelationFilter, patient_conditionsWhereInput>
    other_patient_conditions?: XOR<Patient_conditionsNullableScalarRelationFilter, patient_conditionsWhereInput> | null
  }

  export type patient_conditionsOrderByWithRelationInput = {
    patient_conditions_id?: SortOrder
    condition_type?: SortOrderInput | SortOrder
    condition_description?: SortOrderInput | SortOrder
    patient_conditions?: patient_conditionsOrderByWithRelationInput
    other_patient_conditions?: patient_conditionsOrderByWithRelationInput
  }

  export type patient_conditionsWhereUniqueInput = Prisma.AtLeast<{
    patient_conditions_id?: bigint | number
    AND?: patient_conditionsWhereInput | patient_conditionsWhereInput[]
    OR?: patient_conditionsWhereInput[]
    NOT?: patient_conditionsWhereInput | patient_conditionsWhereInput[]
    condition_type?: StringNullableFilter<"patient_conditions"> | string | null
    condition_description?: StringNullableFilter<"patient_conditions"> | string | null
    patient_conditions?: XOR<Patient_conditionsScalarRelationFilter, patient_conditionsWhereInput>
    other_patient_conditions?: XOR<Patient_conditionsNullableScalarRelationFilter, patient_conditionsWhereInput> | null
  }, "patient_conditions_id">

  export type patient_conditionsOrderByWithAggregationInput = {
    patient_conditions_id?: SortOrder
    condition_type?: SortOrderInput | SortOrder
    condition_description?: SortOrderInput | SortOrder
    _count?: patient_conditionsCountOrderByAggregateInput
    _avg?: patient_conditionsAvgOrderByAggregateInput
    _max?: patient_conditionsMaxOrderByAggregateInput
    _min?: patient_conditionsMinOrderByAggregateInput
    _sum?: patient_conditionsSumOrderByAggregateInput
  }

  export type patient_conditionsScalarWhereWithAggregatesInput = {
    AND?: patient_conditionsScalarWhereWithAggregatesInput | patient_conditionsScalarWhereWithAggregatesInput[]
    OR?: patient_conditionsScalarWhereWithAggregatesInput[]
    NOT?: patient_conditionsScalarWhereWithAggregatesInput | patient_conditionsScalarWhereWithAggregatesInput[]
    patient_conditions_id?: BigIntWithAggregatesFilter<"patient_conditions"> | bigint | number
    condition_type?: StringNullableWithAggregatesFilter<"patient_conditions"> | string | null
    condition_description?: StringNullableWithAggregatesFilter<"patient_conditions"> | string | null
  }

  export type patient_detailsWhereInput = {
    AND?: patient_detailsWhereInput | patient_detailsWhereInput[]
    OR?: patient_detailsWhereInput[]
    NOT?: patient_detailsWhereInput | patient_detailsWhereInput[]
    patient_details_id?: BigIntFilter<"patient_details"> | bigint | number
    patient_id?: BigIntFilter<"patient_details"> | bigint | number
    patient_conditions_id?: BigIntFilter<"patient_details"> | bigint | number
    patient_birth_date?: DateTimeNullableFilter<"patient_details"> | Date | string | null
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
  }

  export type patient_detailsOrderByWithRelationInput = {
    patient_details_id?: SortOrder
    patient_id?: SortOrder
    patient_conditions_id?: SortOrder
    patient_birth_date?: SortOrderInput | SortOrder
    patients?: patientsOrderByWithRelationInput
  }

  export type patient_detailsWhereUniqueInput = Prisma.AtLeast<{
    patient_details_id?: bigint | number
    AND?: patient_detailsWhereInput | patient_detailsWhereInput[]
    OR?: patient_detailsWhereInput[]
    NOT?: patient_detailsWhereInput | patient_detailsWhereInput[]
    patient_id?: BigIntFilter<"patient_details"> | bigint | number
    patient_conditions_id?: BigIntFilter<"patient_details"> | bigint | number
    patient_birth_date?: DateTimeNullableFilter<"patient_details"> | Date | string | null
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
  }, "patient_details_id">

  export type patient_detailsOrderByWithAggregationInput = {
    patient_details_id?: SortOrder
    patient_id?: SortOrder
    patient_conditions_id?: SortOrder
    patient_birth_date?: SortOrderInput | SortOrder
    _count?: patient_detailsCountOrderByAggregateInput
    _avg?: patient_detailsAvgOrderByAggregateInput
    _max?: patient_detailsMaxOrderByAggregateInput
    _min?: patient_detailsMinOrderByAggregateInput
    _sum?: patient_detailsSumOrderByAggregateInput
  }

  export type patient_detailsScalarWhereWithAggregatesInput = {
    AND?: patient_detailsScalarWhereWithAggregatesInput | patient_detailsScalarWhereWithAggregatesInput[]
    OR?: patient_detailsScalarWhereWithAggregatesInput[]
    NOT?: patient_detailsScalarWhereWithAggregatesInput | patient_detailsScalarWhereWithAggregatesInput[]
    patient_details_id?: BigIntWithAggregatesFilter<"patient_details"> | bigint | number
    patient_id?: BigIntWithAggregatesFilter<"patient_details"> | bigint | number
    patient_conditions_id?: BigIntWithAggregatesFilter<"patient_details"> | bigint | number
    patient_birth_date?: DateTimeNullableWithAggregatesFilter<"patient_details"> | Date | string | null
  }

  export type patientsWhereInput = {
    AND?: patientsWhereInput | patientsWhereInput[]
    OR?: patientsWhereInput[]
    NOT?: patientsWhereInput | patientsWhereInput[]
    patient_id?: BigIntFilter<"patients"> | bigint | number
    patient_name?: StringNullableFilter<"patients"> | string | null
    user_id?: BigIntFilter<"patients"> | bigint | number
    patient_appointments?: Patient_appointmentsListRelationFilter
    patient_details?: Patient_detailsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    session?: SessionListRelationFilter
  }

  export type patientsOrderByWithRelationInput = {
    patient_id?: SortOrder
    patient_name?: SortOrderInput | SortOrder
    user_id?: SortOrder
    patient_appointments?: patient_appointmentsOrderByRelationAggregateInput
    patient_details?: patient_detailsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    session?: sessionOrderByRelationAggregateInput
  }

  export type patientsWhereUniqueInput = Prisma.AtLeast<{
    patient_id?: bigint | number
    AND?: patientsWhereInput | patientsWhereInput[]
    OR?: patientsWhereInput[]
    NOT?: patientsWhereInput | patientsWhereInput[]
    patient_name?: StringNullableFilter<"patients"> | string | null
    user_id?: BigIntFilter<"patients"> | bigint | number
    patient_appointments?: Patient_appointmentsListRelationFilter
    patient_details?: Patient_detailsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    session?: SessionListRelationFilter
  }, "patient_id">

  export type patientsOrderByWithAggregationInput = {
    patient_id?: SortOrder
    patient_name?: SortOrderInput | SortOrder
    user_id?: SortOrder
    _count?: patientsCountOrderByAggregateInput
    _avg?: patientsAvgOrderByAggregateInput
    _max?: patientsMaxOrderByAggregateInput
    _min?: patientsMinOrderByAggregateInput
    _sum?: patientsSumOrderByAggregateInput
  }

  export type patientsScalarWhereWithAggregatesInput = {
    AND?: patientsScalarWhereWithAggregatesInput | patientsScalarWhereWithAggregatesInput[]
    OR?: patientsScalarWhereWithAggregatesInput[]
    NOT?: patientsScalarWhereWithAggregatesInput | patientsScalarWhereWithAggregatesInput[]
    patient_id?: BigIntWithAggregatesFilter<"patients"> | bigint | number
    patient_name?: StringNullableWithAggregatesFilter<"patients"> | string | null
    user_id?: BigIntWithAggregatesFilter<"patients"> | bigint | number
  }

  export type paymentWhereInput = {
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    payment_id?: BigIntFilter<"payment"> | bigint | number
    appoint_id?: BigIntFilter<"payment"> | bigint | number
    user_id?: BigIntFilter<"payment"> | bigint | number
    payment_status?: StringNullableFilter<"payment"> | string | null
  }

  export type paymentOrderByWithRelationInput = {
    payment_id?: SortOrder
    appoint_id?: SortOrder
    user_id?: SortOrder
    payment_status?: SortOrderInput | SortOrder
  }

  export type paymentWhereUniqueInput = Prisma.AtLeast<{
    payment_id?: bigint | number
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    appoint_id?: BigIntFilter<"payment"> | bigint | number
    user_id?: BigIntFilter<"payment"> | bigint | number
    payment_status?: StringNullableFilter<"payment"> | string | null
  }, "payment_id">

  export type paymentOrderByWithAggregationInput = {
    payment_id?: SortOrder
    appoint_id?: SortOrder
    user_id?: SortOrder
    payment_status?: SortOrderInput | SortOrder
    _count?: paymentCountOrderByAggregateInput
    _avg?: paymentAvgOrderByAggregateInput
    _max?: paymentMaxOrderByAggregateInput
    _min?: paymentMinOrderByAggregateInput
    _sum?: paymentSumOrderByAggregateInput
  }

  export type paymentScalarWhereWithAggregatesInput = {
    AND?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    OR?: paymentScalarWhereWithAggregatesInput[]
    NOT?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    payment_id?: BigIntWithAggregatesFilter<"payment"> | bigint | number
    appoint_id?: BigIntWithAggregatesFilter<"payment"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"payment"> | bigint | number
    payment_status?: StringNullableWithAggregatesFilter<"payment"> | string | null
  }

  export type recurrenceWhereInput = {
    AND?: recurrenceWhereInput | recurrenceWhereInput[]
    OR?: recurrenceWhereInput[]
    NOT?: recurrenceWhereInput | recurrenceWhereInput[]
    recurrence_id?: BigIntFilter<"recurrence"> | bigint | number
    recurrence_type?: StringNullableFilter<"recurrence"> | string | null
    interval?: StringNullableFilter<"recurrence"> | string | null
    start_date?: DateTimeNullableFilter<"recurrence"> | Date | string | null
    end_date?: DateTimeNullableFilter<"recurrence"> | Date | string | null
    occurence_count?: BigIntNullableFilter<"recurrence"> | bigint | number | null
    time?: DateTimeNullableFilter<"recurrence"> | Date | string | null
    recurring_instances?: Recurring_instancesListRelationFilter
  }

  export type recurrenceOrderByWithRelationInput = {
    recurrence_id?: SortOrder
    recurrence_type?: SortOrderInput | SortOrder
    interval?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    occurence_count?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    recurring_instances?: recurring_instancesOrderByRelationAggregateInput
  }

  export type recurrenceWhereUniqueInput = Prisma.AtLeast<{
    recurrence_id?: bigint | number
    AND?: recurrenceWhereInput | recurrenceWhereInput[]
    OR?: recurrenceWhereInput[]
    NOT?: recurrenceWhereInput | recurrenceWhereInput[]
    recurrence_type?: StringNullableFilter<"recurrence"> | string | null
    interval?: StringNullableFilter<"recurrence"> | string | null
    start_date?: DateTimeNullableFilter<"recurrence"> | Date | string | null
    end_date?: DateTimeNullableFilter<"recurrence"> | Date | string | null
    occurence_count?: BigIntNullableFilter<"recurrence"> | bigint | number | null
    time?: DateTimeNullableFilter<"recurrence"> | Date | string | null
    recurring_instances?: Recurring_instancesListRelationFilter
  }, "recurrence_id">

  export type recurrenceOrderByWithAggregationInput = {
    recurrence_id?: SortOrder
    recurrence_type?: SortOrderInput | SortOrder
    interval?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    occurence_count?: SortOrderInput | SortOrder
    time?: SortOrderInput | SortOrder
    _count?: recurrenceCountOrderByAggregateInput
    _avg?: recurrenceAvgOrderByAggregateInput
    _max?: recurrenceMaxOrderByAggregateInput
    _min?: recurrenceMinOrderByAggregateInput
    _sum?: recurrenceSumOrderByAggregateInput
  }

  export type recurrenceScalarWhereWithAggregatesInput = {
    AND?: recurrenceScalarWhereWithAggregatesInput | recurrenceScalarWhereWithAggregatesInput[]
    OR?: recurrenceScalarWhereWithAggregatesInput[]
    NOT?: recurrenceScalarWhereWithAggregatesInput | recurrenceScalarWhereWithAggregatesInput[]
    recurrence_id?: BigIntWithAggregatesFilter<"recurrence"> | bigint | number
    recurrence_type?: StringNullableWithAggregatesFilter<"recurrence"> | string | null
    interval?: StringNullableWithAggregatesFilter<"recurrence"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"recurrence"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"recurrence"> | Date | string | null
    occurence_count?: BigIntNullableWithAggregatesFilter<"recurrence"> | bigint | number | null
    time?: DateTimeNullableWithAggregatesFilter<"recurrence"> | Date | string | null
  }

  export type recurring_instancesWhereInput = {
    AND?: recurring_instancesWhereInput | recurring_instancesWhereInput[]
    OR?: recurring_instancesWhereInput[]
    NOT?: recurring_instancesWhereInput | recurring_instancesWhereInput[]
    instance_id?: BigIntFilter<"recurring_instances"> | bigint | number
    appoint_id?: BigIntFilter<"recurring_instances"> | bigint | number
    recurrence_id?: BigIntFilter<"recurring_instances"> | bigint | number
    appoint_date?: DateTimeNullableFilter<"recurring_instances"> | Date | string | null
    appoint_time?: DateTimeNullableFilter<"recurring_instances"> | Date | string | null
    instance_status?: StringNullableFilter<"recurring_instances"> | string | null
    appointments?: XOR<AppointmentsScalarRelationFilter, appointmentsWhereInput>
    recurrence?: XOR<RecurrenceScalarRelationFilter, recurrenceWhereInput>
  }

  export type recurring_instancesOrderByWithRelationInput = {
    instance_id?: SortOrder
    appoint_id?: SortOrder
    recurrence_id?: SortOrder
    appoint_date?: SortOrderInput | SortOrder
    appoint_time?: SortOrderInput | SortOrder
    instance_status?: SortOrderInput | SortOrder
    appointments?: appointmentsOrderByWithRelationInput
    recurrence?: recurrenceOrderByWithRelationInput
  }

  export type recurring_instancesWhereUniqueInput = Prisma.AtLeast<{
    instance_id?: bigint | number
    AND?: recurring_instancesWhereInput | recurring_instancesWhereInput[]
    OR?: recurring_instancesWhereInput[]
    NOT?: recurring_instancesWhereInput | recurring_instancesWhereInput[]
    appoint_id?: BigIntFilter<"recurring_instances"> | bigint | number
    recurrence_id?: BigIntFilter<"recurring_instances"> | bigint | number
    appoint_date?: DateTimeNullableFilter<"recurring_instances"> | Date | string | null
    appoint_time?: DateTimeNullableFilter<"recurring_instances"> | Date | string | null
    instance_status?: StringNullableFilter<"recurring_instances"> | string | null
    appointments?: XOR<AppointmentsScalarRelationFilter, appointmentsWhereInput>
    recurrence?: XOR<RecurrenceScalarRelationFilter, recurrenceWhereInput>
  }, "instance_id">

  export type recurring_instancesOrderByWithAggregationInput = {
    instance_id?: SortOrder
    appoint_id?: SortOrder
    recurrence_id?: SortOrder
    appoint_date?: SortOrderInput | SortOrder
    appoint_time?: SortOrderInput | SortOrder
    instance_status?: SortOrderInput | SortOrder
    _count?: recurring_instancesCountOrderByAggregateInput
    _avg?: recurring_instancesAvgOrderByAggregateInput
    _max?: recurring_instancesMaxOrderByAggregateInput
    _min?: recurring_instancesMinOrderByAggregateInput
    _sum?: recurring_instancesSumOrderByAggregateInput
  }

  export type recurring_instancesScalarWhereWithAggregatesInput = {
    AND?: recurring_instancesScalarWhereWithAggregatesInput | recurring_instancesScalarWhereWithAggregatesInput[]
    OR?: recurring_instancesScalarWhereWithAggregatesInput[]
    NOT?: recurring_instancesScalarWhereWithAggregatesInput | recurring_instancesScalarWhereWithAggregatesInput[]
    instance_id?: BigIntWithAggregatesFilter<"recurring_instances"> | bigint | number
    appoint_id?: BigIntWithAggregatesFilter<"recurring_instances"> | bigint | number
    recurrence_id?: BigIntWithAggregatesFilter<"recurring_instances"> | bigint | number
    appoint_date?: DateTimeNullableWithAggregatesFilter<"recurring_instances"> | Date | string | null
    appoint_time?: DateTimeNullableWithAggregatesFilter<"recurring_instances"> | Date | string | null
    instance_status?: StringNullableWithAggregatesFilter<"recurring_instances"> | string | null
  }

  export type sessionWhereInput = {
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    session_id?: BigIntFilter<"session"> | bigint | number
    patient_id?: BigIntFilter<"session"> | bigint | number
    staff_id?: BigIntFilter<"session"> | bigint | number
    appoint_id?: BigIntFilter<"session"> | bigint | number
    appointments?: XOR<AppointmentsScalarRelationFilter, appointmentsWhereInput>
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
    clinic_staff?: XOR<Clinic_staffScalarRelationFilter, clinic_staffWhereInput>
    session_details?: Session_detailsListRelationFilter
  }

  export type sessionOrderByWithRelationInput = {
    session_id?: SortOrder
    patient_id?: SortOrder
    staff_id?: SortOrder
    appoint_id?: SortOrder
    appointments?: appointmentsOrderByWithRelationInput
    patients?: patientsOrderByWithRelationInput
    clinic_staff?: clinic_staffOrderByWithRelationInput
    session_details?: session_detailsOrderByRelationAggregateInput
  }

  export type sessionWhereUniqueInput = Prisma.AtLeast<{
    session_id?: bigint | number
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    patient_id?: BigIntFilter<"session"> | bigint | number
    staff_id?: BigIntFilter<"session"> | bigint | number
    appoint_id?: BigIntFilter<"session"> | bigint | number
    appointments?: XOR<AppointmentsScalarRelationFilter, appointmentsWhereInput>
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
    clinic_staff?: XOR<Clinic_staffScalarRelationFilter, clinic_staffWhereInput>
    session_details?: Session_detailsListRelationFilter
  }, "session_id">

  export type sessionOrderByWithAggregationInput = {
    session_id?: SortOrder
    patient_id?: SortOrder
    staff_id?: SortOrder
    appoint_id?: SortOrder
    _count?: sessionCountOrderByAggregateInput
    _avg?: sessionAvgOrderByAggregateInput
    _max?: sessionMaxOrderByAggregateInput
    _min?: sessionMinOrderByAggregateInput
    _sum?: sessionSumOrderByAggregateInput
  }

  export type sessionScalarWhereWithAggregatesInput = {
    AND?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    OR?: sessionScalarWhereWithAggregatesInput[]
    NOT?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    session_id?: BigIntWithAggregatesFilter<"session"> | bigint | number
    patient_id?: BigIntWithAggregatesFilter<"session"> | bigint | number
    staff_id?: BigIntWithAggregatesFilter<"session"> | bigint | number
    appoint_id?: BigIntWithAggregatesFilter<"session"> | bigint | number
  }

  export type session_detailsWhereInput = {
    AND?: session_detailsWhereInput | session_detailsWhereInput[]
    OR?: session_detailsWhereInput[]
    NOT?: session_detailsWhereInput | session_detailsWhereInput[]
    session_details_id?: BigIntFilter<"session_details"> | bigint | number
    session_id?: BigIntFilter<"session_details"> | bigint | number
    session_description?: StringNullableFilter<"session_details"> | string | null
    session_date?: DateTimeNullableFilter<"session_details"> | Date | string | null
    session_time?: DateTimeNullableFilter<"session_details"> | Date | string | null
    session_document?: BytesNullableFilter<"session_details"> | Uint8Array | null
    session?: XOR<SessionScalarRelationFilter, sessionWhereInput>
  }

  export type session_detailsOrderByWithRelationInput = {
    session_details_id?: SortOrder
    session_id?: SortOrder
    session_description?: SortOrderInput | SortOrder
    session_date?: SortOrderInput | SortOrder
    session_time?: SortOrderInput | SortOrder
    session_document?: SortOrderInput | SortOrder
    session?: sessionOrderByWithRelationInput
  }

  export type session_detailsWhereUniqueInput = Prisma.AtLeast<{
    session_details_id?: bigint | number
    AND?: session_detailsWhereInput | session_detailsWhereInput[]
    OR?: session_detailsWhereInput[]
    NOT?: session_detailsWhereInput | session_detailsWhereInput[]
    session_id?: BigIntFilter<"session_details"> | bigint | number
    session_description?: StringNullableFilter<"session_details"> | string | null
    session_date?: DateTimeNullableFilter<"session_details"> | Date | string | null
    session_time?: DateTimeNullableFilter<"session_details"> | Date | string | null
    session_document?: BytesNullableFilter<"session_details"> | Uint8Array | null
    session?: XOR<SessionScalarRelationFilter, sessionWhereInput>
  }, "session_details_id">

  export type session_detailsOrderByWithAggregationInput = {
    session_details_id?: SortOrder
    session_id?: SortOrder
    session_description?: SortOrderInput | SortOrder
    session_date?: SortOrderInput | SortOrder
    session_time?: SortOrderInput | SortOrder
    session_document?: SortOrderInput | SortOrder
    _count?: session_detailsCountOrderByAggregateInput
    _avg?: session_detailsAvgOrderByAggregateInput
    _max?: session_detailsMaxOrderByAggregateInput
    _min?: session_detailsMinOrderByAggregateInput
    _sum?: session_detailsSumOrderByAggregateInput
  }

  export type session_detailsScalarWhereWithAggregatesInput = {
    AND?: session_detailsScalarWhereWithAggregatesInput | session_detailsScalarWhereWithAggregatesInput[]
    OR?: session_detailsScalarWhereWithAggregatesInput[]
    NOT?: session_detailsScalarWhereWithAggregatesInput | session_detailsScalarWhereWithAggregatesInput[]
    session_details_id?: BigIntWithAggregatesFilter<"session_details"> | bigint | number
    session_id?: BigIntWithAggregatesFilter<"session_details"> | bigint | number
    session_description?: StringNullableWithAggregatesFilter<"session_details"> | string | null
    session_date?: DateTimeNullableWithAggregatesFilter<"session_details"> | Date | string | null
    session_time?: DateTimeNullableWithAggregatesFilter<"session_details"> | Date | string | null
    session_document?: BytesNullableWithAggregatesFilter<"session_details"> | Uint8Array | null
  }

  export type staff_roleWhereInput = {
    AND?: staff_roleWhereInput | staff_roleWhereInput[]
    OR?: staff_roleWhereInput[]
    NOT?: staff_roleWhereInput | staff_roleWhereInput[]
    staff_role_id?: BigIntFilter<"staff_role"> | bigint | number
    staff_id?: BigIntFilter<"staff_role"> | bigint | number
    staff_role?: StringNullableFilter<"staff_role"> | string | null
    clinic_staff?: XOR<Clinic_staffScalarRelationFilter, clinic_staffWhereInput>
  }

  export type staff_roleOrderByWithRelationInput = {
    staff_role_id?: SortOrder
    staff_id?: SortOrder
    staff_role?: SortOrderInput | SortOrder
    clinic_staff?: clinic_staffOrderByWithRelationInput
  }

  export type staff_roleWhereUniqueInput = Prisma.AtLeast<{
    staff_role_id?: bigint | number
    AND?: staff_roleWhereInput | staff_roleWhereInput[]
    OR?: staff_roleWhereInput[]
    NOT?: staff_roleWhereInput | staff_roleWhereInput[]
    staff_id?: BigIntFilter<"staff_role"> | bigint | number
    staff_role?: StringNullableFilter<"staff_role"> | string | null
    clinic_staff?: XOR<Clinic_staffScalarRelationFilter, clinic_staffWhereInput>
  }, "staff_role_id">

  export type staff_roleOrderByWithAggregationInput = {
    staff_role_id?: SortOrder
    staff_id?: SortOrder
    staff_role?: SortOrderInput | SortOrder
    _count?: staff_roleCountOrderByAggregateInput
    _avg?: staff_roleAvgOrderByAggregateInput
    _max?: staff_roleMaxOrderByAggregateInput
    _min?: staff_roleMinOrderByAggregateInput
    _sum?: staff_roleSumOrderByAggregateInput
  }

  export type staff_roleScalarWhereWithAggregatesInput = {
    AND?: staff_roleScalarWhereWithAggregatesInput | staff_roleScalarWhereWithAggregatesInput[]
    OR?: staff_roleScalarWhereWithAggregatesInput[]
    NOT?: staff_roleScalarWhereWithAggregatesInput | staff_roleScalarWhereWithAggregatesInput[]
    staff_role_id?: BigIntWithAggregatesFilter<"staff_role"> | bigint | number
    staff_id?: BigIntWithAggregatesFilter<"staff_role"> | bigint | number
    staff_role?: StringNullableWithAggregatesFilter<"staff_role"> | string | null
  }

  export type type_of_paymentWhereInput = {
    AND?: type_of_paymentWhereInput | type_of_paymentWhereInput[]
    OR?: type_of_paymentWhereInput[]
    NOT?: type_of_paymentWhereInput | type_of_paymentWhereInput[]
    type_of_payment_id?: BigIntFilter<"type_of_payment"> | bigint | number
    type_of_payment?: StringNullableFilter<"type_of_payment"> | string | null
  }

  export type type_of_paymentOrderByWithRelationInput = {
    type_of_payment_id?: SortOrder
    type_of_payment?: SortOrderInput | SortOrder
  }

  export type type_of_paymentWhereUniqueInput = Prisma.AtLeast<{
    type_of_payment_id?: bigint | number
    AND?: type_of_paymentWhereInput | type_of_paymentWhereInput[]
    OR?: type_of_paymentWhereInput[]
    NOT?: type_of_paymentWhereInput | type_of_paymentWhereInput[]
    type_of_payment?: StringNullableFilter<"type_of_payment"> | string | null
  }, "type_of_payment_id">

  export type type_of_paymentOrderByWithAggregationInput = {
    type_of_payment_id?: SortOrder
    type_of_payment?: SortOrderInput | SortOrder
    _count?: type_of_paymentCountOrderByAggregateInput
    _avg?: type_of_paymentAvgOrderByAggregateInput
    _max?: type_of_paymentMaxOrderByAggregateInput
    _min?: type_of_paymentMinOrderByAggregateInput
    _sum?: type_of_paymentSumOrderByAggregateInput
  }

  export type type_of_paymentScalarWhereWithAggregatesInput = {
    AND?: type_of_paymentScalarWhereWithAggregatesInput | type_of_paymentScalarWhereWithAggregatesInput[]
    OR?: type_of_paymentScalarWhereWithAggregatesInput[]
    NOT?: type_of_paymentScalarWhereWithAggregatesInput | type_of_paymentScalarWhereWithAggregatesInput[]
    type_of_payment_id?: BigIntWithAggregatesFilter<"type_of_payment"> | bigint | number
    type_of_payment?: StringNullableWithAggregatesFilter<"type_of_payment"> | string | null
  }

  export type user_contactsWhereInput = {
    AND?: user_contactsWhereInput | user_contactsWhereInput[]
    OR?: user_contactsWhereInput[]
    NOT?: user_contactsWhereInput | user_contactsWhereInput[]
    user_contact_id?: BigIntFilter<"user_contacts"> | bigint | number
    user_id?: BigIntFilter<"user_contacts"> | bigint | number
    user_email?: StringNullableFilter<"user_contacts"> | string | null
    user_contact_number?: StringNullableFilter<"user_contacts"> | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type user_contactsOrderByWithRelationInput = {
    user_contact_id?: SortOrder
    user_id?: SortOrder
    user_email?: SortOrderInput | SortOrder
    user_contact_number?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type user_contactsWhereUniqueInput = Prisma.AtLeast<{
    user_contact_id?: bigint | number
    AND?: user_contactsWhereInput | user_contactsWhereInput[]
    OR?: user_contactsWhereInput[]
    NOT?: user_contactsWhereInput | user_contactsWhereInput[]
    user_id?: BigIntFilter<"user_contacts"> | bigint | number
    user_email?: StringNullableFilter<"user_contacts"> | string | null
    user_contact_number?: StringNullableFilter<"user_contacts"> | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "user_contact_id">

  export type user_contactsOrderByWithAggregationInput = {
    user_contact_id?: SortOrder
    user_id?: SortOrder
    user_email?: SortOrderInput | SortOrder
    user_contact_number?: SortOrderInput | SortOrder
    _count?: user_contactsCountOrderByAggregateInput
    _avg?: user_contactsAvgOrderByAggregateInput
    _max?: user_contactsMaxOrderByAggregateInput
    _min?: user_contactsMinOrderByAggregateInput
    _sum?: user_contactsSumOrderByAggregateInput
  }

  export type user_contactsScalarWhereWithAggregatesInput = {
    AND?: user_contactsScalarWhereWithAggregatesInput | user_contactsScalarWhereWithAggregatesInput[]
    OR?: user_contactsScalarWhereWithAggregatesInput[]
    NOT?: user_contactsScalarWhereWithAggregatesInput | user_contactsScalarWhereWithAggregatesInput[]
    user_contact_id?: BigIntWithAggregatesFilter<"user_contacts"> | bigint | number
    user_id?: BigIntWithAggregatesFilter<"user_contacts"> | bigint | number
    user_email?: StringNullableWithAggregatesFilter<"user_contacts"> | string | null
    user_contact_number?: StringNullableWithAggregatesFilter<"user_contacts"> | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    user_id?: BigIntFilter<"users"> | bigint | number
    user_full_name?: StringNullableFilter<"users"> | string | null
    user_password?: StringNullableFilter<"users"> | string | null
    username?: StringNullableFilter<"users"> | string | null
    appointments?: AppointmentsListRelationFilter
    patients?: PatientsListRelationFilter
    user_contacts?: User_contactsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    user_id?: SortOrder
    user_full_name?: SortOrderInput | SortOrder
    user_password?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    appointments?: appointmentsOrderByRelationAggregateInput
    patients?: patientsOrderByRelationAggregateInput
    user_contacts?: user_contactsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    user_id?: bigint | number
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    user_full_name?: StringNullableFilter<"users"> | string | null
    user_password?: StringNullableFilter<"users"> | string | null
    username?: StringNullableFilter<"users"> | string | null
    appointments?: AppointmentsListRelationFilter
    patients?: PatientsListRelationFilter
    user_contacts?: User_contactsListRelationFilter
  }, "user_id">

  export type usersOrderByWithAggregationInput = {
    user_id?: SortOrder
    user_full_name?: SortOrderInput | SortOrder
    user_password?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    user_id?: BigIntWithAggregatesFilter<"users"> | bigint | number
    user_full_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    user_password?: StringNullableWithAggregatesFilter<"users"> | string | null
    username?: StringNullableWithAggregatesFilter<"users"> | string | null
  }

  export type appointment_statusCreateInput = {
    appointment_status_id?: bigint | number
    appointment_status?: string | null
    appointments?: appointmentsCreateNestedManyWithoutAppointment_statusInput
  }

  export type appointment_statusUncheckedCreateInput = {
    appointment_status_id?: bigint | number
    appointment_status?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutAppointment_statusInput
  }

  export type appointment_statusUpdateInput = {
    appointment_status_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appointment_status?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutAppointment_statusNestedInput
  }

  export type appointment_statusUncheckedUpdateInput = {
    appointment_status_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appointment_status?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutAppointment_statusNestedInput
  }

  export type appointment_statusCreateManyInput = {
    appointment_status_id?: bigint | number
    appointment_status?: string | null
  }

  export type appointment_statusUpdateManyMutationInput = {
    appointment_status_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appointment_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type appointment_statusUncheckedUpdateManyInput = {
    appointment_status_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appointment_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type appointmentsCreateInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    appointment_status?: appointment_statusCreateNestedOneWithoutAppointmentsInput
    clinic_staff?: clinic_staffCreateNestedOneWithoutAppointmentsInput
    users?: usersCreateNestedOneWithoutAppointmentsInput
    patient_appointments?: patient_appointmentsCreateNestedManyWithoutAppointmentsInput
    recurring_instances?: recurring_instancesCreateNestedManyWithoutAppointmentsInput
    session?: sessionCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    staff_id?: bigint | number | null
    appointment_status_id?: bigint | number | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    user_id?: bigint | number | null
    patient_appointments?: patient_appointmentsUncheckedCreateNestedManyWithoutAppointmentsInput
    recurring_instances?: recurring_instancesUncheckedCreateNestedManyWithoutAppointmentsInput
    session?: sessionUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUpdateInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointment_status?: appointment_statusUpdateOneWithoutAppointmentsNestedInput
    clinic_staff?: clinic_staffUpdateOneWithoutAppointmentsNestedInput
    users?: usersUpdateOneWithoutAppointmentsNestedInput
    patient_appointments?: patient_appointmentsUpdateManyWithoutAppointmentsNestedInput
    recurring_instances?: recurring_instancesUpdateManyWithoutAppointmentsNestedInput
    session?: sessionUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staff_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    appointment_status_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    patient_appointments?: patient_appointmentsUncheckedUpdateManyWithoutAppointmentsNestedInput
    recurring_instances?: recurring_instancesUncheckedUpdateManyWithoutAppointmentsNestedInput
    session?: sessionUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsCreateManyInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    staff_id?: bigint | number | null
    appointment_status_id?: bigint | number | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    user_id?: bigint | number | null
  }

  export type appointmentsUpdateManyMutationInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type appointmentsUncheckedUpdateManyInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staff_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    appointment_status_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type clinic_staffCreateInput = {
    staff_id?: bigint | number
    staff_name?: string | null
    staff_birthdate?: Date | string | null
    appointments?: appointmentsCreateNestedManyWithoutClinic_staffInput
    clinic_staff_details?: clinic_staff_detailsCreateNestedManyWithoutClinic_staffInput
    session?: sessionCreateNestedManyWithoutClinic_staffInput
    staff_role?: staff_roleCreateNestedManyWithoutClinic_staffInput
  }

  export type clinic_staffUncheckedCreateInput = {
    staff_id?: bigint | number
    staff_name?: string | null
    staff_birthdate?: Date | string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutClinic_staffInput
    clinic_staff_details?: clinic_staff_detailsUncheckedCreateNestedManyWithoutClinic_staffInput
    session?: sessionUncheckedCreateNestedManyWithoutClinic_staffInput
    staff_role?: staff_roleUncheckedCreateNestedManyWithoutClinic_staffInput
  }

  export type clinic_staffUpdateInput = {
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_name?: NullableStringFieldUpdateOperationsInput | string | null
    staff_birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUpdateManyWithoutClinic_staffNestedInput
    clinic_staff_details?: clinic_staff_detailsUpdateManyWithoutClinic_staffNestedInput
    session?: sessionUpdateManyWithoutClinic_staffNestedInput
    staff_role?: staff_roleUpdateManyWithoutClinic_staffNestedInput
  }

  export type clinic_staffUncheckedUpdateInput = {
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_name?: NullableStringFieldUpdateOperationsInput | string | null
    staff_birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutClinic_staffNestedInput
    clinic_staff_details?: clinic_staff_detailsUncheckedUpdateManyWithoutClinic_staffNestedInput
    session?: sessionUncheckedUpdateManyWithoutClinic_staffNestedInput
    staff_role?: staff_roleUncheckedUpdateManyWithoutClinic_staffNestedInput
  }

  export type clinic_staffCreateManyInput = {
    staff_id?: bigint | number
    staff_name?: string | null
    staff_birthdate?: Date | string | null
  }

  export type clinic_staffUpdateManyMutationInput = {
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_name?: NullableStringFieldUpdateOperationsInput | string | null
    staff_birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type clinic_staffUncheckedUpdateManyInput = {
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_name?: NullableStringFieldUpdateOperationsInput | string | null
    staff_birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type clinic_staff_detailsCreateInput = {
    clinic_staff_contact_id?: bigint | number
    staff_contact?: string | null
    staff_address?: string | null
    clinic_staff: clinic_staffCreateNestedOneWithoutClinic_staff_detailsInput
  }

  export type clinic_staff_detailsUncheckedCreateInput = {
    clinic_staff_contact_id?: bigint | number
    staff_id: bigint | number
    staff_contact?: string | null
    staff_address?: string | null
  }

  export type clinic_staff_detailsUpdateInput = {
    clinic_staff_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_contact?: NullableStringFieldUpdateOperationsInput | string | null
    staff_address?: NullableStringFieldUpdateOperationsInput | string | null
    clinic_staff?: clinic_staffUpdateOneRequiredWithoutClinic_staff_detailsNestedInput
  }

  export type clinic_staff_detailsUncheckedUpdateInput = {
    clinic_staff_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_contact?: NullableStringFieldUpdateOperationsInput | string | null
    staff_address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinic_staff_detailsCreateManyInput = {
    clinic_staff_contact_id?: bigint | number
    staff_id: bigint | number
    staff_contact?: string | null
    staff_address?: string | null
  }

  export type clinic_staff_detailsUpdateManyMutationInput = {
    clinic_staff_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_contact?: NullableStringFieldUpdateOperationsInput | string | null
    staff_address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinic_staff_detailsUncheckedUpdateManyInput = {
    clinic_staff_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_contact?: NullableStringFieldUpdateOperationsInput | string | null
    staff_address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type guardianCreateInput = {
    guardian_id?: bigint | number
    patient_details_id: bigint | number
    guardian_name?: string | null
    guardian_contact?: string | null
  }

  export type guardianUncheckedCreateInput = {
    guardian_id?: bigint | number
    patient_details_id: bigint | number
    guardian_name?: string | null
    guardian_contact?: string | null
  }

  export type guardianUpdateInput = {
    guardian_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_contact?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type guardianUncheckedUpdateInput = {
    guardian_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_contact?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type guardianCreateManyInput = {
    guardian_id?: bigint | number
    patient_details_id: bigint | number
    guardian_name?: string | null
    guardian_contact?: string | null
  }

  export type guardianUpdateManyMutationInput = {
    guardian_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_contact?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type guardianUncheckedUpdateManyInput = {
    guardian_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    guardian_name?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_contact?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mode_of_paymentCreateInput = {
    mode_of_payment_id?: bigint | number
    mode_of_payment?: string | null
  }

  export type mode_of_paymentUncheckedCreateInput = {
    mode_of_payment_id?: bigint | number
    mode_of_payment?: string | null
  }

  export type mode_of_paymentUpdateInput = {
    mode_of_payment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    mode_of_payment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mode_of_paymentUncheckedUpdateInput = {
    mode_of_payment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    mode_of_payment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mode_of_paymentCreateManyInput = {
    mode_of_payment_id?: bigint | number
    mode_of_payment?: string | null
  }

  export type mode_of_paymentUpdateManyMutationInput = {
    mode_of_payment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    mode_of_payment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mode_of_paymentUncheckedUpdateManyInput = {
    mode_of_payment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    mode_of_payment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type patient_appointmentsCreateInput = {
    patient_appointments_id?: bigint | number
    booking_date?: Date | string | null
    appointments: appointmentsCreateNestedOneWithoutPatient_appointmentsInput
    patients: patientsCreateNestedOneWithoutPatient_appointmentsInput
  }

  export type patient_appointmentsUncheckedCreateInput = {
    patient_appointments_id?: bigint | number
    patient_id: bigint | number
    appoint_id: bigint | number
    booking_date?: Date | string | null
  }

  export type patient_appointmentsUpdateInput = {
    patient_appointments_id?: BigIntFieldUpdateOperationsInput | bigint | number
    booking_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUpdateOneRequiredWithoutPatient_appointmentsNestedInput
    patients?: patientsUpdateOneRequiredWithoutPatient_appointmentsNestedInput
  }

  export type patient_appointmentsUncheckedUpdateInput = {
    patient_appointments_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    booking_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_appointmentsCreateManyInput = {
    patient_appointments_id?: bigint | number
    patient_id: bigint | number
    appoint_id: bigint | number
    booking_date?: Date | string | null
  }

  export type patient_appointmentsUpdateManyMutationInput = {
    patient_appointments_id?: BigIntFieldUpdateOperationsInput | bigint | number
    booking_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_appointmentsUncheckedUpdateManyInput = {
    patient_appointments_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    booking_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_conditionsCreateInput = {
    condition_type?: string | null
    condition_description?: string | null
    patient_conditions?: patient_conditionsCreateNestedOneWithoutOther_patient_conditionsInput
    other_patient_conditions?: patient_conditionsCreateNestedOneWithoutPatient_conditionsInput
  }

  export type patient_conditionsUncheckedCreateInput = {
    patient_conditions_id?: bigint | number
    condition_type?: string | null
    condition_description?: string | null
    other_patient_conditions?: patient_conditionsUncheckedCreateNestedOneWithoutPatient_conditionsInput
  }

  export type patient_conditionsUpdateInput = {
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    condition_description?: NullableStringFieldUpdateOperationsInput | string | null
    patient_conditions?: patient_conditionsUpdateOneRequiredWithoutOther_patient_conditionsNestedInput
    other_patient_conditions?: patient_conditionsUpdateOneWithoutPatient_conditionsNestedInput
  }

  export type patient_conditionsUncheckedUpdateInput = {
    patient_conditions_id?: BigIntFieldUpdateOperationsInput | bigint | number
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    condition_description?: NullableStringFieldUpdateOperationsInput | string | null
    other_patient_conditions?: patient_conditionsUncheckedUpdateOneWithoutPatient_conditionsNestedInput
  }

  export type patient_conditionsCreateManyInput = {
    patient_conditions_id?: bigint | number
    condition_type?: string | null
    condition_description?: string | null
  }

  export type patient_conditionsUpdateManyMutationInput = {
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    condition_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type patient_conditionsUncheckedUpdateManyInput = {
    patient_conditions_id?: BigIntFieldUpdateOperationsInput | bigint | number
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    condition_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type patient_detailsCreateInput = {
    patient_details_id?: bigint | number
    patient_conditions_id: bigint | number
    patient_birth_date?: Date | string | null
    patients: patientsCreateNestedOneWithoutPatient_detailsInput
  }

  export type patient_detailsUncheckedCreateInput = {
    patient_details_id?: bigint | number
    patient_id: bigint | number
    patient_conditions_id: bigint | number
    patient_birth_date?: Date | string | null
  }

  export type patient_detailsUpdateInput = {
    patient_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_conditions_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patients?: patientsUpdateOneRequiredWithoutPatient_detailsNestedInput
  }

  export type patient_detailsUncheckedUpdateInput = {
    patient_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_conditions_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_detailsCreateManyInput = {
    patient_details_id?: bigint | number
    patient_id: bigint | number
    patient_conditions_id: bigint | number
    patient_birth_date?: Date | string | null
  }

  export type patient_detailsUpdateManyMutationInput = {
    patient_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_conditions_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_detailsUncheckedUpdateManyInput = {
    patient_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_conditions_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patientsCreateInput = {
    patient_id?: bigint | number
    patient_name?: string | null
    patient_appointments?: patient_appointmentsCreateNestedManyWithoutPatientsInput
    patient_details?: patient_detailsCreateNestedManyWithoutPatientsInput
    users: usersCreateNestedOneWithoutPatientsInput
    session?: sessionCreateNestedManyWithoutPatientsInput
  }

  export type patientsUncheckedCreateInput = {
    patient_id?: bigint | number
    patient_name?: string | null
    user_id: bigint | number
    patient_appointments?: patient_appointmentsUncheckedCreateNestedManyWithoutPatientsInput
    patient_details?: patient_detailsUncheckedCreateNestedManyWithoutPatientsInput
    session?: sessionUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsUpdateInput = {
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_name?: NullableStringFieldUpdateOperationsInput | string | null
    patient_appointments?: patient_appointmentsUpdateManyWithoutPatientsNestedInput
    patient_details?: patient_detailsUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneRequiredWithoutPatientsNestedInput
    session?: sessionUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateInput = {
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_appointments?: patient_appointmentsUncheckedUpdateManyWithoutPatientsNestedInput
    patient_details?: patient_detailsUncheckedUpdateManyWithoutPatientsNestedInput
    session?: sessionUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type patientsCreateManyInput = {
    patient_id?: bigint | number
    patient_name?: string | null
    user_id: bigint | number
  }

  export type patientsUpdateManyMutationInput = {
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type patientsUncheckedUpdateManyInput = {
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type paymentCreateInput = {
    payment_id?: bigint | number
    appoint_id: bigint | number
    user_id: bigint | number
    payment_status?: string | null
  }

  export type paymentUncheckedCreateInput = {
    payment_id?: bigint | number
    appoint_id: bigint | number
    user_id: bigint | number
    payment_status?: string | null
  }

  export type paymentUpdateInput = {
    payment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentUncheckedUpdateInput = {
    payment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentCreateManyInput = {
    payment_id?: bigint | number
    appoint_id: bigint | number
    user_id: bigint | number
    payment_status?: string | null
  }

  export type paymentUpdateManyMutationInput = {
    payment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentUncheckedUpdateManyInput = {
    payment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recurrenceCreateInput = {
    recurrence_id?: bigint | number
    recurrence_type?: string | null
    interval?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    occurence_count?: bigint | number | null
    time?: Date | string | null
    recurring_instances?: recurring_instancesCreateNestedManyWithoutRecurrenceInput
  }

  export type recurrenceUncheckedCreateInput = {
    recurrence_id?: bigint | number
    recurrence_type?: string | null
    interval?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    occurence_count?: bigint | number | null
    time?: Date | string | null
    recurring_instances?: recurring_instancesUncheckedCreateNestedManyWithoutRecurrenceInput
  }

  export type recurrenceUpdateInput = {
    recurrence_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recurrence_type?: NullableStringFieldUpdateOperationsInput | string | null
    interval?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occurence_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurring_instances?: recurring_instancesUpdateManyWithoutRecurrenceNestedInput
  }

  export type recurrenceUncheckedUpdateInput = {
    recurrence_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recurrence_type?: NullableStringFieldUpdateOperationsInput | string | null
    interval?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occurence_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurring_instances?: recurring_instancesUncheckedUpdateManyWithoutRecurrenceNestedInput
  }

  export type recurrenceCreateManyInput = {
    recurrence_id?: bigint | number
    recurrence_type?: string | null
    interval?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    occurence_count?: bigint | number | null
    time?: Date | string | null
  }

  export type recurrenceUpdateManyMutationInput = {
    recurrence_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recurrence_type?: NullableStringFieldUpdateOperationsInput | string | null
    interval?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occurence_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type recurrenceUncheckedUpdateManyInput = {
    recurrence_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recurrence_type?: NullableStringFieldUpdateOperationsInput | string | null
    interval?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occurence_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type recurring_instancesCreateInput = {
    instance_id?: bigint | number
    appoint_date?: Date | string | null
    appoint_time?: Date | string | null
    instance_status?: string | null
    appointments: appointmentsCreateNestedOneWithoutRecurring_instancesInput
    recurrence: recurrenceCreateNestedOneWithoutRecurring_instancesInput
  }

  export type recurring_instancesUncheckedCreateInput = {
    instance_id?: bigint | number
    appoint_id: bigint | number
    recurrence_id: bigint | number
    appoint_date?: Date | string | null
    appoint_time?: Date | string | null
    instance_status?: string | null
  }

  export type recurring_instancesUpdateInput = {
    instance_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appoint_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance_status?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateOneRequiredWithoutRecurring_instancesNestedInput
    recurrence?: recurrenceUpdateOneRequiredWithoutRecurring_instancesNestedInput
  }

  export type recurring_instancesUncheckedUpdateInput = {
    instance_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recurrence_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appoint_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recurring_instancesCreateManyInput = {
    instance_id?: bigint | number
    appoint_id: bigint | number
    recurrence_id: bigint | number
    appoint_date?: Date | string | null
    appoint_time?: Date | string | null
    instance_status?: string | null
  }

  export type recurring_instancesUpdateManyMutationInput = {
    instance_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appoint_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recurring_instancesUncheckedUpdateManyInput = {
    instance_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recurrence_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appoint_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionCreateInput = {
    session_id?: bigint | number
    appointments: appointmentsCreateNestedOneWithoutSessionInput
    patients: patientsCreateNestedOneWithoutSessionInput
    clinic_staff: clinic_staffCreateNestedOneWithoutSessionInput
    session_details?: session_detailsCreateNestedManyWithoutSessionInput
  }

  export type sessionUncheckedCreateInput = {
    session_id?: bigint | number
    patient_id: bigint | number
    staff_id: bigint | number
    appoint_id: bigint | number
    session_details?: session_detailsUncheckedCreateNestedManyWithoutSessionInput
  }

  export type sessionUpdateInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appointments?: appointmentsUpdateOneRequiredWithoutSessionNestedInput
    patients?: patientsUpdateOneRequiredWithoutSessionNestedInput
    clinic_staff?: clinic_staffUpdateOneRequiredWithoutSessionNestedInput
    session_details?: session_detailsUpdateManyWithoutSessionNestedInput
  }

  export type sessionUncheckedUpdateInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    session_details?: session_detailsUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type sessionCreateManyInput = {
    session_id?: bigint | number
    patient_id: bigint | number
    staff_id: bigint | number
    appoint_id: bigint | number
  }

  export type sessionUpdateManyMutationInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type sessionUncheckedUpdateManyInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type session_detailsCreateInput = {
    session_details_id?: bigint | number
    session_description?: string | null
    session_date?: Date | string | null
    session_time?: Date | string | null
    session_document?: Uint8Array | null
    session: sessionCreateNestedOneWithoutSession_detailsInput
  }

  export type session_detailsUncheckedCreateInput = {
    session_details_id?: bigint | number
    session_id: bigint | number
    session_description?: string | null
    session_date?: Date | string | null
    session_time?: Date | string | null
    session_document?: Uint8Array | null
  }

  export type session_detailsUpdateInput = {
    session_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    session_description?: NullableStringFieldUpdateOperationsInput | string | null
    session_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_document?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    session?: sessionUpdateOneRequiredWithoutSession_detailsNestedInput
  }

  export type session_detailsUncheckedUpdateInput = {
    session_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    session_description?: NullableStringFieldUpdateOperationsInput | string | null
    session_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_document?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type session_detailsCreateManyInput = {
    session_details_id?: bigint | number
    session_id: bigint | number
    session_description?: string | null
    session_date?: Date | string | null
    session_time?: Date | string | null
    session_document?: Uint8Array | null
  }

  export type session_detailsUpdateManyMutationInput = {
    session_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    session_description?: NullableStringFieldUpdateOperationsInput | string | null
    session_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_document?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type session_detailsUncheckedUpdateManyInput = {
    session_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    session_description?: NullableStringFieldUpdateOperationsInput | string | null
    session_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_document?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type staff_roleCreateInput = {
    staff_role_id?: bigint | number
    staff_role?: string | null
    clinic_staff: clinic_staffCreateNestedOneWithoutStaff_roleInput
  }

  export type staff_roleUncheckedCreateInput = {
    staff_role_id?: bigint | number
    staff_id: bigint | number
    staff_role?: string | null
  }

  export type staff_roleUpdateInput = {
    staff_role_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_role?: NullableStringFieldUpdateOperationsInput | string | null
    clinic_staff?: clinic_staffUpdateOneRequiredWithoutStaff_roleNestedInput
  }

  export type staff_roleUncheckedUpdateInput = {
    staff_role_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staff_roleCreateManyInput = {
    staff_role_id?: bigint | number
    staff_id: bigint | number
    staff_role?: string | null
  }

  export type staff_roleUpdateManyMutationInput = {
    staff_role_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staff_roleUncheckedUpdateManyInput = {
    staff_role_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type type_of_paymentCreateInput = {
    type_of_payment_id?: bigint | number
    type_of_payment?: string | null
  }

  export type type_of_paymentUncheckedCreateInput = {
    type_of_payment_id?: bigint | number
    type_of_payment?: string | null
  }

  export type type_of_paymentUpdateInput = {
    type_of_payment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type_of_payment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type type_of_paymentUncheckedUpdateInput = {
    type_of_payment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type_of_payment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type type_of_paymentCreateManyInput = {
    type_of_payment_id?: bigint | number
    type_of_payment?: string | null
  }

  export type type_of_paymentUpdateManyMutationInput = {
    type_of_payment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type_of_payment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type type_of_paymentUncheckedUpdateManyInput = {
    type_of_payment_id?: BigIntFieldUpdateOperationsInput | bigint | number
    type_of_payment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_contactsCreateInput = {
    user_contact_id?: bigint | number
    user_email?: string | null
    user_contact_number?: string | null
    users: usersCreateNestedOneWithoutUser_contactsInput
  }

  export type user_contactsUncheckedCreateInput = {
    user_contact_id?: bigint | number
    user_id: bigint | number
    user_email?: string | null
    user_contact_number?: string | null
  }

  export type user_contactsUpdateInput = {
    user_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneRequiredWithoutUser_contactsNestedInput
  }

  export type user_contactsUncheckedUpdateInput = {
    user_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_contact_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_contactsCreateManyInput = {
    user_contact_id?: bigint | number
    user_id: bigint | number
    user_email?: string | null
    user_contact_number?: string | null
  }

  export type user_contactsUpdateManyMutationInput = {
    user_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_contact_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_contactsUncheckedUpdateManyInput = {
    user_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_contact_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersCreateInput = {
    user_id?: bigint | number
    user_full_name?: string | null
    user_password?: string | null
    username?: string | null
    appointments?: appointmentsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
    user_contacts?: user_contactsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    user_id?: bigint | number
    user_full_name?: string | null
    user_password?: string | null
    username?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    user_contacts?: user_contactsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_full_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
    user_contacts?: user_contactsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_full_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    user_contacts?: user_contactsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    user_id?: bigint | number
    user_full_name?: string | null
    user_password?: string | null
    username?: string | null
  }

  export type usersUpdateManyMutationInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_full_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_full_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AppointmentsListRelationFilter = {
    every?: appointmentsWhereInput
    some?: appointmentsWhereInput
    none?: appointmentsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type appointmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type appointment_statusCountOrderByAggregateInput = {
    appointment_status_id?: SortOrder
    appointment_status?: SortOrder
  }

  export type appointment_statusAvgOrderByAggregateInput = {
    appointment_status_id?: SortOrder
  }

  export type appointment_statusMaxOrderByAggregateInput = {
    appointment_status_id?: SortOrder
    appointment_status?: SortOrder
  }

  export type appointment_statusMinOrderByAggregateInput = {
    appointment_status_id?: SortOrder
    appointment_status?: SortOrder
  }

  export type appointment_statusSumOrderByAggregateInput = {
    appointment_status_id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type Appointment_statusNullableScalarRelationFilter = {
    is?: appointment_statusWhereInput | null
    isNot?: appointment_statusWhereInput | null
  }

  export type Clinic_staffNullableScalarRelationFilter = {
    is?: clinic_staffWhereInput | null
    isNot?: clinic_staffWhereInput | null
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type Patient_appointmentsListRelationFilter = {
    every?: patient_appointmentsWhereInput
    some?: patient_appointmentsWhereInput
    none?: patient_appointmentsWhereInput
  }

  export type Recurring_instancesListRelationFilter = {
    every?: recurring_instancesWhereInput
    some?: recurring_instancesWhereInput
    none?: recurring_instancesWhereInput
  }

  export type SessionListRelationFilter = {
    every?: sessionWhereInput
    some?: sessionWhereInput
    none?: sessionWhereInput
  }

  export type patient_appointmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type recurring_instancesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type appointmentsCountOrderByAggregateInput = {
    appoint_id?: SortOrder
    preferred_time?: SortOrder
    preferred_date?: SortOrder
    staff_id?: SortOrder
    appointment_status_id?: SortOrder
    final_date?: SortOrder
    final_time?: SortOrder
    user_id?: SortOrder
  }

  export type appointmentsAvgOrderByAggregateInput = {
    appoint_id?: SortOrder
    staff_id?: SortOrder
    appointment_status_id?: SortOrder
    user_id?: SortOrder
  }

  export type appointmentsMaxOrderByAggregateInput = {
    appoint_id?: SortOrder
    preferred_time?: SortOrder
    preferred_date?: SortOrder
    staff_id?: SortOrder
    appointment_status_id?: SortOrder
    final_date?: SortOrder
    final_time?: SortOrder
    user_id?: SortOrder
  }

  export type appointmentsMinOrderByAggregateInput = {
    appoint_id?: SortOrder
    preferred_time?: SortOrder
    preferred_date?: SortOrder
    staff_id?: SortOrder
    appointment_status_id?: SortOrder
    final_date?: SortOrder
    final_time?: SortOrder
    user_id?: SortOrder
  }

  export type appointmentsSumOrderByAggregateInput = {
    appoint_id?: SortOrder
    staff_id?: SortOrder
    appointment_status_id?: SortOrder
    user_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type Clinic_staff_detailsListRelationFilter = {
    every?: clinic_staff_detailsWhereInput
    some?: clinic_staff_detailsWhereInput
    none?: clinic_staff_detailsWhereInput
  }

  export type Staff_roleListRelationFilter = {
    every?: staff_roleWhereInput
    some?: staff_roleWhereInput
    none?: staff_roleWhereInput
  }

  export type clinic_staff_detailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type staff_roleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clinic_staffCountOrderByAggregateInput = {
    staff_id?: SortOrder
    staff_name?: SortOrder
    staff_birthdate?: SortOrder
  }

  export type clinic_staffAvgOrderByAggregateInput = {
    staff_id?: SortOrder
  }

  export type clinic_staffMaxOrderByAggregateInput = {
    staff_id?: SortOrder
    staff_name?: SortOrder
    staff_birthdate?: SortOrder
  }

  export type clinic_staffMinOrderByAggregateInput = {
    staff_id?: SortOrder
    staff_name?: SortOrder
    staff_birthdate?: SortOrder
  }

  export type clinic_staffSumOrderByAggregateInput = {
    staff_id?: SortOrder
  }

  export type Clinic_staffScalarRelationFilter = {
    is?: clinic_staffWhereInput
    isNot?: clinic_staffWhereInput
  }

  export type clinic_staff_detailsCountOrderByAggregateInput = {
    clinic_staff_contact_id?: SortOrder
    staff_id?: SortOrder
    staff_contact?: SortOrder
    staff_address?: SortOrder
  }

  export type clinic_staff_detailsAvgOrderByAggregateInput = {
    clinic_staff_contact_id?: SortOrder
    staff_id?: SortOrder
  }

  export type clinic_staff_detailsMaxOrderByAggregateInput = {
    clinic_staff_contact_id?: SortOrder
    staff_id?: SortOrder
    staff_contact?: SortOrder
    staff_address?: SortOrder
  }

  export type clinic_staff_detailsMinOrderByAggregateInput = {
    clinic_staff_contact_id?: SortOrder
    staff_id?: SortOrder
    staff_contact?: SortOrder
    staff_address?: SortOrder
  }

  export type clinic_staff_detailsSumOrderByAggregateInput = {
    clinic_staff_contact_id?: SortOrder
    staff_id?: SortOrder
  }

  export type guardianCountOrderByAggregateInput = {
    guardian_id?: SortOrder
    patient_details_id?: SortOrder
    guardian_name?: SortOrder
    guardian_contact?: SortOrder
  }

  export type guardianAvgOrderByAggregateInput = {
    guardian_id?: SortOrder
    patient_details_id?: SortOrder
  }

  export type guardianMaxOrderByAggregateInput = {
    guardian_id?: SortOrder
    patient_details_id?: SortOrder
    guardian_name?: SortOrder
    guardian_contact?: SortOrder
  }

  export type guardianMinOrderByAggregateInput = {
    guardian_id?: SortOrder
    patient_details_id?: SortOrder
    guardian_name?: SortOrder
    guardian_contact?: SortOrder
  }

  export type guardianSumOrderByAggregateInput = {
    guardian_id?: SortOrder
    patient_details_id?: SortOrder
  }

  export type mode_of_paymentCountOrderByAggregateInput = {
    mode_of_payment_id?: SortOrder
    mode_of_payment?: SortOrder
  }

  export type mode_of_paymentAvgOrderByAggregateInput = {
    mode_of_payment_id?: SortOrder
  }

  export type mode_of_paymentMaxOrderByAggregateInput = {
    mode_of_payment_id?: SortOrder
    mode_of_payment?: SortOrder
  }

  export type mode_of_paymentMinOrderByAggregateInput = {
    mode_of_payment_id?: SortOrder
    mode_of_payment?: SortOrder
  }

  export type mode_of_paymentSumOrderByAggregateInput = {
    mode_of_payment_id?: SortOrder
  }

  export type AppointmentsScalarRelationFilter = {
    is?: appointmentsWhereInput
    isNot?: appointmentsWhereInput
  }

  export type PatientsScalarRelationFilter = {
    is?: patientsWhereInput
    isNot?: patientsWhereInput
  }

  export type patient_appointmentsCountOrderByAggregateInput = {
    patient_appointments_id?: SortOrder
    patient_id?: SortOrder
    appoint_id?: SortOrder
    booking_date?: SortOrder
  }

  export type patient_appointmentsAvgOrderByAggregateInput = {
    patient_appointments_id?: SortOrder
    patient_id?: SortOrder
    appoint_id?: SortOrder
  }

  export type patient_appointmentsMaxOrderByAggregateInput = {
    patient_appointments_id?: SortOrder
    patient_id?: SortOrder
    appoint_id?: SortOrder
    booking_date?: SortOrder
  }

  export type patient_appointmentsMinOrderByAggregateInput = {
    patient_appointments_id?: SortOrder
    patient_id?: SortOrder
    appoint_id?: SortOrder
    booking_date?: SortOrder
  }

  export type patient_appointmentsSumOrderByAggregateInput = {
    patient_appointments_id?: SortOrder
    patient_id?: SortOrder
    appoint_id?: SortOrder
  }

  export type Patient_conditionsScalarRelationFilter = {
    is?: patient_conditionsWhereInput
    isNot?: patient_conditionsWhereInput
  }

  export type Patient_conditionsNullableScalarRelationFilter = {
    is?: patient_conditionsWhereInput | null
    isNot?: patient_conditionsWhereInput | null
  }

  export type patient_conditionsCountOrderByAggregateInput = {
    patient_conditions_id?: SortOrder
    condition_type?: SortOrder
    condition_description?: SortOrder
  }

  export type patient_conditionsAvgOrderByAggregateInput = {
    patient_conditions_id?: SortOrder
  }

  export type patient_conditionsMaxOrderByAggregateInput = {
    patient_conditions_id?: SortOrder
    condition_type?: SortOrder
    condition_description?: SortOrder
  }

  export type patient_conditionsMinOrderByAggregateInput = {
    patient_conditions_id?: SortOrder
    condition_type?: SortOrder
    condition_description?: SortOrder
  }

  export type patient_conditionsSumOrderByAggregateInput = {
    patient_conditions_id?: SortOrder
  }

  export type patient_detailsCountOrderByAggregateInput = {
    patient_details_id?: SortOrder
    patient_id?: SortOrder
    patient_conditions_id?: SortOrder
    patient_birth_date?: SortOrder
  }

  export type patient_detailsAvgOrderByAggregateInput = {
    patient_details_id?: SortOrder
    patient_id?: SortOrder
    patient_conditions_id?: SortOrder
  }

  export type patient_detailsMaxOrderByAggregateInput = {
    patient_details_id?: SortOrder
    patient_id?: SortOrder
    patient_conditions_id?: SortOrder
    patient_birth_date?: SortOrder
  }

  export type patient_detailsMinOrderByAggregateInput = {
    patient_details_id?: SortOrder
    patient_id?: SortOrder
    patient_conditions_id?: SortOrder
    patient_birth_date?: SortOrder
  }

  export type patient_detailsSumOrderByAggregateInput = {
    patient_details_id?: SortOrder
    patient_id?: SortOrder
    patient_conditions_id?: SortOrder
  }

  export type Patient_detailsListRelationFilter = {
    every?: patient_detailsWhereInput
    some?: patient_detailsWhereInput
    none?: patient_detailsWhereInput
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type patient_detailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type patientsCountOrderByAggregateInput = {
    patient_id?: SortOrder
    patient_name?: SortOrder
    user_id?: SortOrder
  }

  export type patientsAvgOrderByAggregateInput = {
    patient_id?: SortOrder
    user_id?: SortOrder
  }

  export type patientsMaxOrderByAggregateInput = {
    patient_id?: SortOrder
    patient_name?: SortOrder
    user_id?: SortOrder
  }

  export type patientsMinOrderByAggregateInput = {
    patient_id?: SortOrder
    patient_name?: SortOrder
    user_id?: SortOrder
  }

  export type patientsSumOrderByAggregateInput = {
    patient_id?: SortOrder
    user_id?: SortOrder
  }

  export type paymentCountOrderByAggregateInput = {
    payment_id?: SortOrder
    appoint_id?: SortOrder
    user_id?: SortOrder
    payment_status?: SortOrder
  }

  export type paymentAvgOrderByAggregateInput = {
    payment_id?: SortOrder
    appoint_id?: SortOrder
    user_id?: SortOrder
  }

  export type paymentMaxOrderByAggregateInput = {
    payment_id?: SortOrder
    appoint_id?: SortOrder
    user_id?: SortOrder
    payment_status?: SortOrder
  }

  export type paymentMinOrderByAggregateInput = {
    payment_id?: SortOrder
    appoint_id?: SortOrder
    user_id?: SortOrder
    payment_status?: SortOrder
  }

  export type paymentSumOrderByAggregateInput = {
    payment_id?: SortOrder
    appoint_id?: SortOrder
    user_id?: SortOrder
  }

  export type recurrenceCountOrderByAggregateInput = {
    recurrence_id?: SortOrder
    recurrence_type?: SortOrder
    interval?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    occurence_count?: SortOrder
    time?: SortOrder
  }

  export type recurrenceAvgOrderByAggregateInput = {
    recurrence_id?: SortOrder
    occurence_count?: SortOrder
  }

  export type recurrenceMaxOrderByAggregateInput = {
    recurrence_id?: SortOrder
    recurrence_type?: SortOrder
    interval?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    occurence_count?: SortOrder
    time?: SortOrder
  }

  export type recurrenceMinOrderByAggregateInput = {
    recurrence_id?: SortOrder
    recurrence_type?: SortOrder
    interval?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    occurence_count?: SortOrder
    time?: SortOrder
  }

  export type recurrenceSumOrderByAggregateInput = {
    recurrence_id?: SortOrder
    occurence_count?: SortOrder
  }

  export type RecurrenceScalarRelationFilter = {
    is?: recurrenceWhereInput
    isNot?: recurrenceWhereInput
  }

  export type recurring_instancesCountOrderByAggregateInput = {
    instance_id?: SortOrder
    appoint_id?: SortOrder
    recurrence_id?: SortOrder
    appoint_date?: SortOrder
    appoint_time?: SortOrder
    instance_status?: SortOrder
  }

  export type recurring_instancesAvgOrderByAggregateInput = {
    instance_id?: SortOrder
    appoint_id?: SortOrder
    recurrence_id?: SortOrder
  }

  export type recurring_instancesMaxOrderByAggregateInput = {
    instance_id?: SortOrder
    appoint_id?: SortOrder
    recurrence_id?: SortOrder
    appoint_date?: SortOrder
    appoint_time?: SortOrder
    instance_status?: SortOrder
  }

  export type recurring_instancesMinOrderByAggregateInput = {
    instance_id?: SortOrder
    appoint_id?: SortOrder
    recurrence_id?: SortOrder
    appoint_date?: SortOrder
    appoint_time?: SortOrder
    instance_status?: SortOrder
  }

  export type recurring_instancesSumOrderByAggregateInput = {
    instance_id?: SortOrder
    appoint_id?: SortOrder
    recurrence_id?: SortOrder
  }

  export type Session_detailsListRelationFilter = {
    every?: session_detailsWhereInput
    some?: session_detailsWhereInput
    none?: session_detailsWhereInput
  }

  export type session_detailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionCountOrderByAggregateInput = {
    session_id?: SortOrder
    patient_id?: SortOrder
    staff_id?: SortOrder
    appoint_id?: SortOrder
  }

  export type sessionAvgOrderByAggregateInput = {
    session_id?: SortOrder
    patient_id?: SortOrder
    staff_id?: SortOrder
    appoint_id?: SortOrder
  }

  export type sessionMaxOrderByAggregateInput = {
    session_id?: SortOrder
    patient_id?: SortOrder
    staff_id?: SortOrder
    appoint_id?: SortOrder
  }

  export type sessionMinOrderByAggregateInput = {
    session_id?: SortOrder
    patient_id?: SortOrder
    staff_id?: SortOrder
    appoint_id?: SortOrder
  }

  export type sessionSumOrderByAggregateInput = {
    session_id?: SortOrder
    patient_id?: SortOrder
    staff_id?: SortOrder
    appoint_id?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type SessionScalarRelationFilter = {
    is?: sessionWhereInput
    isNot?: sessionWhereInput
  }

  export type session_detailsCountOrderByAggregateInput = {
    session_details_id?: SortOrder
    session_id?: SortOrder
    session_description?: SortOrder
    session_date?: SortOrder
    session_time?: SortOrder
    session_document?: SortOrder
  }

  export type session_detailsAvgOrderByAggregateInput = {
    session_details_id?: SortOrder
    session_id?: SortOrder
  }

  export type session_detailsMaxOrderByAggregateInput = {
    session_details_id?: SortOrder
    session_id?: SortOrder
    session_description?: SortOrder
    session_date?: SortOrder
    session_time?: SortOrder
    session_document?: SortOrder
  }

  export type session_detailsMinOrderByAggregateInput = {
    session_details_id?: SortOrder
    session_id?: SortOrder
    session_description?: SortOrder
    session_date?: SortOrder
    session_time?: SortOrder
    session_document?: SortOrder
  }

  export type session_detailsSumOrderByAggregateInput = {
    session_details_id?: SortOrder
    session_id?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type staff_roleCountOrderByAggregateInput = {
    staff_role_id?: SortOrder
    staff_id?: SortOrder
    staff_role?: SortOrder
  }

  export type staff_roleAvgOrderByAggregateInput = {
    staff_role_id?: SortOrder
    staff_id?: SortOrder
  }

  export type staff_roleMaxOrderByAggregateInput = {
    staff_role_id?: SortOrder
    staff_id?: SortOrder
    staff_role?: SortOrder
  }

  export type staff_roleMinOrderByAggregateInput = {
    staff_role_id?: SortOrder
    staff_id?: SortOrder
    staff_role?: SortOrder
  }

  export type staff_roleSumOrderByAggregateInput = {
    staff_role_id?: SortOrder
    staff_id?: SortOrder
  }

  export type type_of_paymentCountOrderByAggregateInput = {
    type_of_payment_id?: SortOrder
    type_of_payment?: SortOrder
  }

  export type type_of_paymentAvgOrderByAggregateInput = {
    type_of_payment_id?: SortOrder
  }

  export type type_of_paymentMaxOrderByAggregateInput = {
    type_of_payment_id?: SortOrder
    type_of_payment?: SortOrder
  }

  export type type_of_paymentMinOrderByAggregateInput = {
    type_of_payment_id?: SortOrder
    type_of_payment?: SortOrder
  }

  export type type_of_paymentSumOrderByAggregateInput = {
    type_of_payment_id?: SortOrder
  }

  export type user_contactsCountOrderByAggregateInput = {
    user_contact_id?: SortOrder
    user_id?: SortOrder
    user_email?: SortOrder
    user_contact_number?: SortOrder
  }

  export type user_contactsAvgOrderByAggregateInput = {
    user_contact_id?: SortOrder
    user_id?: SortOrder
  }

  export type user_contactsMaxOrderByAggregateInput = {
    user_contact_id?: SortOrder
    user_id?: SortOrder
    user_email?: SortOrder
    user_contact_number?: SortOrder
  }

  export type user_contactsMinOrderByAggregateInput = {
    user_contact_id?: SortOrder
    user_id?: SortOrder
    user_email?: SortOrder
    user_contact_number?: SortOrder
  }

  export type user_contactsSumOrderByAggregateInput = {
    user_contact_id?: SortOrder
    user_id?: SortOrder
  }

  export type PatientsListRelationFilter = {
    every?: patientsWhereInput
    some?: patientsWhereInput
    none?: patientsWhereInput
  }

  export type User_contactsListRelationFilter = {
    every?: user_contactsWhereInput
    some?: user_contactsWhereInput
    none?: user_contactsWhereInput
  }

  export type patientsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_contactsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    user_id?: SortOrder
    user_full_name?: SortOrder
    user_password?: SortOrder
    username?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    user_id?: SortOrder
    user_full_name?: SortOrder
    user_password?: SortOrder
    username?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    user_id?: SortOrder
    user_full_name?: SortOrder
    user_password?: SortOrder
    username?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type appointmentsCreateNestedManyWithoutAppointment_statusInput = {
    create?: XOR<appointmentsCreateWithoutAppointment_statusInput, appointmentsUncheckedCreateWithoutAppointment_statusInput> | appointmentsCreateWithoutAppointment_statusInput[] | appointmentsUncheckedCreateWithoutAppointment_statusInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutAppointment_statusInput | appointmentsCreateOrConnectWithoutAppointment_statusInput[]
    createMany?: appointmentsCreateManyAppointment_statusInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type appointmentsUncheckedCreateNestedManyWithoutAppointment_statusInput = {
    create?: XOR<appointmentsCreateWithoutAppointment_statusInput, appointmentsUncheckedCreateWithoutAppointment_statusInput> | appointmentsCreateWithoutAppointment_statusInput[] | appointmentsUncheckedCreateWithoutAppointment_statusInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutAppointment_statusInput | appointmentsCreateOrConnectWithoutAppointment_statusInput[]
    createMany?: appointmentsCreateManyAppointment_statusInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type appointmentsUpdateManyWithoutAppointment_statusNestedInput = {
    create?: XOR<appointmentsCreateWithoutAppointment_statusInput, appointmentsUncheckedCreateWithoutAppointment_statusInput> | appointmentsCreateWithoutAppointment_statusInput[] | appointmentsUncheckedCreateWithoutAppointment_statusInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutAppointment_statusInput | appointmentsCreateOrConnectWithoutAppointment_statusInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutAppointment_statusInput | appointmentsUpsertWithWhereUniqueWithoutAppointment_statusInput[]
    createMany?: appointmentsCreateManyAppointment_statusInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutAppointment_statusInput | appointmentsUpdateWithWhereUniqueWithoutAppointment_statusInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutAppointment_statusInput | appointmentsUpdateManyWithWhereWithoutAppointment_statusInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type appointmentsUncheckedUpdateManyWithoutAppointment_statusNestedInput = {
    create?: XOR<appointmentsCreateWithoutAppointment_statusInput, appointmentsUncheckedCreateWithoutAppointment_statusInput> | appointmentsCreateWithoutAppointment_statusInput[] | appointmentsUncheckedCreateWithoutAppointment_statusInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutAppointment_statusInput | appointmentsCreateOrConnectWithoutAppointment_statusInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutAppointment_statusInput | appointmentsUpsertWithWhereUniqueWithoutAppointment_statusInput[]
    createMany?: appointmentsCreateManyAppointment_statusInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutAppointment_statusInput | appointmentsUpdateWithWhereUniqueWithoutAppointment_statusInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutAppointment_statusInput | appointmentsUpdateManyWithWhereWithoutAppointment_statusInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type appointment_statusCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<appointment_statusCreateWithoutAppointmentsInput, appointment_statusUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: appointment_statusCreateOrConnectWithoutAppointmentsInput
    connect?: appointment_statusWhereUniqueInput
  }

  export type clinic_staffCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<clinic_staffCreateWithoutAppointmentsInput, clinic_staffUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: clinic_staffCreateOrConnectWithoutAppointmentsInput
    connect?: clinic_staffWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<usersCreateWithoutAppointmentsInput, usersUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAppointmentsInput
    connect?: usersWhereUniqueInput
  }

  export type patient_appointmentsCreateNestedManyWithoutAppointmentsInput = {
    create?: XOR<patient_appointmentsCreateWithoutAppointmentsInput, patient_appointmentsUncheckedCreateWithoutAppointmentsInput> | patient_appointmentsCreateWithoutAppointmentsInput[] | patient_appointmentsUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: patient_appointmentsCreateOrConnectWithoutAppointmentsInput | patient_appointmentsCreateOrConnectWithoutAppointmentsInput[]
    createMany?: patient_appointmentsCreateManyAppointmentsInputEnvelope
    connect?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
  }

  export type recurring_instancesCreateNestedManyWithoutAppointmentsInput = {
    create?: XOR<recurring_instancesCreateWithoutAppointmentsInput, recurring_instancesUncheckedCreateWithoutAppointmentsInput> | recurring_instancesCreateWithoutAppointmentsInput[] | recurring_instancesUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: recurring_instancesCreateOrConnectWithoutAppointmentsInput | recurring_instancesCreateOrConnectWithoutAppointmentsInput[]
    createMany?: recurring_instancesCreateManyAppointmentsInputEnvelope
    connect?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
  }

  export type sessionCreateNestedManyWithoutAppointmentsInput = {
    create?: XOR<sessionCreateWithoutAppointmentsInput, sessionUncheckedCreateWithoutAppointmentsInput> | sessionCreateWithoutAppointmentsInput[] | sessionUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutAppointmentsInput | sessionCreateOrConnectWithoutAppointmentsInput[]
    createMany?: sessionCreateManyAppointmentsInputEnvelope
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
  }

  export type patient_appointmentsUncheckedCreateNestedManyWithoutAppointmentsInput = {
    create?: XOR<patient_appointmentsCreateWithoutAppointmentsInput, patient_appointmentsUncheckedCreateWithoutAppointmentsInput> | patient_appointmentsCreateWithoutAppointmentsInput[] | patient_appointmentsUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: patient_appointmentsCreateOrConnectWithoutAppointmentsInput | patient_appointmentsCreateOrConnectWithoutAppointmentsInput[]
    createMany?: patient_appointmentsCreateManyAppointmentsInputEnvelope
    connect?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
  }

  export type recurring_instancesUncheckedCreateNestedManyWithoutAppointmentsInput = {
    create?: XOR<recurring_instancesCreateWithoutAppointmentsInput, recurring_instancesUncheckedCreateWithoutAppointmentsInput> | recurring_instancesCreateWithoutAppointmentsInput[] | recurring_instancesUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: recurring_instancesCreateOrConnectWithoutAppointmentsInput | recurring_instancesCreateOrConnectWithoutAppointmentsInput[]
    createMany?: recurring_instancesCreateManyAppointmentsInputEnvelope
    connect?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
  }

  export type sessionUncheckedCreateNestedManyWithoutAppointmentsInput = {
    create?: XOR<sessionCreateWithoutAppointmentsInput, sessionUncheckedCreateWithoutAppointmentsInput> | sessionCreateWithoutAppointmentsInput[] | sessionUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutAppointmentsInput | sessionCreateOrConnectWithoutAppointmentsInput[]
    createMany?: sessionCreateManyAppointmentsInputEnvelope
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type appointment_statusUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<appointment_statusCreateWithoutAppointmentsInput, appointment_statusUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: appointment_statusCreateOrConnectWithoutAppointmentsInput
    upsert?: appointment_statusUpsertWithoutAppointmentsInput
    disconnect?: appointment_statusWhereInput | boolean
    delete?: appointment_statusWhereInput | boolean
    connect?: appointment_statusWhereUniqueInput
    update?: XOR<XOR<appointment_statusUpdateToOneWithWhereWithoutAppointmentsInput, appointment_statusUpdateWithoutAppointmentsInput>, appointment_statusUncheckedUpdateWithoutAppointmentsInput>
  }

  export type clinic_staffUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<clinic_staffCreateWithoutAppointmentsInput, clinic_staffUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: clinic_staffCreateOrConnectWithoutAppointmentsInput
    upsert?: clinic_staffUpsertWithoutAppointmentsInput
    disconnect?: clinic_staffWhereInput | boolean
    delete?: clinic_staffWhereInput | boolean
    connect?: clinic_staffWhereUniqueInput
    update?: XOR<XOR<clinic_staffUpdateToOneWithWhereWithoutAppointmentsInput, clinic_staffUpdateWithoutAppointmentsInput>, clinic_staffUncheckedUpdateWithoutAppointmentsInput>
  }

  export type usersUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<usersCreateWithoutAppointmentsInput, usersUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAppointmentsInput
    upsert?: usersUpsertWithoutAppointmentsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAppointmentsInput, usersUpdateWithoutAppointmentsInput>, usersUncheckedUpdateWithoutAppointmentsInput>
  }

  export type patient_appointmentsUpdateManyWithoutAppointmentsNestedInput = {
    create?: XOR<patient_appointmentsCreateWithoutAppointmentsInput, patient_appointmentsUncheckedCreateWithoutAppointmentsInput> | patient_appointmentsCreateWithoutAppointmentsInput[] | patient_appointmentsUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: patient_appointmentsCreateOrConnectWithoutAppointmentsInput | patient_appointmentsCreateOrConnectWithoutAppointmentsInput[]
    upsert?: patient_appointmentsUpsertWithWhereUniqueWithoutAppointmentsInput | patient_appointmentsUpsertWithWhereUniqueWithoutAppointmentsInput[]
    createMany?: patient_appointmentsCreateManyAppointmentsInputEnvelope
    set?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    disconnect?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    delete?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    connect?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    update?: patient_appointmentsUpdateWithWhereUniqueWithoutAppointmentsInput | patient_appointmentsUpdateWithWhereUniqueWithoutAppointmentsInput[]
    updateMany?: patient_appointmentsUpdateManyWithWhereWithoutAppointmentsInput | patient_appointmentsUpdateManyWithWhereWithoutAppointmentsInput[]
    deleteMany?: patient_appointmentsScalarWhereInput | patient_appointmentsScalarWhereInput[]
  }

  export type recurring_instancesUpdateManyWithoutAppointmentsNestedInput = {
    create?: XOR<recurring_instancesCreateWithoutAppointmentsInput, recurring_instancesUncheckedCreateWithoutAppointmentsInput> | recurring_instancesCreateWithoutAppointmentsInput[] | recurring_instancesUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: recurring_instancesCreateOrConnectWithoutAppointmentsInput | recurring_instancesCreateOrConnectWithoutAppointmentsInput[]
    upsert?: recurring_instancesUpsertWithWhereUniqueWithoutAppointmentsInput | recurring_instancesUpsertWithWhereUniqueWithoutAppointmentsInput[]
    createMany?: recurring_instancesCreateManyAppointmentsInputEnvelope
    set?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    disconnect?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    delete?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    connect?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    update?: recurring_instancesUpdateWithWhereUniqueWithoutAppointmentsInput | recurring_instancesUpdateWithWhereUniqueWithoutAppointmentsInput[]
    updateMany?: recurring_instancesUpdateManyWithWhereWithoutAppointmentsInput | recurring_instancesUpdateManyWithWhereWithoutAppointmentsInput[]
    deleteMany?: recurring_instancesScalarWhereInput | recurring_instancesScalarWhereInput[]
  }

  export type sessionUpdateManyWithoutAppointmentsNestedInput = {
    create?: XOR<sessionCreateWithoutAppointmentsInput, sessionUncheckedCreateWithoutAppointmentsInput> | sessionCreateWithoutAppointmentsInput[] | sessionUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutAppointmentsInput | sessionCreateOrConnectWithoutAppointmentsInput[]
    upsert?: sessionUpsertWithWhereUniqueWithoutAppointmentsInput | sessionUpsertWithWhereUniqueWithoutAppointmentsInput[]
    createMany?: sessionCreateManyAppointmentsInputEnvelope
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    update?: sessionUpdateWithWhereUniqueWithoutAppointmentsInput | sessionUpdateWithWhereUniqueWithoutAppointmentsInput[]
    updateMany?: sessionUpdateManyWithWhereWithoutAppointmentsInput | sessionUpdateManyWithWhereWithoutAppointmentsInput[]
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type patient_appointmentsUncheckedUpdateManyWithoutAppointmentsNestedInput = {
    create?: XOR<patient_appointmentsCreateWithoutAppointmentsInput, patient_appointmentsUncheckedCreateWithoutAppointmentsInput> | patient_appointmentsCreateWithoutAppointmentsInput[] | patient_appointmentsUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: patient_appointmentsCreateOrConnectWithoutAppointmentsInput | patient_appointmentsCreateOrConnectWithoutAppointmentsInput[]
    upsert?: patient_appointmentsUpsertWithWhereUniqueWithoutAppointmentsInput | patient_appointmentsUpsertWithWhereUniqueWithoutAppointmentsInput[]
    createMany?: patient_appointmentsCreateManyAppointmentsInputEnvelope
    set?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    disconnect?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    delete?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    connect?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    update?: patient_appointmentsUpdateWithWhereUniqueWithoutAppointmentsInput | patient_appointmentsUpdateWithWhereUniqueWithoutAppointmentsInput[]
    updateMany?: patient_appointmentsUpdateManyWithWhereWithoutAppointmentsInput | patient_appointmentsUpdateManyWithWhereWithoutAppointmentsInput[]
    deleteMany?: patient_appointmentsScalarWhereInput | patient_appointmentsScalarWhereInput[]
  }

  export type recurring_instancesUncheckedUpdateManyWithoutAppointmentsNestedInput = {
    create?: XOR<recurring_instancesCreateWithoutAppointmentsInput, recurring_instancesUncheckedCreateWithoutAppointmentsInput> | recurring_instancesCreateWithoutAppointmentsInput[] | recurring_instancesUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: recurring_instancesCreateOrConnectWithoutAppointmentsInput | recurring_instancesCreateOrConnectWithoutAppointmentsInput[]
    upsert?: recurring_instancesUpsertWithWhereUniqueWithoutAppointmentsInput | recurring_instancesUpsertWithWhereUniqueWithoutAppointmentsInput[]
    createMany?: recurring_instancesCreateManyAppointmentsInputEnvelope
    set?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    disconnect?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    delete?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    connect?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    update?: recurring_instancesUpdateWithWhereUniqueWithoutAppointmentsInput | recurring_instancesUpdateWithWhereUniqueWithoutAppointmentsInput[]
    updateMany?: recurring_instancesUpdateManyWithWhereWithoutAppointmentsInput | recurring_instancesUpdateManyWithWhereWithoutAppointmentsInput[]
    deleteMany?: recurring_instancesScalarWhereInput | recurring_instancesScalarWhereInput[]
  }

  export type sessionUncheckedUpdateManyWithoutAppointmentsNestedInput = {
    create?: XOR<sessionCreateWithoutAppointmentsInput, sessionUncheckedCreateWithoutAppointmentsInput> | sessionCreateWithoutAppointmentsInput[] | sessionUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutAppointmentsInput | sessionCreateOrConnectWithoutAppointmentsInput[]
    upsert?: sessionUpsertWithWhereUniqueWithoutAppointmentsInput | sessionUpsertWithWhereUniqueWithoutAppointmentsInput[]
    createMany?: sessionCreateManyAppointmentsInputEnvelope
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    update?: sessionUpdateWithWhereUniqueWithoutAppointmentsInput | sessionUpdateWithWhereUniqueWithoutAppointmentsInput[]
    updateMany?: sessionUpdateManyWithWhereWithoutAppointmentsInput | sessionUpdateManyWithWhereWithoutAppointmentsInput[]
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[]
  }

  export type appointmentsCreateNestedManyWithoutClinic_staffInput = {
    create?: XOR<appointmentsCreateWithoutClinic_staffInput, appointmentsUncheckedCreateWithoutClinic_staffInput> | appointmentsCreateWithoutClinic_staffInput[] | appointmentsUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutClinic_staffInput | appointmentsCreateOrConnectWithoutClinic_staffInput[]
    createMany?: appointmentsCreateManyClinic_staffInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type clinic_staff_detailsCreateNestedManyWithoutClinic_staffInput = {
    create?: XOR<clinic_staff_detailsCreateWithoutClinic_staffInput, clinic_staff_detailsUncheckedCreateWithoutClinic_staffInput> | clinic_staff_detailsCreateWithoutClinic_staffInput[] | clinic_staff_detailsUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: clinic_staff_detailsCreateOrConnectWithoutClinic_staffInput | clinic_staff_detailsCreateOrConnectWithoutClinic_staffInput[]
    createMany?: clinic_staff_detailsCreateManyClinic_staffInputEnvelope
    connect?: clinic_staff_detailsWhereUniqueInput | clinic_staff_detailsWhereUniqueInput[]
  }

  export type sessionCreateNestedManyWithoutClinic_staffInput = {
    create?: XOR<sessionCreateWithoutClinic_staffInput, sessionUncheckedCreateWithoutClinic_staffInput> | sessionCreateWithoutClinic_staffInput[] | sessionUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutClinic_staffInput | sessionCreateOrConnectWithoutClinic_staffInput[]
    createMany?: sessionCreateManyClinic_staffInputEnvelope
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
  }

  export type staff_roleCreateNestedManyWithoutClinic_staffInput = {
    create?: XOR<staff_roleCreateWithoutClinic_staffInput, staff_roleUncheckedCreateWithoutClinic_staffInput> | staff_roleCreateWithoutClinic_staffInput[] | staff_roleUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: staff_roleCreateOrConnectWithoutClinic_staffInput | staff_roleCreateOrConnectWithoutClinic_staffInput[]
    createMany?: staff_roleCreateManyClinic_staffInputEnvelope
    connect?: staff_roleWhereUniqueInput | staff_roleWhereUniqueInput[]
  }

  export type appointmentsUncheckedCreateNestedManyWithoutClinic_staffInput = {
    create?: XOR<appointmentsCreateWithoutClinic_staffInput, appointmentsUncheckedCreateWithoutClinic_staffInput> | appointmentsCreateWithoutClinic_staffInput[] | appointmentsUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutClinic_staffInput | appointmentsCreateOrConnectWithoutClinic_staffInput[]
    createMany?: appointmentsCreateManyClinic_staffInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type clinic_staff_detailsUncheckedCreateNestedManyWithoutClinic_staffInput = {
    create?: XOR<clinic_staff_detailsCreateWithoutClinic_staffInput, clinic_staff_detailsUncheckedCreateWithoutClinic_staffInput> | clinic_staff_detailsCreateWithoutClinic_staffInput[] | clinic_staff_detailsUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: clinic_staff_detailsCreateOrConnectWithoutClinic_staffInput | clinic_staff_detailsCreateOrConnectWithoutClinic_staffInput[]
    createMany?: clinic_staff_detailsCreateManyClinic_staffInputEnvelope
    connect?: clinic_staff_detailsWhereUniqueInput | clinic_staff_detailsWhereUniqueInput[]
  }

  export type sessionUncheckedCreateNestedManyWithoutClinic_staffInput = {
    create?: XOR<sessionCreateWithoutClinic_staffInput, sessionUncheckedCreateWithoutClinic_staffInput> | sessionCreateWithoutClinic_staffInput[] | sessionUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutClinic_staffInput | sessionCreateOrConnectWithoutClinic_staffInput[]
    createMany?: sessionCreateManyClinic_staffInputEnvelope
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
  }

  export type staff_roleUncheckedCreateNestedManyWithoutClinic_staffInput = {
    create?: XOR<staff_roleCreateWithoutClinic_staffInput, staff_roleUncheckedCreateWithoutClinic_staffInput> | staff_roleCreateWithoutClinic_staffInput[] | staff_roleUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: staff_roleCreateOrConnectWithoutClinic_staffInput | staff_roleCreateOrConnectWithoutClinic_staffInput[]
    createMany?: staff_roleCreateManyClinic_staffInputEnvelope
    connect?: staff_roleWhereUniqueInput | staff_roleWhereUniqueInput[]
  }

  export type appointmentsUpdateManyWithoutClinic_staffNestedInput = {
    create?: XOR<appointmentsCreateWithoutClinic_staffInput, appointmentsUncheckedCreateWithoutClinic_staffInput> | appointmentsCreateWithoutClinic_staffInput[] | appointmentsUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutClinic_staffInput | appointmentsCreateOrConnectWithoutClinic_staffInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutClinic_staffInput | appointmentsUpsertWithWhereUniqueWithoutClinic_staffInput[]
    createMany?: appointmentsCreateManyClinic_staffInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutClinic_staffInput | appointmentsUpdateWithWhereUniqueWithoutClinic_staffInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutClinic_staffInput | appointmentsUpdateManyWithWhereWithoutClinic_staffInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type clinic_staff_detailsUpdateManyWithoutClinic_staffNestedInput = {
    create?: XOR<clinic_staff_detailsCreateWithoutClinic_staffInput, clinic_staff_detailsUncheckedCreateWithoutClinic_staffInput> | clinic_staff_detailsCreateWithoutClinic_staffInput[] | clinic_staff_detailsUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: clinic_staff_detailsCreateOrConnectWithoutClinic_staffInput | clinic_staff_detailsCreateOrConnectWithoutClinic_staffInput[]
    upsert?: clinic_staff_detailsUpsertWithWhereUniqueWithoutClinic_staffInput | clinic_staff_detailsUpsertWithWhereUniqueWithoutClinic_staffInput[]
    createMany?: clinic_staff_detailsCreateManyClinic_staffInputEnvelope
    set?: clinic_staff_detailsWhereUniqueInput | clinic_staff_detailsWhereUniqueInput[]
    disconnect?: clinic_staff_detailsWhereUniqueInput | clinic_staff_detailsWhereUniqueInput[]
    delete?: clinic_staff_detailsWhereUniqueInput | clinic_staff_detailsWhereUniqueInput[]
    connect?: clinic_staff_detailsWhereUniqueInput | clinic_staff_detailsWhereUniqueInput[]
    update?: clinic_staff_detailsUpdateWithWhereUniqueWithoutClinic_staffInput | clinic_staff_detailsUpdateWithWhereUniqueWithoutClinic_staffInput[]
    updateMany?: clinic_staff_detailsUpdateManyWithWhereWithoutClinic_staffInput | clinic_staff_detailsUpdateManyWithWhereWithoutClinic_staffInput[]
    deleteMany?: clinic_staff_detailsScalarWhereInput | clinic_staff_detailsScalarWhereInput[]
  }

  export type sessionUpdateManyWithoutClinic_staffNestedInput = {
    create?: XOR<sessionCreateWithoutClinic_staffInput, sessionUncheckedCreateWithoutClinic_staffInput> | sessionCreateWithoutClinic_staffInput[] | sessionUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutClinic_staffInput | sessionCreateOrConnectWithoutClinic_staffInput[]
    upsert?: sessionUpsertWithWhereUniqueWithoutClinic_staffInput | sessionUpsertWithWhereUniqueWithoutClinic_staffInput[]
    createMany?: sessionCreateManyClinic_staffInputEnvelope
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    update?: sessionUpdateWithWhereUniqueWithoutClinic_staffInput | sessionUpdateWithWhereUniqueWithoutClinic_staffInput[]
    updateMany?: sessionUpdateManyWithWhereWithoutClinic_staffInput | sessionUpdateManyWithWhereWithoutClinic_staffInput[]
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[]
  }

  export type staff_roleUpdateManyWithoutClinic_staffNestedInput = {
    create?: XOR<staff_roleCreateWithoutClinic_staffInput, staff_roleUncheckedCreateWithoutClinic_staffInput> | staff_roleCreateWithoutClinic_staffInput[] | staff_roleUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: staff_roleCreateOrConnectWithoutClinic_staffInput | staff_roleCreateOrConnectWithoutClinic_staffInput[]
    upsert?: staff_roleUpsertWithWhereUniqueWithoutClinic_staffInput | staff_roleUpsertWithWhereUniqueWithoutClinic_staffInput[]
    createMany?: staff_roleCreateManyClinic_staffInputEnvelope
    set?: staff_roleWhereUniqueInput | staff_roleWhereUniqueInput[]
    disconnect?: staff_roleWhereUniqueInput | staff_roleWhereUniqueInput[]
    delete?: staff_roleWhereUniqueInput | staff_roleWhereUniqueInput[]
    connect?: staff_roleWhereUniqueInput | staff_roleWhereUniqueInput[]
    update?: staff_roleUpdateWithWhereUniqueWithoutClinic_staffInput | staff_roleUpdateWithWhereUniqueWithoutClinic_staffInput[]
    updateMany?: staff_roleUpdateManyWithWhereWithoutClinic_staffInput | staff_roleUpdateManyWithWhereWithoutClinic_staffInput[]
    deleteMany?: staff_roleScalarWhereInput | staff_roleScalarWhereInput[]
  }

  export type appointmentsUncheckedUpdateManyWithoutClinic_staffNestedInput = {
    create?: XOR<appointmentsCreateWithoutClinic_staffInput, appointmentsUncheckedCreateWithoutClinic_staffInput> | appointmentsCreateWithoutClinic_staffInput[] | appointmentsUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutClinic_staffInput | appointmentsCreateOrConnectWithoutClinic_staffInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutClinic_staffInput | appointmentsUpsertWithWhereUniqueWithoutClinic_staffInput[]
    createMany?: appointmentsCreateManyClinic_staffInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutClinic_staffInput | appointmentsUpdateWithWhereUniqueWithoutClinic_staffInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutClinic_staffInput | appointmentsUpdateManyWithWhereWithoutClinic_staffInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type clinic_staff_detailsUncheckedUpdateManyWithoutClinic_staffNestedInput = {
    create?: XOR<clinic_staff_detailsCreateWithoutClinic_staffInput, clinic_staff_detailsUncheckedCreateWithoutClinic_staffInput> | clinic_staff_detailsCreateWithoutClinic_staffInput[] | clinic_staff_detailsUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: clinic_staff_detailsCreateOrConnectWithoutClinic_staffInput | clinic_staff_detailsCreateOrConnectWithoutClinic_staffInput[]
    upsert?: clinic_staff_detailsUpsertWithWhereUniqueWithoutClinic_staffInput | clinic_staff_detailsUpsertWithWhereUniqueWithoutClinic_staffInput[]
    createMany?: clinic_staff_detailsCreateManyClinic_staffInputEnvelope
    set?: clinic_staff_detailsWhereUniqueInput | clinic_staff_detailsWhereUniqueInput[]
    disconnect?: clinic_staff_detailsWhereUniqueInput | clinic_staff_detailsWhereUniqueInput[]
    delete?: clinic_staff_detailsWhereUniqueInput | clinic_staff_detailsWhereUniqueInput[]
    connect?: clinic_staff_detailsWhereUniqueInput | clinic_staff_detailsWhereUniqueInput[]
    update?: clinic_staff_detailsUpdateWithWhereUniqueWithoutClinic_staffInput | clinic_staff_detailsUpdateWithWhereUniqueWithoutClinic_staffInput[]
    updateMany?: clinic_staff_detailsUpdateManyWithWhereWithoutClinic_staffInput | clinic_staff_detailsUpdateManyWithWhereWithoutClinic_staffInput[]
    deleteMany?: clinic_staff_detailsScalarWhereInput | clinic_staff_detailsScalarWhereInput[]
  }

  export type sessionUncheckedUpdateManyWithoutClinic_staffNestedInput = {
    create?: XOR<sessionCreateWithoutClinic_staffInput, sessionUncheckedCreateWithoutClinic_staffInput> | sessionCreateWithoutClinic_staffInput[] | sessionUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutClinic_staffInput | sessionCreateOrConnectWithoutClinic_staffInput[]
    upsert?: sessionUpsertWithWhereUniqueWithoutClinic_staffInput | sessionUpsertWithWhereUniqueWithoutClinic_staffInput[]
    createMany?: sessionCreateManyClinic_staffInputEnvelope
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    update?: sessionUpdateWithWhereUniqueWithoutClinic_staffInput | sessionUpdateWithWhereUniqueWithoutClinic_staffInput[]
    updateMany?: sessionUpdateManyWithWhereWithoutClinic_staffInput | sessionUpdateManyWithWhereWithoutClinic_staffInput[]
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[]
  }

  export type staff_roleUncheckedUpdateManyWithoutClinic_staffNestedInput = {
    create?: XOR<staff_roleCreateWithoutClinic_staffInput, staff_roleUncheckedCreateWithoutClinic_staffInput> | staff_roleCreateWithoutClinic_staffInput[] | staff_roleUncheckedCreateWithoutClinic_staffInput[]
    connectOrCreate?: staff_roleCreateOrConnectWithoutClinic_staffInput | staff_roleCreateOrConnectWithoutClinic_staffInput[]
    upsert?: staff_roleUpsertWithWhereUniqueWithoutClinic_staffInput | staff_roleUpsertWithWhereUniqueWithoutClinic_staffInput[]
    createMany?: staff_roleCreateManyClinic_staffInputEnvelope
    set?: staff_roleWhereUniqueInput | staff_roleWhereUniqueInput[]
    disconnect?: staff_roleWhereUniqueInput | staff_roleWhereUniqueInput[]
    delete?: staff_roleWhereUniqueInput | staff_roleWhereUniqueInput[]
    connect?: staff_roleWhereUniqueInput | staff_roleWhereUniqueInput[]
    update?: staff_roleUpdateWithWhereUniqueWithoutClinic_staffInput | staff_roleUpdateWithWhereUniqueWithoutClinic_staffInput[]
    updateMany?: staff_roleUpdateManyWithWhereWithoutClinic_staffInput | staff_roleUpdateManyWithWhereWithoutClinic_staffInput[]
    deleteMany?: staff_roleScalarWhereInput | staff_roleScalarWhereInput[]
  }

  export type clinic_staffCreateNestedOneWithoutClinic_staff_detailsInput = {
    create?: XOR<clinic_staffCreateWithoutClinic_staff_detailsInput, clinic_staffUncheckedCreateWithoutClinic_staff_detailsInput>
    connectOrCreate?: clinic_staffCreateOrConnectWithoutClinic_staff_detailsInput
    connect?: clinic_staffWhereUniqueInput
  }

  export type clinic_staffUpdateOneRequiredWithoutClinic_staff_detailsNestedInput = {
    create?: XOR<clinic_staffCreateWithoutClinic_staff_detailsInput, clinic_staffUncheckedCreateWithoutClinic_staff_detailsInput>
    connectOrCreate?: clinic_staffCreateOrConnectWithoutClinic_staff_detailsInput
    upsert?: clinic_staffUpsertWithoutClinic_staff_detailsInput
    connect?: clinic_staffWhereUniqueInput
    update?: XOR<XOR<clinic_staffUpdateToOneWithWhereWithoutClinic_staff_detailsInput, clinic_staffUpdateWithoutClinic_staff_detailsInput>, clinic_staffUncheckedUpdateWithoutClinic_staff_detailsInput>
  }

  export type appointmentsCreateNestedOneWithoutPatient_appointmentsInput = {
    create?: XOR<appointmentsCreateWithoutPatient_appointmentsInput, appointmentsUncheckedCreateWithoutPatient_appointmentsInput>
    connectOrCreate?: appointmentsCreateOrConnectWithoutPatient_appointmentsInput
    connect?: appointmentsWhereUniqueInput
  }

  export type patientsCreateNestedOneWithoutPatient_appointmentsInput = {
    create?: XOR<patientsCreateWithoutPatient_appointmentsInput, patientsUncheckedCreateWithoutPatient_appointmentsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutPatient_appointmentsInput
    connect?: patientsWhereUniqueInput
  }

  export type appointmentsUpdateOneRequiredWithoutPatient_appointmentsNestedInput = {
    create?: XOR<appointmentsCreateWithoutPatient_appointmentsInput, appointmentsUncheckedCreateWithoutPatient_appointmentsInput>
    connectOrCreate?: appointmentsCreateOrConnectWithoutPatient_appointmentsInput
    upsert?: appointmentsUpsertWithoutPatient_appointmentsInput
    connect?: appointmentsWhereUniqueInput
    update?: XOR<XOR<appointmentsUpdateToOneWithWhereWithoutPatient_appointmentsInput, appointmentsUpdateWithoutPatient_appointmentsInput>, appointmentsUncheckedUpdateWithoutPatient_appointmentsInput>
  }

  export type patientsUpdateOneRequiredWithoutPatient_appointmentsNestedInput = {
    create?: XOR<patientsCreateWithoutPatient_appointmentsInput, patientsUncheckedCreateWithoutPatient_appointmentsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutPatient_appointmentsInput
    upsert?: patientsUpsertWithoutPatient_appointmentsInput
    connect?: patientsWhereUniqueInput
    update?: XOR<XOR<patientsUpdateToOneWithWhereWithoutPatient_appointmentsInput, patientsUpdateWithoutPatient_appointmentsInput>, patientsUncheckedUpdateWithoutPatient_appointmentsInput>
  }

  export type patient_conditionsCreateNestedOneWithoutOther_patient_conditionsInput = {
    create?: XOR<patient_conditionsCreateWithoutOther_patient_conditionsInput, patient_conditionsUncheckedCreateWithoutOther_patient_conditionsInput>
    connectOrCreate?: patient_conditionsCreateOrConnectWithoutOther_patient_conditionsInput
    connect?: patient_conditionsWhereUniqueInput
  }

  export type patient_conditionsCreateNestedOneWithoutPatient_conditionsInput = {
    create?: XOR<patient_conditionsCreateWithoutPatient_conditionsInput, patient_conditionsUncheckedCreateWithoutPatient_conditionsInput>
    connectOrCreate?: patient_conditionsCreateOrConnectWithoutPatient_conditionsInput
    connect?: patient_conditionsWhereUniqueInput
  }

  export type patient_conditionsUncheckedCreateNestedOneWithoutPatient_conditionsInput = {
    create?: XOR<patient_conditionsCreateWithoutPatient_conditionsInput, patient_conditionsUncheckedCreateWithoutPatient_conditionsInput>
    connectOrCreate?: patient_conditionsCreateOrConnectWithoutPatient_conditionsInput
    connect?: patient_conditionsWhereUniqueInput
  }

  export type patient_conditionsUpdateOneRequiredWithoutOther_patient_conditionsNestedInput = {
    create?: XOR<patient_conditionsCreateWithoutOther_patient_conditionsInput, patient_conditionsUncheckedCreateWithoutOther_patient_conditionsInput>
    connectOrCreate?: patient_conditionsCreateOrConnectWithoutOther_patient_conditionsInput
    upsert?: patient_conditionsUpsertWithoutOther_patient_conditionsInput
    connect?: patient_conditionsWhereUniqueInput
    update?: XOR<XOR<patient_conditionsUpdateToOneWithWhereWithoutOther_patient_conditionsInput, patient_conditionsUpdateWithoutOther_patient_conditionsInput>, patient_conditionsUncheckedUpdateWithoutOther_patient_conditionsInput>
  }

  export type patient_conditionsUpdateOneWithoutPatient_conditionsNestedInput = {
    create?: XOR<patient_conditionsCreateWithoutPatient_conditionsInput, patient_conditionsUncheckedCreateWithoutPatient_conditionsInput>
    connectOrCreate?: patient_conditionsCreateOrConnectWithoutPatient_conditionsInput
    upsert?: patient_conditionsUpsertWithoutPatient_conditionsInput
    disconnect?: patient_conditionsWhereInput | boolean
    delete?: patient_conditionsWhereInput | boolean
    connect?: patient_conditionsWhereUniqueInput
    update?: XOR<XOR<patient_conditionsUpdateToOneWithWhereWithoutPatient_conditionsInput, patient_conditionsUpdateWithoutPatient_conditionsInput>, patient_conditionsUncheckedUpdateWithoutPatient_conditionsInput>
  }

  export type patient_conditionsUncheckedUpdateOneWithoutPatient_conditionsNestedInput = {
    create?: XOR<patient_conditionsCreateWithoutPatient_conditionsInput, patient_conditionsUncheckedCreateWithoutPatient_conditionsInput>
    connectOrCreate?: patient_conditionsCreateOrConnectWithoutPatient_conditionsInput
    upsert?: patient_conditionsUpsertWithoutPatient_conditionsInput
    disconnect?: patient_conditionsWhereInput | boolean
    delete?: patient_conditionsWhereInput | boolean
    connect?: patient_conditionsWhereUniqueInput
    update?: XOR<XOR<patient_conditionsUpdateToOneWithWhereWithoutPatient_conditionsInput, patient_conditionsUpdateWithoutPatient_conditionsInput>, patient_conditionsUncheckedUpdateWithoutPatient_conditionsInput>
  }

  export type patientsCreateNestedOneWithoutPatient_detailsInput = {
    create?: XOR<patientsCreateWithoutPatient_detailsInput, patientsUncheckedCreateWithoutPatient_detailsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutPatient_detailsInput
    connect?: patientsWhereUniqueInput
  }

  export type patientsUpdateOneRequiredWithoutPatient_detailsNestedInput = {
    create?: XOR<patientsCreateWithoutPatient_detailsInput, patientsUncheckedCreateWithoutPatient_detailsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutPatient_detailsInput
    upsert?: patientsUpsertWithoutPatient_detailsInput
    connect?: patientsWhereUniqueInput
    update?: XOR<XOR<patientsUpdateToOneWithWhereWithoutPatient_detailsInput, patientsUpdateWithoutPatient_detailsInput>, patientsUncheckedUpdateWithoutPatient_detailsInput>
  }

  export type patient_appointmentsCreateNestedManyWithoutPatientsInput = {
    create?: XOR<patient_appointmentsCreateWithoutPatientsInput, patient_appointmentsUncheckedCreateWithoutPatientsInput> | patient_appointmentsCreateWithoutPatientsInput[] | patient_appointmentsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: patient_appointmentsCreateOrConnectWithoutPatientsInput | patient_appointmentsCreateOrConnectWithoutPatientsInput[]
    createMany?: patient_appointmentsCreateManyPatientsInputEnvelope
    connect?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
  }

  export type patient_detailsCreateNestedManyWithoutPatientsInput = {
    create?: XOR<patient_detailsCreateWithoutPatientsInput, patient_detailsUncheckedCreateWithoutPatientsInput> | patient_detailsCreateWithoutPatientsInput[] | patient_detailsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: patient_detailsCreateOrConnectWithoutPatientsInput | patient_detailsCreateOrConnectWithoutPatientsInput[]
    createMany?: patient_detailsCreateManyPatientsInputEnvelope
    connect?: patient_detailsWhereUniqueInput | patient_detailsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutPatientsInput = {
    create?: XOR<usersCreateWithoutPatientsInput, usersUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPatientsInput
    connect?: usersWhereUniqueInput
  }

  export type sessionCreateNestedManyWithoutPatientsInput = {
    create?: XOR<sessionCreateWithoutPatientsInput, sessionUncheckedCreateWithoutPatientsInput> | sessionCreateWithoutPatientsInput[] | sessionUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutPatientsInput | sessionCreateOrConnectWithoutPatientsInput[]
    createMany?: sessionCreateManyPatientsInputEnvelope
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
  }

  export type patient_appointmentsUncheckedCreateNestedManyWithoutPatientsInput = {
    create?: XOR<patient_appointmentsCreateWithoutPatientsInput, patient_appointmentsUncheckedCreateWithoutPatientsInput> | patient_appointmentsCreateWithoutPatientsInput[] | patient_appointmentsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: patient_appointmentsCreateOrConnectWithoutPatientsInput | patient_appointmentsCreateOrConnectWithoutPatientsInput[]
    createMany?: patient_appointmentsCreateManyPatientsInputEnvelope
    connect?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
  }

  export type patient_detailsUncheckedCreateNestedManyWithoutPatientsInput = {
    create?: XOR<patient_detailsCreateWithoutPatientsInput, patient_detailsUncheckedCreateWithoutPatientsInput> | patient_detailsCreateWithoutPatientsInput[] | patient_detailsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: patient_detailsCreateOrConnectWithoutPatientsInput | patient_detailsCreateOrConnectWithoutPatientsInput[]
    createMany?: patient_detailsCreateManyPatientsInputEnvelope
    connect?: patient_detailsWhereUniqueInput | patient_detailsWhereUniqueInput[]
  }

  export type sessionUncheckedCreateNestedManyWithoutPatientsInput = {
    create?: XOR<sessionCreateWithoutPatientsInput, sessionUncheckedCreateWithoutPatientsInput> | sessionCreateWithoutPatientsInput[] | sessionUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutPatientsInput | sessionCreateOrConnectWithoutPatientsInput[]
    createMany?: sessionCreateManyPatientsInputEnvelope
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
  }

  export type patient_appointmentsUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<patient_appointmentsCreateWithoutPatientsInput, patient_appointmentsUncheckedCreateWithoutPatientsInput> | patient_appointmentsCreateWithoutPatientsInput[] | patient_appointmentsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: patient_appointmentsCreateOrConnectWithoutPatientsInput | patient_appointmentsCreateOrConnectWithoutPatientsInput[]
    upsert?: patient_appointmentsUpsertWithWhereUniqueWithoutPatientsInput | patient_appointmentsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: patient_appointmentsCreateManyPatientsInputEnvelope
    set?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    disconnect?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    delete?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    connect?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    update?: patient_appointmentsUpdateWithWhereUniqueWithoutPatientsInput | patient_appointmentsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: patient_appointmentsUpdateManyWithWhereWithoutPatientsInput | patient_appointmentsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: patient_appointmentsScalarWhereInput | patient_appointmentsScalarWhereInput[]
  }

  export type patient_detailsUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<patient_detailsCreateWithoutPatientsInput, patient_detailsUncheckedCreateWithoutPatientsInput> | patient_detailsCreateWithoutPatientsInput[] | patient_detailsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: patient_detailsCreateOrConnectWithoutPatientsInput | patient_detailsCreateOrConnectWithoutPatientsInput[]
    upsert?: patient_detailsUpsertWithWhereUniqueWithoutPatientsInput | patient_detailsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: patient_detailsCreateManyPatientsInputEnvelope
    set?: patient_detailsWhereUniqueInput | patient_detailsWhereUniqueInput[]
    disconnect?: patient_detailsWhereUniqueInput | patient_detailsWhereUniqueInput[]
    delete?: patient_detailsWhereUniqueInput | patient_detailsWhereUniqueInput[]
    connect?: patient_detailsWhereUniqueInput | patient_detailsWhereUniqueInput[]
    update?: patient_detailsUpdateWithWhereUniqueWithoutPatientsInput | patient_detailsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: patient_detailsUpdateManyWithWhereWithoutPatientsInput | patient_detailsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: patient_detailsScalarWhereInput | patient_detailsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<usersCreateWithoutPatientsInput, usersUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPatientsInput
    upsert?: usersUpsertWithoutPatientsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPatientsInput, usersUpdateWithoutPatientsInput>, usersUncheckedUpdateWithoutPatientsInput>
  }

  export type sessionUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<sessionCreateWithoutPatientsInput, sessionUncheckedCreateWithoutPatientsInput> | sessionCreateWithoutPatientsInput[] | sessionUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutPatientsInput | sessionCreateOrConnectWithoutPatientsInput[]
    upsert?: sessionUpsertWithWhereUniqueWithoutPatientsInput | sessionUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: sessionCreateManyPatientsInputEnvelope
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    update?: sessionUpdateWithWhereUniqueWithoutPatientsInput | sessionUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: sessionUpdateManyWithWhereWithoutPatientsInput | sessionUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[]
  }

  export type patient_appointmentsUncheckedUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<patient_appointmentsCreateWithoutPatientsInput, patient_appointmentsUncheckedCreateWithoutPatientsInput> | patient_appointmentsCreateWithoutPatientsInput[] | patient_appointmentsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: patient_appointmentsCreateOrConnectWithoutPatientsInput | patient_appointmentsCreateOrConnectWithoutPatientsInput[]
    upsert?: patient_appointmentsUpsertWithWhereUniqueWithoutPatientsInput | patient_appointmentsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: patient_appointmentsCreateManyPatientsInputEnvelope
    set?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    disconnect?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    delete?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    connect?: patient_appointmentsWhereUniqueInput | patient_appointmentsWhereUniqueInput[]
    update?: patient_appointmentsUpdateWithWhereUniqueWithoutPatientsInput | patient_appointmentsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: patient_appointmentsUpdateManyWithWhereWithoutPatientsInput | patient_appointmentsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: patient_appointmentsScalarWhereInput | patient_appointmentsScalarWhereInput[]
  }

  export type patient_detailsUncheckedUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<patient_detailsCreateWithoutPatientsInput, patient_detailsUncheckedCreateWithoutPatientsInput> | patient_detailsCreateWithoutPatientsInput[] | patient_detailsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: patient_detailsCreateOrConnectWithoutPatientsInput | patient_detailsCreateOrConnectWithoutPatientsInput[]
    upsert?: patient_detailsUpsertWithWhereUniqueWithoutPatientsInput | patient_detailsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: patient_detailsCreateManyPatientsInputEnvelope
    set?: patient_detailsWhereUniqueInput | patient_detailsWhereUniqueInput[]
    disconnect?: patient_detailsWhereUniqueInput | patient_detailsWhereUniqueInput[]
    delete?: patient_detailsWhereUniqueInput | patient_detailsWhereUniqueInput[]
    connect?: patient_detailsWhereUniqueInput | patient_detailsWhereUniqueInput[]
    update?: patient_detailsUpdateWithWhereUniqueWithoutPatientsInput | patient_detailsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: patient_detailsUpdateManyWithWhereWithoutPatientsInput | patient_detailsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: patient_detailsScalarWhereInput | patient_detailsScalarWhereInput[]
  }

  export type sessionUncheckedUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<sessionCreateWithoutPatientsInput, sessionUncheckedCreateWithoutPatientsInput> | sessionCreateWithoutPatientsInput[] | sessionUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: sessionCreateOrConnectWithoutPatientsInput | sessionCreateOrConnectWithoutPatientsInput[]
    upsert?: sessionUpsertWithWhereUniqueWithoutPatientsInput | sessionUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: sessionCreateManyPatientsInputEnvelope
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[]
    update?: sessionUpdateWithWhereUniqueWithoutPatientsInput | sessionUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: sessionUpdateManyWithWhereWithoutPatientsInput | sessionUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[]
  }

  export type recurring_instancesCreateNestedManyWithoutRecurrenceInput = {
    create?: XOR<recurring_instancesCreateWithoutRecurrenceInput, recurring_instancesUncheckedCreateWithoutRecurrenceInput> | recurring_instancesCreateWithoutRecurrenceInput[] | recurring_instancesUncheckedCreateWithoutRecurrenceInput[]
    connectOrCreate?: recurring_instancesCreateOrConnectWithoutRecurrenceInput | recurring_instancesCreateOrConnectWithoutRecurrenceInput[]
    createMany?: recurring_instancesCreateManyRecurrenceInputEnvelope
    connect?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
  }

  export type recurring_instancesUncheckedCreateNestedManyWithoutRecurrenceInput = {
    create?: XOR<recurring_instancesCreateWithoutRecurrenceInput, recurring_instancesUncheckedCreateWithoutRecurrenceInput> | recurring_instancesCreateWithoutRecurrenceInput[] | recurring_instancesUncheckedCreateWithoutRecurrenceInput[]
    connectOrCreate?: recurring_instancesCreateOrConnectWithoutRecurrenceInput | recurring_instancesCreateOrConnectWithoutRecurrenceInput[]
    createMany?: recurring_instancesCreateManyRecurrenceInputEnvelope
    connect?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
  }

  export type recurring_instancesUpdateManyWithoutRecurrenceNestedInput = {
    create?: XOR<recurring_instancesCreateWithoutRecurrenceInput, recurring_instancesUncheckedCreateWithoutRecurrenceInput> | recurring_instancesCreateWithoutRecurrenceInput[] | recurring_instancesUncheckedCreateWithoutRecurrenceInput[]
    connectOrCreate?: recurring_instancesCreateOrConnectWithoutRecurrenceInput | recurring_instancesCreateOrConnectWithoutRecurrenceInput[]
    upsert?: recurring_instancesUpsertWithWhereUniqueWithoutRecurrenceInput | recurring_instancesUpsertWithWhereUniqueWithoutRecurrenceInput[]
    createMany?: recurring_instancesCreateManyRecurrenceInputEnvelope
    set?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    disconnect?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    delete?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    connect?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    update?: recurring_instancesUpdateWithWhereUniqueWithoutRecurrenceInput | recurring_instancesUpdateWithWhereUniqueWithoutRecurrenceInput[]
    updateMany?: recurring_instancesUpdateManyWithWhereWithoutRecurrenceInput | recurring_instancesUpdateManyWithWhereWithoutRecurrenceInput[]
    deleteMany?: recurring_instancesScalarWhereInput | recurring_instancesScalarWhereInput[]
  }

  export type recurring_instancesUncheckedUpdateManyWithoutRecurrenceNestedInput = {
    create?: XOR<recurring_instancesCreateWithoutRecurrenceInput, recurring_instancesUncheckedCreateWithoutRecurrenceInput> | recurring_instancesCreateWithoutRecurrenceInput[] | recurring_instancesUncheckedCreateWithoutRecurrenceInput[]
    connectOrCreate?: recurring_instancesCreateOrConnectWithoutRecurrenceInput | recurring_instancesCreateOrConnectWithoutRecurrenceInput[]
    upsert?: recurring_instancesUpsertWithWhereUniqueWithoutRecurrenceInput | recurring_instancesUpsertWithWhereUniqueWithoutRecurrenceInput[]
    createMany?: recurring_instancesCreateManyRecurrenceInputEnvelope
    set?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    disconnect?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    delete?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    connect?: recurring_instancesWhereUniqueInput | recurring_instancesWhereUniqueInput[]
    update?: recurring_instancesUpdateWithWhereUniqueWithoutRecurrenceInput | recurring_instancesUpdateWithWhereUniqueWithoutRecurrenceInput[]
    updateMany?: recurring_instancesUpdateManyWithWhereWithoutRecurrenceInput | recurring_instancesUpdateManyWithWhereWithoutRecurrenceInput[]
    deleteMany?: recurring_instancesScalarWhereInput | recurring_instancesScalarWhereInput[]
  }

  export type appointmentsCreateNestedOneWithoutRecurring_instancesInput = {
    create?: XOR<appointmentsCreateWithoutRecurring_instancesInput, appointmentsUncheckedCreateWithoutRecurring_instancesInput>
    connectOrCreate?: appointmentsCreateOrConnectWithoutRecurring_instancesInput
    connect?: appointmentsWhereUniqueInput
  }

  export type recurrenceCreateNestedOneWithoutRecurring_instancesInput = {
    create?: XOR<recurrenceCreateWithoutRecurring_instancesInput, recurrenceUncheckedCreateWithoutRecurring_instancesInput>
    connectOrCreate?: recurrenceCreateOrConnectWithoutRecurring_instancesInput
    connect?: recurrenceWhereUniqueInput
  }

  export type appointmentsUpdateOneRequiredWithoutRecurring_instancesNestedInput = {
    create?: XOR<appointmentsCreateWithoutRecurring_instancesInput, appointmentsUncheckedCreateWithoutRecurring_instancesInput>
    connectOrCreate?: appointmentsCreateOrConnectWithoutRecurring_instancesInput
    upsert?: appointmentsUpsertWithoutRecurring_instancesInput
    connect?: appointmentsWhereUniqueInput
    update?: XOR<XOR<appointmentsUpdateToOneWithWhereWithoutRecurring_instancesInput, appointmentsUpdateWithoutRecurring_instancesInput>, appointmentsUncheckedUpdateWithoutRecurring_instancesInput>
  }

  export type recurrenceUpdateOneRequiredWithoutRecurring_instancesNestedInput = {
    create?: XOR<recurrenceCreateWithoutRecurring_instancesInput, recurrenceUncheckedCreateWithoutRecurring_instancesInput>
    connectOrCreate?: recurrenceCreateOrConnectWithoutRecurring_instancesInput
    upsert?: recurrenceUpsertWithoutRecurring_instancesInput
    connect?: recurrenceWhereUniqueInput
    update?: XOR<XOR<recurrenceUpdateToOneWithWhereWithoutRecurring_instancesInput, recurrenceUpdateWithoutRecurring_instancesInput>, recurrenceUncheckedUpdateWithoutRecurring_instancesInput>
  }

  export type appointmentsCreateNestedOneWithoutSessionInput = {
    create?: XOR<appointmentsCreateWithoutSessionInput, appointmentsUncheckedCreateWithoutSessionInput>
    connectOrCreate?: appointmentsCreateOrConnectWithoutSessionInput
    connect?: appointmentsWhereUniqueInput
  }

  export type patientsCreateNestedOneWithoutSessionInput = {
    create?: XOR<patientsCreateWithoutSessionInput, patientsUncheckedCreateWithoutSessionInput>
    connectOrCreate?: patientsCreateOrConnectWithoutSessionInput
    connect?: patientsWhereUniqueInput
  }

  export type clinic_staffCreateNestedOneWithoutSessionInput = {
    create?: XOR<clinic_staffCreateWithoutSessionInput, clinic_staffUncheckedCreateWithoutSessionInput>
    connectOrCreate?: clinic_staffCreateOrConnectWithoutSessionInput
    connect?: clinic_staffWhereUniqueInput
  }

  export type session_detailsCreateNestedManyWithoutSessionInput = {
    create?: XOR<session_detailsCreateWithoutSessionInput, session_detailsUncheckedCreateWithoutSessionInput> | session_detailsCreateWithoutSessionInput[] | session_detailsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: session_detailsCreateOrConnectWithoutSessionInput | session_detailsCreateOrConnectWithoutSessionInput[]
    createMany?: session_detailsCreateManySessionInputEnvelope
    connect?: session_detailsWhereUniqueInput | session_detailsWhereUniqueInput[]
  }

  export type session_detailsUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<session_detailsCreateWithoutSessionInput, session_detailsUncheckedCreateWithoutSessionInput> | session_detailsCreateWithoutSessionInput[] | session_detailsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: session_detailsCreateOrConnectWithoutSessionInput | session_detailsCreateOrConnectWithoutSessionInput[]
    createMany?: session_detailsCreateManySessionInputEnvelope
    connect?: session_detailsWhereUniqueInput | session_detailsWhereUniqueInput[]
  }

  export type appointmentsUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<appointmentsCreateWithoutSessionInput, appointmentsUncheckedCreateWithoutSessionInput>
    connectOrCreate?: appointmentsCreateOrConnectWithoutSessionInput
    upsert?: appointmentsUpsertWithoutSessionInput
    connect?: appointmentsWhereUniqueInput
    update?: XOR<XOR<appointmentsUpdateToOneWithWhereWithoutSessionInput, appointmentsUpdateWithoutSessionInput>, appointmentsUncheckedUpdateWithoutSessionInput>
  }

  export type patientsUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<patientsCreateWithoutSessionInput, patientsUncheckedCreateWithoutSessionInput>
    connectOrCreate?: patientsCreateOrConnectWithoutSessionInput
    upsert?: patientsUpsertWithoutSessionInput
    connect?: patientsWhereUniqueInput
    update?: XOR<XOR<patientsUpdateToOneWithWhereWithoutSessionInput, patientsUpdateWithoutSessionInput>, patientsUncheckedUpdateWithoutSessionInput>
  }

  export type clinic_staffUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<clinic_staffCreateWithoutSessionInput, clinic_staffUncheckedCreateWithoutSessionInput>
    connectOrCreate?: clinic_staffCreateOrConnectWithoutSessionInput
    upsert?: clinic_staffUpsertWithoutSessionInput
    connect?: clinic_staffWhereUniqueInput
    update?: XOR<XOR<clinic_staffUpdateToOneWithWhereWithoutSessionInput, clinic_staffUpdateWithoutSessionInput>, clinic_staffUncheckedUpdateWithoutSessionInput>
  }

  export type session_detailsUpdateManyWithoutSessionNestedInput = {
    create?: XOR<session_detailsCreateWithoutSessionInput, session_detailsUncheckedCreateWithoutSessionInput> | session_detailsCreateWithoutSessionInput[] | session_detailsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: session_detailsCreateOrConnectWithoutSessionInput | session_detailsCreateOrConnectWithoutSessionInput[]
    upsert?: session_detailsUpsertWithWhereUniqueWithoutSessionInput | session_detailsUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: session_detailsCreateManySessionInputEnvelope
    set?: session_detailsWhereUniqueInput | session_detailsWhereUniqueInput[]
    disconnect?: session_detailsWhereUniqueInput | session_detailsWhereUniqueInput[]
    delete?: session_detailsWhereUniqueInput | session_detailsWhereUniqueInput[]
    connect?: session_detailsWhereUniqueInput | session_detailsWhereUniqueInput[]
    update?: session_detailsUpdateWithWhereUniqueWithoutSessionInput | session_detailsUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: session_detailsUpdateManyWithWhereWithoutSessionInput | session_detailsUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: session_detailsScalarWhereInput | session_detailsScalarWhereInput[]
  }

  export type session_detailsUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<session_detailsCreateWithoutSessionInput, session_detailsUncheckedCreateWithoutSessionInput> | session_detailsCreateWithoutSessionInput[] | session_detailsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: session_detailsCreateOrConnectWithoutSessionInput | session_detailsCreateOrConnectWithoutSessionInput[]
    upsert?: session_detailsUpsertWithWhereUniqueWithoutSessionInput | session_detailsUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: session_detailsCreateManySessionInputEnvelope
    set?: session_detailsWhereUniqueInput | session_detailsWhereUniqueInput[]
    disconnect?: session_detailsWhereUniqueInput | session_detailsWhereUniqueInput[]
    delete?: session_detailsWhereUniqueInput | session_detailsWhereUniqueInput[]
    connect?: session_detailsWhereUniqueInput | session_detailsWhereUniqueInput[]
    update?: session_detailsUpdateWithWhereUniqueWithoutSessionInput | session_detailsUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: session_detailsUpdateManyWithWhereWithoutSessionInput | session_detailsUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: session_detailsScalarWhereInput | session_detailsScalarWhereInput[]
  }

  export type sessionCreateNestedOneWithoutSession_detailsInput = {
    create?: XOR<sessionCreateWithoutSession_detailsInput, sessionUncheckedCreateWithoutSession_detailsInput>
    connectOrCreate?: sessionCreateOrConnectWithoutSession_detailsInput
    connect?: sessionWhereUniqueInput
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type sessionUpdateOneRequiredWithoutSession_detailsNestedInput = {
    create?: XOR<sessionCreateWithoutSession_detailsInput, sessionUncheckedCreateWithoutSession_detailsInput>
    connectOrCreate?: sessionCreateOrConnectWithoutSession_detailsInput
    upsert?: sessionUpsertWithoutSession_detailsInput
    connect?: sessionWhereUniqueInput
    update?: XOR<XOR<sessionUpdateToOneWithWhereWithoutSession_detailsInput, sessionUpdateWithoutSession_detailsInput>, sessionUncheckedUpdateWithoutSession_detailsInput>
  }

  export type clinic_staffCreateNestedOneWithoutStaff_roleInput = {
    create?: XOR<clinic_staffCreateWithoutStaff_roleInput, clinic_staffUncheckedCreateWithoutStaff_roleInput>
    connectOrCreate?: clinic_staffCreateOrConnectWithoutStaff_roleInput
    connect?: clinic_staffWhereUniqueInput
  }

  export type clinic_staffUpdateOneRequiredWithoutStaff_roleNestedInput = {
    create?: XOR<clinic_staffCreateWithoutStaff_roleInput, clinic_staffUncheckedCreateWithoutStaff_roleInput>
    connectOrCreate?: clinic_staffCreateOrConnectWithoutStaff_roleInput
    upsert?: clinic_staffUpsertWithoutStaff_roleInput
    connect?: clinic_staffWhereUniqueInput
    update?: XOR<XOR<clinic_staffUpdateToOneWithWhereWithoutStaff_roleInput, clinic_staffUpdateWithoutStaff_roleInput>, clinic_staffUncheckedUpdateWithoutStaff_roleInput>
  }

  export type usersCreateNestedOneWithoutUser_contactsInput = {
    create?: XOR<usersCreateWithoutUser_contactsInput, usersUncheckedCreateWithoutUser_contactsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_contactsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUser_contactsNestedInput = {
    create?: XOR<usersCreateWithoutUser_contactsInput, usersUncheckedCreateWithoutUser_contactsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_contactsInput
    upsert?: usersUpsertWithoutUser_contactsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_contactsInput, usersUpdateWithoutUser_contactsInput>, usersUncheckedUpdateWithoutUser_contactsInput>
  }

  export type appointmentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<appointmentsCreateWithoutUsersInput, appointmentsUncheckedCreateWithoutUsersInput> | appointmentsCreateWithoutUsersInput[] | appointmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutUsersInput | appointmentsCreateOrConnectWithoutUsersInput[]
    createMany?: appointmentsCreateManyUsersInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type patientsCreateNestedManyWithoutUsersInput = {
    create?: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput> | patientsCreateWithoutUsersInput[] | patientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: patientsCreateOrConnectWithoutUsersInput | patientsCreateOrConnectWithoutUsersInput[]
    createMany?: patientsCreateManyUsersInputEnvelope
    connect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
  }

  export type user_contactsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_contactsCreateWithoutUsersInput, user_contactsUncheckedCreateWithoutUsersInput> | user_contactsCreateWithoutUsersInput[] | user_contactsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_contactsCreateOrConnectWithoutUsersInput | user_contactsCreateOrConnectWithoutUsersInput[]
    createMany?: user_contactsCreateManyUsersInputEnvelope
    connect?: user_contactsWhereUniqueInput | user_contactsWhereUniqueInput[]
  }

  export type appointmentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<appointmentsCreateWithoutUsersInput, appointmentsUncheckedCreateWithoutUsersInput> | appointmentsCreateWithoutUsersInput[] | appointmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutUsersInput | appointmentsCreateOrConnectWithoutUsersInput[]
    createMany?: appointmentsCreateManyUsersInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type patientsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput> | patientsCreateWithoutUsersInput[] | patientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: patientsCreateOrConnectWithoutUsersInput | patientsCreateOrConnectWithoutUsersInput[]
    createMany?: patientsCreateManyUsersInputEnvelope
    connect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
  }

  export type user_contactsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_contactsCreateWithoutUsersInput, user_contactsUncheckedCreateWithoutUsersInput> | user_contactsCreateWithoutUsersInput[] | user_contactsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_contactsCreateOrConnectWithoutUsersInput | user_contactsCreateOrConnectWithoutUsersInput[]
    createMany?: user_contactsCreateManyUsersInputEnvelope
    connect?: user_contactsWhereUniqueInput | user_contactsWhereUniqueInput[]
  }

  export type appointmentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<appointmentsCreateWithoutUsersInput, appointmentsUncheckedCreateWithoutUsersInput> | appointmentsCreateWithoutUsersInput[] | appointmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutUsersInput | appointmentsCreateOrConnectWithoutUsersInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutUsersInput | appointmentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: appointmentsCreateManyUsersInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutUsersInput | appointmentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutUsersInput | appointmentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type patientsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput> | patientsCreateWithoutUsersInput[] | patientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: patientsCreateOrConnectWithoutUsersInput | patientsCreateOrConnectWithoutUsersInput[]
    upsert?: patientsUpsertWithWhereUniqueWithoutUsersInput | patientsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: patientsCreateManyUsersInputEnvelope
    set?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    disconnect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    delete?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    connect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    update?: patientsUpdateWithWhereUniqueWithoutUsersInput | patientsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: patientsUpdateManyWithWhereWithoutUsersInput | patientsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: patientsScalarWhereInput | patientsScalarWhereInput[]
  }

  export type user_contactsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_contactsCreateWithoutUsersInput, user_contactsUncheckedCreateWithoutUsersInput> | user_contactsCreateWithoutUsersInput[] | user_contactsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_contactsCreateOrConnectWithoutUsersInput | user_contactsCreateOrConnectWithoutUsersInput[]
    upsert?: user_contactsUpsertWithWhereUniqueWithoutUsersInput | user_contactsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_contactsCreateManyUsersInputEnvelope
    set?: user_contactsWhereUniqueInput | user_contactsWhereUniqueInput[]
    disconnect?: user_contactsWhereUniqueInput | user_contactsWhereUniqueInput[]
    delete?: user_contactsWhereUniqueInput | user_contactsWhereUniqueInput[]
    connect?: user_contactsWhereUniqueInput | user_contactsWhereUniqueInput[]
    update?: user_contactsUpdateWithWhereUniqueWithoutUsersInput | user_contactsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_contactsUpdateManyWithWhereWithoutUsersInput | user_contactsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_contactsScalarWhereInput | user_contactsScalarWhereInput[]
  }

  export type appointmentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<appointmentsCreateWithoutUsersInput, appointmentsUncheckedCreateWithoutUsersInput> | appointmentsCreateWithoutUsersInput[] | appointmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutUsersInput | appointmentsCreateOrConnectWithoutUsersInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutUsersInput | appointmentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: appointmentsCreateManyUsersInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutUsersInput | appointmentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutUsersInput | appointmentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type patientsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput> | patientsCreateWithoutUsersInput[] | patientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: patientsCreateOrConnectWithoutUsersInput | patientsCreateOrConnectWithoutUsersInput[]
    upsert?: patientsUpsertWithWhereUniqueWithoutUsersInput | patientsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: patientsCreateManyUsersInputEnvelope
    set?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    disconnect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    delete?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    connect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    update?: patientsUpdateWithWhereUniqueWithoutUsersInput | patientsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: patientsUpdateManyWithWhereWithoutUsersInput | patientsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: patientsScalarWhereInput | patientsScalarWhereInput[]
  }

  export type user_contactsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_contactsCreateWithoutUsersInput, user_contactsUncheckedCreateWithoutUsersInput> | user_contactsCreateWithoutUsersInput[] | user_contactsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_contactsCreateOrConnectWithoutUsersInput | user_contactsCreateOrConnectWithoutUsersInput[]
    upsert?: user_contactsUpsertWithWhereUniqueWithoutUsersInput | user_contactsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_contactsCreateManyUsersInputEnvelope
    set?: user_contactsWhereUniqueInput | user_contactsWhereUniqueInput[]
    disconnect?: user_contactsWhereUniqueInput | user_contactsWhereUniqueInput[]
    delete?: user_contactsWhereUniqueInput | user_contactsWhereUniqueInput[]
    connect?: user_contactsWhereUniqueInput | user_contactsWhereUniqueInput[]
    update?: user_contactsUpdateWithWhereUniqueWithoutUsersInput | user_contactsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_contactsUpdateManyWithWhereWithoutUsersInput | user_contactsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_contactsScalarWhereInput | user_contactsScalarWhereInput[]
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type appointmentsCreateWithoutAppointment_statusInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    clinic_staff?: clinic_staffCreateNestedOneWithoutAppointmentsInput
    users?: usersCreateNestedOneWithoutAppointmentsInput
    patient_appointments?: patient_appointmentsCreateNestedManyWithoutAppointmentsInput
    recurring_instances?: recurring_instancesCreateNestedManyWithoutAppointmentsInput
    session?: sessionCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateWithoutAppointment_statusInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    staff_id?: bigint | number | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    user_id?: bigint | number | null
    patient_appointments?: patient_appointmentsUncheckedCreateNestedManyWithoutAppointmentsInput
    recurring_instances?: recurring_instancesUncheckedCreateNestedManyWithoutAppointmentsInput
    session?: sessionUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsCreateOrConnectWithoutAppointment_statusInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutAppointment_statusInput, appointmentsUncheckedCreateWithoutAppointment_statusInput>
  }

  export type appointmentsCreateManyAppointment_statusInputEnvelope = {
    data: appointmentsCreateManyAppointment_statusInput | appointmentsCreateManyAppointment_statusInput[]
    skipDuplicates?: boolean
  }

  export type appointmentsUpsertWithWhereUniqueWithoutAppointment_statusInput = {
    where: appointmentsWhereUniqueInput
    update: XOR<appointmentsUpdateWithoutAppointment_statusInput, appointmentsUncheckedUpdateWithoutAppointment_statusInput>
    create: XOR<appointmentsCreateWithoutAppointment_statusInput, appointmentsUncheckedCreateWithoutAppointment_statusInput>
  }

  export type appointmentsUpdateWithWhereUniqueWithoutAppointment_statusInput = {
    where: appointmentsWhereUniqueInput
    data: XOR<appointmentsUpdateWithoutAppointment_statusInput, appointmentsUncheckedUpdateWithoutAppointment_statusInput>
  }

  export type appointmentsUpdateManyWithWhereWithoutAppointment_statusInput = {
    where: appointmentsScalarWhereInput
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyWithoutAppointment_statusInput>
  }

  export type appointmentsScalarWhereInput = {
    AND?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
    OR?: appointmentsScalarWhereInput[]
    NOT?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
    appoint_id?: BigIntFilter<"appointments"> | bigint | number
    preferred_time?: DateTimeNullableFilter<"appointments"> | Date | string | null
    preferred_date?: DateTimeNullableFilter<"appointments"> | Date | string | null
    staff_id?: BigIntNullableFilter<"appointments"> | bigint | number | null
    appointment_status_id?: BigIntNullableFilter<"appointments"> | bigint | number | null
    final_date?: DateTimeNullableFilter<"appointments"> | Date | string | null
    final_time?: DateTimeNullableFilter<"appointments"> | Date | string | null
    user_id?: BigIntNullableFilter<"appointments"> | bigint | number | null
  }

  export type appointment_statusCreateWithoutAppointmentsInput = {
    appointment_status_id?: bigint | number
    appointment_status?: string | null
  }

  export type appointment_statusUncheckedCreateWithoutAppointmentsInput = {
    appointment_status_id?: bigint | number
    appointment_status?: string | null
  }

  export type appointment_statusCreateOrConnectWithoutAppointmentsInput = {
    where: appointment_statusWhereUniqueInput
    create: XOR<appointment_statusCreateWithoutAppointmentsInput, appointment_statusUncheckedCreateWithoutAppointmentsInput>
  }

  export type clinic_staffCreateWithoutAppointmentsInput = {
    staff_id?: bigint | number
    staff_name?: string | null
    staff_birthdate?: Date | string | null
    clinic_staff_details?: clinic_staff_detailsCreateNestedManyWithoutClinic_staffInput
    session?: sessionCreateNestedManyWithoutClinic_staffInput
    staff_role?: staff_roleCreateNestedManyWithoutClinic_staffInput
  }

  export type clinic_staffUncheckedCreateWithoutAppointmentsInput = {
    staff_id?: bigint | number
    staff_name?: string | null
    staff_birthdate?: Date | string | null
    clinic_staff_details?: clinic_staff_detailsUncheckedCreateNestedManyWithoutClinic_staffInput
    session?: sessionUncheckedCreateNestedManyWithoutClinic_staffInput
    staff_role?: staff_roleUncheckedCreateNestedManyWithoutClinic_staffInput
  }

  export type clinic_staffCreateOrConnectWithoutAppointmentsInput = {
    where: clinic_staffWhereUniqueInput
    create: XOR<clinic_staffCreateWithoutAppointmentsInput, clinic_staffUncheckedCreateWithoutAppointmentsInput>
  }

  export type usersCreateWithoutAppointmentsInput = {
    user_id?: bigint | number
    user_full_name?: string | null
    user_password?: string | null
    username?: string | null
    patients?: patientsCreateNestedManyWithoutUsersInput
    user_contacts?: user_contactsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAppointmentsInput = {
    user_id?: bigint | number
    user_full_name?: string | null
    user_password?: string | null
    username?: string | null
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    user_contacts?: user_contactsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAppointmentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAppointmentsInput, usersUncheckedCreateWithoutAppointmentsInput>
  }

  export type patient_appointmentsCreateWithoutAppointmentsInput = {
    patient_appointments_id?: bigint | number
    booking_date?: Date | string | null
    patients: patientsCreateNestedOneWithoutPatient_appointmentsInput
  }

  export type patient_appointmentsUncheckedCreateWithoutAppointmentsInput = {
    patient_appointments_id?: bigint | number
    patient_id: bigint | number
    booking_date?: Date | string | null
  }

  export type patient_appointmentsCreateOrConnectWithoutAppointmentsInput = {
    where: patient_appointmentsWhereUniqueInput
    create: XOR<patient_appointmentsCreateWithoutAppointmentsInput, patient_appointmentsUncheckedCreateWithoutAppointmentsInput>
  }

  export type patient_appointmentsCreateManyAppointmentsInputEnvelope = {
    data: patient_appointmentsCreateManyAppointmentsInput | patient_appointmentsCreateManyAppointmentsInput[]
    skipDuplicates?: boolean
  }

  export type recurring_instancesCreateWithoutAppointmentsInput = {
    instance_id?: bigint | number
    appoint_date?: Date | string | null
    appoint_time?: Date | string | null
    instance_status?: string | null
    recurrence: recurrenceCreateNestedOneWithoutRecurring_instancesInput
  }

  export type recurring_instancesUncheckedCreateWithoutAppointmentsInput = {
    instance_id?: bigint | number
    recurrence_id: bigint | number
    appoint_date?: Date | string | null
    appoint_time?: Date | string | null
    instance_status?: string | null
  }

  export type recurring_instancesCreateOrConnectWithoutAppointmentsInput = {
    where: recurring_instancesWhereUniqueInput
    create: XOR<recurring_instancesCreateWithoutAppointmentsInput, recurring_instancesUncheckedCreateWithoutAppointmentsInput>
  }

  export type recurring_instancesCreateManyAppointmentsInputEnvelope = {
    data: recurring_instancesCreateManyAppointmentsInput | recurring_instancesCreateManyAppointmentsInput[]
    skipDuplicates?: boolean
  }

  export type sessionCreateWithoutAppointmentsInput = {
    session_id?: bigint | number
    patients: patientsCreateNestedOneWithoutSessionInput
    clinic_staff: clinic_staffCreateNestedOneWithoutSessionInput
    session_details?: session_detailsCreateNestedManyWithoutSessionInput
  }

  export type sessionUncheckedCreateWithoutAppointmentsInput = {
    session_id?: bigint | number
    patient_id: bigint | number
    staff_id: bigint | number
    session_details?: session_detailsUncheckedCreateNestedManyWithoutSessionInput
  }

  export type sessionCreateOrConnectWithoutAppointmentsInput = {
    where: sessionWhereUniqueInput
    create: XOR<sessionCreateWithoutAppointmentsInput, sessionUncheckedCreateWithoutAppointmentsInput>
  }

  export type sessionCreateManyAppointmentsInputEnvelope = {
    data: sessionCreateManyAppointmentsInput | sessionCreateManyAppointmentsInput[]
    skipDuplicates?: boolean
  }

  export type appointment_statusUpsertWithoutAppointmentsInput = {
    update: XOR<appointment_statusUpdateWithoutAppointmentsInput, appointment_statusUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<appointment_statusCreateWithoutAppointmentsInput, appointment_statusUncheckedCreateWithoutAppointmentsInput>
    where?: appointment_statusWhereInput
  }

  export type appointment_statusUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: appointment_statusWhereInput
    data: XOR<appointment_statusUpdateWithoutAppointmentsInput, appointment_statusUncheckedUpdateWithoutAppointmentsInput>
  }

  export type appointment_statusUpdateWithoutAppointmentsInput = {
    appointment_status_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appointment_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type appointment_statusUncheckedUpdateWithoutAppointmentsInput = {
    appointment_status_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appointment_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinic_staffUpsertWithoutAppointmentsInput = {
    update: XOR<clinic_staffUpdateWithoutAppointmentsInput, clinic_staffUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<clinic_staffCreateWithoutAppointmentsInput, clinic_staffUncheckedCreateWithoutAppointmentsInput>
    where?: clinic_staffWhereInput
  }

  export type clinic_staffUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: clinic_staffWhereInput
    data: XOR<clinic_staffUpdateWithoutAppointmentsInput, clinic_staffUncheckedUpdateWithoutAppointmentsInput>
  }

  export type clinic_staffUpdateWithoutAppointmentsInput = {
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_name?: NullableStringFieldUpdateOperationsInput | string | null
    staff_birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic_staff_details?: clinic_staff_detailsUpdateManyWithoutClinic_staffNestedInput
    session?: sessionUpdateManyWithoutClinic_staffNestedInput
    staff_role?: staff_roleUpdateManyWithoutClinic_staffNestedInput
  }

  export type clinic_staffUncheckedUpdateWithoutAppointmentsInput = {
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_name?: NullableStringFieldUpdateOperationsInput | string | null
    staff_birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic_staff_details?: clinic_staff_detailsUncheckedUpdateManyWithoutClinic_staffNestedInput
    session?: sessionUncheckedUpdateManyWithoutClinic_staffNestedInput
    staff_role?: staff_roleUncheckedUpdateManyWithoutClinic_staffNestedInput
  }

  export type usersUpsertWithoutAppointmentsInput = {
    update: XOR<usersUpdateWithoutAppointmentsInput, usersUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<usersCreateWithoutAppointmentsInput, usersUncheckedCreateWithoutAppointmentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAppointmentsInput, usersUncheckedUpdateWithoutAppointmentsInput>
  }

  export type usersUpdateWithoutAppointmentsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_full_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    patients?: patientsUpdateManyWithoutUsersNestedInput
    user_contacts?: user_contactsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAppointmentsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_full_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    user_contacts?: user_contactsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type patient_appointmentsUpsertWithWhereUniqueWithoutAppointmentsInput = {
    where: patient_appointmentsWhereUniqueInput
    update: XOR<patient_appointmentsUpdateWithoutAppointmentsInput, patient_appointmentsUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<patient_appointmentsCreateWithoutAppointmentsInput, patient_appointmentsUncheckedCreateWithoutAppointmentsInput>
  }

  export type patient_appointmentsUpdateWithWhereUniqueWithoutAppointmentsInput = {
    where: patient_appointmentsWhereUniqueInput
    data: XOR<patient_appointmentsUpdateWithoutAppointmentsInput, patient_appointmentsUncheckedUpdateWithoutAppointmentsInput>
  }

  export type patient_appointmentsUpdateManyWithWhereWithoutAppointmentsInput = {
    where: patient_appointmentsScalarWhereInput
    data: XOR<patient_appointmentsUpdateManyMutationInput, patient_appointmentsUncheckedUpdateManyWithoutAppointmentsInput>
  }

  export type patient_appointmentsScalarWhereInput = {
    AND?: patient_appointmentsScalarWhereInput | patient_appointmentsScalarWhereInput[]
    OR?: patient_appointmentsScalarWhereInput[]
    NOT?: patient_appointmentsScalarWhereInput | patient_appointmentsScalarWhereInput[]
    patient_appointments_id?: BigIntFilter<"patient_appointments"> | bigint | number
    patient_id?: BigIntFilter<"patient_appointments"> | bigint | number
    appoint_id?: BigIntFilter<"patient_appointments"> | bigint | number
    booking_date?: DateTimeNullableFilter<"patient_appointments"> | Date | string | null
  }

  export type recurring_instancesUpsertWithWhereUniqueWithoutAppointmentsInput = {
    where: recurring_instancesWhereUniqueInput
    update: XOR<recurring_instancesUpdateWithoutAppointmentsInput, recurring_instancesUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<recurring_instancesCreateWithoutAppointmentsInput, recurring_instancesUncheckedCreateWithoutAppointmentsInput>
  }

  export type recurring_instancesUpdateWithWhereUniqueWithoutAppointmentsInput = {
    where: recurring_instancesWhereUniqueInput
    data: XOR<recurring_instancesUpdateWithoutAppointmentsInput, recurring_instancesUncheckedUpdateWithoutAppointmentsInput>
  }

  export type recurring_instancesUpdateManyWithWhereWithoutAppointmentsInput = {
    where: recurring_instancesScalarWhereInput
    data: XOR<recurring_instancesUpdateManyMutationInput, recurring_instancesUncheckedUpdateManyWithoutAppointmentsInput>
  }

  export type recurring_instancesScalarWhereInput = {
    AND?: recurring_instancesScalarWhereInput | recurring_instancesScalarWhereInput[]
    OR?: recurring_instancesScalarWhereInput[]
    NOT?: recurring_instancesScalarWhereInput | recurring_instancesScalarWhereInput[]
    instance_id?: BigIntFilter<"recurring_instances"> | bigint | number
    appoint_id?: BigIntFilter<"recurring_instances"> | bigint | number
    recurrence_id?: BigIntFilter<"recurring_instances"> | bigint | number
    appoint_date?: DateTimeNullableFilter<"recurring_instances"> | Date | string | null
    appoint_time?: DateTimeNullableFilter<"recurring_instances"> | Date | string | null
    instance_status?: StringNullableFilter<"recurring_instances"> | string | null
  }

  export type sessionUpsertWithWhereUniqueWithoutAppointmentsInput = {
    where: sessionWhereUniqueInput
    update: XOR<sessionUpdateWithoutAppointmentsInput, sessionUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<sessionCreateWithoutAppointmentsInput, sessionUncheckedCreateWithoutAppointmentsInput>
  }

  export type sessionUpdateWithWhereUniqueWithoutAppointmentsInput = {
    where: sessionWhereUniqueInput
    data: XOR<sessionUpdateWithoutAppointmentsInput, sessionUncheckedUpdateWithoutAppointmentsInput>
  }

  export type sessionUpdateManyWithWhereWithoutAppointmentsInput = {
    where: sessionScalarWhereInput
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyWithoutAppointmentsInput>
  }

  export type sessionScalarWhereInput = {
    AND?: sessionScalarWhereInput | sessionScalarWhereInput[]
    OR?: sessionScalarWhereInput[]
    NOT?: sessionScalarWhereInput | sessionScalarWhereInput[]
    session_id?: BigIntFilter<"session"> | bigint | number
    patient_id?: BigIntFilter<"session"> | bigint | number
    staff_id?: BigIntFilter<"session"> | bigint | number
    appoint_id?: BigIntFilter<"session"> | bigint | number
  }

  export type appointmentsCreateWithoutClinic_staffInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    appointment_status?: appointment_statusCreateNestedOneWithoutAppointmentsInput
    users?: usersCreateNestedOneWithoutAppointmentsInput
    patient_appointments?: patient_appointmentsCreateNestedManyWithoutAppointmentsInput
    recurring_instances?: recurring_instancesCreateNestedManyWithoutAppointmentsInput
    session?: sessionCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateWithoutClinic_staffInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    appointment_status_id?: bigint | number | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    user_id?: bigint | number | null
    patient_appointments?: patient_appointmentsUncheckedCreateNestedManyWithoutAppointmentsInput
    recurring_instances?: recurring_instancesUncheckedCreateNestedManyWithoutAppointmentsInput
    session?: sessionUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsCreateOrConnectWithoutClinic_staffInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutClinic_staffInput, appointmentsUncheckedCreateWithoutClinic_staffInput>
  }

  export type appointmentsCreateManyClinic_staffInputEnvelope = {
    data: appointmentsCreateManyClinic_staffInput | appointmentsCreateManyClinic_staffInput[]
    skipDuplicates?: boolean
  }

  export type clinic_staff_detailsCreateWithoutClinic_staffInput = {
    clinic_staff_contact_id?: bigint | number
    staff_contact?: string | null
    staff_address?: string | null
  }

  export type clinic_staff_detailsUncheckedCreateWithoutClinic_staffInput = {
    clinic_staff_contact_id?: bigint | number
    staff_contact?: string | null
    staff_address?: string | null
  }

  export type clinic_staff_detailsCreateOrConnectWithoutClinic_staffInput = {
    where: clinic_staff_detailsWhereUniqueInput
    create: XOR<clinic_staff_detailsCreateWithoutClinic_staffInput, clinic_staff_detailsUncheckedCreateWithoutClinic_staffInput>
  }

  export type clinic_staff_detailsCreateManyClinic_staffInputEnvelope = {
    data: clinic_staff_detailsCreateManyClinic_staffInput | clinic_staff_detailsCreateManyClinic_staffInput[]
    skipDuplicates?: boolean
  }

  export type sessionCreateWithoutClinic_staffInput = {
    session_id?: bigint | number
    appointments: appointmentsCreateNestedOneWithoutSessionInput
    patients: patientsCreateNestedOneWithoutSessionInput
    session_details?: session_detailsCreateNestedManyWithoutSessionInput
  }

  export type sessionUncheckedCreateWithoutClinic_staffInput = {
    session_id?: bigint | number
    patient_id: bigint | number
    appoint_id: bigint | number
    session_details?: session_detailsUncheckedCreateNestedManyWithoutSessionInput
  }

  export type sessionCreateOrConnectWithoutClinic_staffInput = {
    where: sessionWhereUniqueInput
    create: XOR<sessionCreateWithoutClinic_staffInput, sessionUncheckedCreateWithoutClinic_staffInput>
  }

  export type sessionCreateManyClinic_staffInputEnvelope = {
    data: sessionCreateManyClinic_staffInput | sessionCreateManyClinic_staffInput[]
    skipDuplicates?: boolean
  }

  export type staff_roleCreateWithoutClinic_staffInput = {
    staff_role_id?: bigint | number
    staff_role?: string | null
  }

  export type staff_roleUncheckedCreateWithoutClinic_staffInput = {
    staff_role_id?: bigint | number
    staff_role?: string | null
  }

  export type staff_roleCreateOrConnectWithoutClinic_staffInput = {
    where: staff_roleWhereUniqueInput
    create: XOR<staff_roleCreateWithoutClinic_staffInput, staff_roleUncheckedCreateWithoutClinic_staffInput>
  }

  export type staff_roleCreateManyClinic_staffInputEnvelope = {
    data: staff_roleCreateManyClinic_staffInput | staff_roleCreateManyClinic_staffInput[]
    skipDuplicates?: boolean
  }

  export type appointmentsUpsertWithWhereUniqueWithoutClinic_staffInput = {
    where: appointmentsWhereUniqueInput
    update: XOR<appointmentsUpdateWithoutClinic_staffInput, appointmentsUncheckedUpdateWithoutClinic_staffInput>
    create: XOR<appointmentsCreateWithoutClinic_staffInput, appointmentsUncheckedCreateWithoutClinic_staffInput>
  }

  export type appointmentsUpdateWithWhereUniqueWithoutClinic_staffInput = {
    where: appointmentsWhereUniqueInput
    data: XOR<appointmentsUpdateWithoutClinic_staffInput, appointmentsUncheckedUpdateWithoutClinic_staffInput>
  }

  export type appointmentsUpdateManyWithWhereWithoutClinic_staffInput = {
    where: appointmentsScalarWhereInput
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyWithoutClinic_staffInput>
  }

  export type clinic_staff_detailsUpsertWithWhereUniqueWithoutClinic_staffInput = {
    where: clinic_staff_detailsWhereUniqueInput
    update: XOR<clinic_staff_detailsUpdateWithoutClinic_staffInput, clinic_staff_detailsUncheckedUpdateWithoutClinic_staffInput>
    create: XOR<clinic_staff_detailsCreateWithoutClinic_staffInput, clinic_staff_detailsUncheckedCreateWithoutClinic_staffInput>
  }

  export type clinic_staff_detailsUpdateWithWhereUniqueWithoutClinic_staffInput = {
    where: clinic_staff_detailsWhereUniqueInput
    data: XOR<clinic_staff_detailsUpdateWithoutClinic_staffInput, clinic_staff_detailsUncheckedUpdateWithoutClinic_staffInput>
  }

  export type clinic_staff_detailsUpdateManyWithWhereWithoutClinic_staffInput = {
    where: clinic_staff_detailsScalarWhereInput
    data: XOR<clinic_staff_detailsUpdateManyMutationInput, clinic_staff_detailsUncheckedUpdateManyWithoutClinic_staffInput>
  }

  export type clinic_staff_detailsScalarWhereInput = {
    AND?: clinic_staff_detailsScalarWhereInput | clinic_staff_detailsScalarWhereInput[]
    OR?: clinic_staff_detailsScalarWhereInput[]
    NOT?: clinic_staff_detailsScalarWhereInput | clinic_staff_detailsScalarWhereInput[]
    clinic_staff_contact_id?: BigIntFilter<"clinic_staff_details"> | bigint | number
    staff_id?: BigIntFilter<"clinic_staff_details"> | bigint | number
    staff_contact?: StringNullableFilter<"clinic_staff_details"> | string | null
    staff_address?: StringNullableFilter<"clinic_staff_details"> | string | null
  }

  export type sessionUpsertWithWhereUniqueWithoutClinic_staffInput = {
    where: sessionWhereUniqueInput
    update: XOR<sessionUpdateWithoutClinic_staffInput, sessionUncheckedUpdateWithoutClinic_staffInput>
    create: XOR<sessionCreateWithoutClinic_staffInput, sessionUncheckedCreateWithoutClinic_staffInput>
  }

  export type sessionUpdateWithWhereUniqueWithoutClinic_staffInput = {
    where: sessionWhereUniqueInput
    data: XOR<sessionUpdateWithoutClinic_staffInput, sessionUncheckedUpdateWithoutClinic_staffInput>
  }

  export type sessionUpdateManyWithWhereWithoutClinic_staffInput = {
    where: sessionScalarWhereInput
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyWithoutClinic_staffInput>
  }

  export type staff_roleUpsertWithWhereUniqueWithoutClinic_staffInput = {
    where: staff_roleWhereUniqueInput
    update: XOR<staff_roleUpdateWithoutClinic_staffInput, staff_roleUncheckedUpdateWithoutClinic_staffInput>
    create: XOR<staff_roleCreateWithoutClinic_staffInput, staff_roleUncheckedCreateWithoutClinic_staffInput>
  }

  export type staff_roleUpdateWithWhereUniqueWithoutClinic_staffInput = {
    where: staff_roleWhereUniqueInput
    data: XOR<staff_roleUpdateWithoutClinic_staffInput, staff_roleUncheckedUpdateWithoutClinic_staffInput>
  }

  export type staff_roleUpdateManyWithWhereWithoutClinic_staffInput = {
    where: staff_roleScalarWhereInput
    data: XOR<staff_roleUpdateManyMutationInput, staff_roleUncheckedUpdateManyWithoutClinic_staffInput>
  }

  export type staff_roleScalarWhereInput = {
    AND?: staff_roleScalarWhereInput | staff_roleScalarWhereInput[]
    OR?: staff_roleScalarWhereInput[]
    NOT?: staff_roleScalarWhereInput | staff_roleScalarWhereInput[]
    staff_role_id?: BigIntFilter<"staff_role"> | bigint | number
    staff_id?: BigIntFilter<"staff_role"> | bigint | number
    staff_role?: StringNullableFilter<"staff_role"> | string | null
  }

  export type clinic_staffCreateWithoutClinic_staff_detailsInput = {
    staff_id?: bigint | number
    staff_name?: string | null
    staff_birthdate?: Date | string | null
    appointments?: appointmentsCreateNestedManyWithoutClinic_staffInput
    session?: sessionCreateNestedManyWithoutClinic_staffInput
    staff_role?: staff_roleCreateNestedManyWithoutClinic_staffInput
  }

  export type clinic_staffUncheckedCreateWithoutClinic_staff_detailsInput = {
    staff_id?: bigint | number
    staff_name?: string | null
    staff_birthdate?: Date | string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutClinic_staffInput
    session?: sessionUncheckedCreateNestedManyWithoutClinic_staffInput
    staff_role?: staff_roleUncheckedCreateNestedManyWithoutClinic_staffInput
  }

  export type clinic_staffCreateOrConnectWithoutClinic_staff_detailsInput = {
    where: clinic_staffWhereUniqueInput
    create: XOR<clinic_staffCreateWithoutClinic_staff_detailsInput, clinic_staffUncheckedCreateWithoutClinic_staff_detailsInput>
  }

  export type clinic_staffUpsertWithoutClinic_staff_detailsInput = {
    update: XOR<clinic_staffUpdateWithoutClinic_staff_detailsInput, clinic_staffUncheckedUpdateWithoutClinic_staff_detailsInput>
    create: XOR<clinic_staffCreateWithoutClinic_staff_detailsInput, clinic_staffUncheckedCreateWithoutClinic_staff_detailsInput>
    where?: clinic_staffWhereInput
  }

  export type clinic_staffUpdateToOneWithWhereWithoutClinic_staff_detailsInput = {
    where?: clinic_staffWhereInput
    data: XOR<clinic_staffUpdateWithoutClinic_staff_detailsInput, clinic_staffUncheckedUpdateWithoutClinic_staff_detailsInput>
  }

  export type clinic_staffUpdateWithoutClinic_staff_detailsInput = {
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_name?: NullableStringFieldUpdateOperationsInput | string | null
    staff_birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUpdateManyWithoutClinic_staffNestedInput
    session?: sessionUpdateManyWithoutClinic_staffNestedInput
    staff_role?: staff_roleUpdateManyWithoutClinic_staffNestedInput
  }

  export type clinic_staffUncheckedUpdateWithoutClinic_staff_detailsInput = {
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_name?: NullableStringFieldUpdateOperationsInput | string | null
    staff_birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutClinic_staffNestedInput
    session?: sessionUncheckedUpdateManyWithoutClinic_staffNestedInput
    staff_role?: staff_roleUncheckedUpdateManyWithoutClinic_staffNestedInput
  }

  export type appointmentsCreateWithoutPatient_appointmentsInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    appointment_status?: appointment_statusCreateNestedOneWithoutAppointmentsInput
    clinic_staff?: clinic_staffCreateNestedOneWithoutAppointmentsInput
    users?: usersCreateNestedOneWithoutAppointmentsInput
    recurring_instances?: recurring_instancesCreateNestedManyWithoutAppointmentsInput
    session?: sessionCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateWithoutPatient_appointmentsInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    staff_id?: bigint | number | null
    appointment_status_id?: bigint | number | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    user_id?: bigint | number | null
    recurring_instances?: recurring_instancesUncheckedCreateNestedManyWithoutAppointmentsInput
    session?: sessionUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsCreateOrConnectWithoutPatient_appointmentsInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutPatient_appointmentsInput, appointmentsUncheckedCreateWithoutPatient_appointmentsInput>
  }

  export type patientsCreateWithoutPatient_appointmentsInput = {
    patient_id?: bigint | number
    patient_name?: string | null
    patient_details?: patient_detailsCreateNestedManyWithoutPatientsInput
    users: usersCreateNestedOneWithoutPatientsInput
    session?: sessionCreateNestedManyWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutPatient_appointmentsInput = {
    patient_id?: bigint | number
    patient_name?: string | null
    user_id: bigint | number
    patient_details?: patient_detailsUncheckedCreateNestedManyWithoutPatientsInput
    session?: sessionUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutPatient_appointmentsInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutPatient_appointmentsInput, patientsUncheckedCreateWithoutPatient_appointmentsInput>
  }

  export type appointmentsUpsertWithoutPatient_appointmentsInput = {
    update: XOR<appointmentsUpdateWithoutPatient_appointmentsInput, appointmentsUncheckedUpdateWithoutPatient_appointmentsInput>
    create: XOR<appointmentsCreateWithoutPatient_appointmentsInput, appointmentsUncheckedCreateWithoutPatient_appointmentsInput>
    where?: appointmentsWhereInput
  }

  export type appointmentsUpdateToOneWithWhereWithoutPatient_appointmentsInput = {
    where?: appointmentsWhereInput
    data: XOR<appointmentsUpdateWithoutPatient_appointmentsInput, appointmentsUncheckedUpdateWithoutPatient_appointmentsInput>
  }

  export type appointmentsUpdateWithoutPatient_appointmentsInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointment_status?: appointment_statusUpdateOneWithoutAppointmentsNestedInput
    clinic_staff?: clinic_staffUpdateOneWithoutAppointmentsNestedInput
    users?: usersUpdateOneWithoutAppointmentsNestedInput
    recurring_instances?: recurring_instancesUpdateManyWithoutAppointmentsNestedInput
    session?: sessionUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutPatient_appointmentsInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staff_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    appointment_status_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    recurring_instances?: recurring_instancesUncheckedUpdateManyWithoutAppointmentsNestedInput
    session?: sessionUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type patientsUpsertWithoutPatient_appointmentsInput = {
    update: XOR<patientsUpdateWithoutPatient_appointmentsInput, patientsUncheckedUpdateWithoutPatient_appointmentsInput>
    create: XOR<patientsCreateWithoutPatient_appointmentsInput, patientsUncheckedCreateWithoutPatient_appointmentsInput>
    where?: patientsWhereInput
  }

  export type patientsUpdateToOneWithWhereWithoutPatient_appointmentsInput = {
    where?: patientsWhereInput
    data: XOR<patientsUpdateWithoutPatient_appointmentsInput, patientsUncheckedUpdateWithoutPatient_appointmentsInput>
  }

  export type patientsUpdateWithoutPatient_appointmentsInput = {
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_name?: NullableStringFieldUpdateOperationsInput | string | null
    patient_details?: patient_detailsUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneRequiredWithoutPatientsNestedInput
    session?: sessionUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutPatient_appointmentsInput = {
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_details?: patient_detailsUncheckedUpdateManyWithoutPatientsNestedInput
    session?: sessionUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type patient_conditionsCreateWithoutOther_patient_conditionsInput = {
    condition_type?: string | null
    condition_description?: string | null
    patient_conditions?: patient_conditionsCreateNestedOneWithoutOther_patient_conditionsInput
  }

  export type patient_conditionsUncheckedCreateWithoutOther_patient_conditionsInput = {
    patient_conditions_id?: bigint | number
    condition_type?: string | null
    condition_description?: string | null
  }

  export type patient_conditionsCreateOrConnectWithoutOther_patient_conditionsInput = {
    where: patient_conditionsWhereUniqueInput
    create: XOR<patient_conditionsCreateWithoutOther_patient_conditionsInput, patient_conditionsUncheckedCreateWithoutOther_patient_conditionsInput>
  }

  export type patient_conditionsCreateWithoutPatient_conditionsInput = {
    condition_type?: string | null
    condition_description?: string | null
    other_patient_conditions?: patient_conditionsCreateNestedOneWithoutPatient_conditionsInput
  }

  export type patient_conditionsUncheckedCreateWithoutPatient_conditionsInput = {
    condition_type?: string | null
    condition_description?: string | null
    other_patient_conditions?: patient_conditionsUncheckedCreateNestedOneWithoutPatient_conditionsInput
  }

  export type patient_conditionsCreateOrConnectWithoutPatient_conditionsInput = {
    where: patient_conditionsWhereUniqueInput
    create: XOR<patient_conditionsCreateWithoutPatient_conditionsInput, patient_conditionsUncheckedCreateWithoutPatient_conditionsInput>
  }

  export type patient_conditionsUpsertWithoutOther_patient_conditionsInput = {
    update: XOR<patient_conditionsUpdateWithoutOther_patient_conditionsInput, patient_conditionsUncheckedUpdateWithoutOther_patient_conditionsInput>
    create: XOR<patient_conditionsCreateWithoutOther_patient_conditionsInput, patient_conditionsUncheckedCreateWithoutOther_patient_conditionsInput>
    where?: patient_conditionsWhereInput
  }

  export type patient_conditionsUpdateToOneWithWhereWithoutOther_patient_conditionsInput = {
    where?: patient_conditionsWhereInput
    data: XOR<patient_conditionsUpdateWithoutOther_patient_conditionsInput, patient_conditionsUncheckedUpdateWithoutOther_patient_conditionsInput>
  }

  export type patient_conditionsUpdateWithoutOther_patient_conditionsInput = {
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    condition_description?: NullableStringFieldUpdateOperationsInput | string | null
    patient_conditions?: patient_conditionsUpdateOneRequiredWithoutOther_patient_conditionsNestedInput
  }

  export type patient_conditionsUncheckedUpdateWithoutOther_patient_conditionsInput = {
    patient_conditions_id?: BigIntFieldUpdateOperationsInput | bigint | number
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    condition_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type patient_conditionsUpsertWithoutPatient_conditionsInput = {
    update: XOR<patient_conditionsUpdateWithoutPatient_conditionsInput, patient_conditionsUncheckedUpdateWithoutPatient_conditionsInput>
    create: XOR<patient_conditionsCreateWithoutPatient_conditionsInput, patient_conditionsUncheckedCreateWithoutPatient_conditionsInput>
    where?: patient_conditionsWhereInput
  }

  export type patient_conditionsUpdateToOneWithWhereWithoutPatient_conditionsInput = {
    where?: patient_conditionsWhereInput
    data: XOR<patient_conditionsUpdateWithoutPatient_conditionsInput, patient_conditionsUncheckedUpdateWithoutPatient_conditionsInput>
  }

  export type patient_conditionsUpdateWithoutPatient_conditionsInput = {
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    condition_description?: NullableStringFieldUpdateOperationsInput | string | null
    other_patient_conditions?: patient_conditionsUpdateOneWithoutPatient_conditionsNestedInput
  }

  export type patient_conditionsUncheckedUpdateWithoutPatient_conditionsInput = {
    condition_type?: NullableStringFieldUpdateOperationsInput | string | null
    condition_description?: NullableStringFieldUpdateOperationsInput | string | null
    other_patient_conditions?: patient_conditionsUncheckedUpdateOneWithoutPatient_conditionsNestedInput
  }

  export type patientsCreateWithoutPatient_detailsInput = {
    patient_id?: bigint | number
    patient_name?: string | null
    patient_appointments?: patient_appointmentsCreateNestedManyWithoutPatientsInput
    users: usersCreateNestedOneWithoutPatientsInput
    session?: sessionCreateNestedManyWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutPatient_detailsInput = {
    patient_id?: bigint | number
    patient_name?: string | null
    user_id: bigint | number
    patient_appointments?: patient_appointmentsUncheckedCreateNestedManyWithoutPatientsInput
    session?: sessionUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutPatient_detailsInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutPatient_detailsInput, patientsUncheckedCreateWithoutPatient_detailsInput>
  }

  export type patientsUpsertWithoutPatient_detailsInput = {
    update: XOR<patientsUpdateWithoutPatient_detailsInput, patientsUncheckedUpdateWithoutPatient_detailsInput>
    create: XOR<patientsCreateWithoutPatient_detailsInput, patientsUncheckedCreateWithoutPatient_detailsInput>
    where?: patientsWhereInput
  }

  export type patientsUpdateToOneWithWhereWithoutPatient_detailsInput = {
    where?: patientsWhereInput
    data: XOR<patientsUpdateWithoutPatient_detailsInput, patientsUncheckedUpdateWithoutPatient_detailsInput>
  }

  export type patientsUpdateWithoutPatient_detailsInput = {
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_name?: NullableStringFieldUpdateOperationsInput | string | null
    patient_appointments?: patient_appointmentsUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneRequiredWithoutPatientsNestedInput
    session?: sessionUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutPatient_detailsInput = {
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_appointments?: patient_appointmentsUncheckedUpdateManyWithoutPatientsNestedInput
    session?: sessionUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type patient_appointmentsCreateWithoutPatientsInput = {
    patient_appointments_id?: bigint | number
    booking_date?: Date | string | null
    appointments: appointmentsCreateNestedOneWithoutPatient_appointmentsInput
  }

  export type patient_appointmentsUncheckedCreateWithoutPatientsInput = {
    patient_appointments_id?: bigint | number
    appoint_id: bigint | number
    booking_date?: Date | string | null
  }

  export type patient_appointmentsCreateOrConnectWithoutPatientsInput = {
    where: patient_appointmentsWhereUniqueInput
    create: XOR<patient_appointmentsCreateWithoutPatientsInput, patient_appointmentsUncheckedCreateWithoutPatientsInput>
  }

  export type patient_appointmentsCreateManyPatientsInputEnvelope = {
    data: patient_appointmentsCreateManyPatientsInput | patient_appointmentsCreateManyPatientsInput[]
    skipDuplicates?: boolean
  }

  export type patient_detailsCreateWithoutPatientsInput = {
    patient_details_id?: bigint | number
    patient_conditions_id: bigint | number
    patient_birth_date?: Date | string | null
  }

  export type patient_detailsUncheckedCreateWithoutPatientsInput = {
    patient_details_id?: bigint | number
    patient_conditions_id: bigint | number
    patient_birth_date?: Date | string | null
  }

  export type patient_detailsCreateOrConnectWithoutPatientsInput = {
    where: patient_detailsWhereUniqueInput
    create: XOR<patient_detailsCreateWithoutPatientsInput, patient_detailsUncheckedCreateWithoutPatientsInput>
  }

  export type patient_detailsCreateManyPatientsInputEnvelope = {
    data: patient_detailsCreateManyPatientsInput | patient_detailsCreateManyPatientsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutPatientsInput = {
    user_id?: bigint | number
    user_full_name?: string | null
    user_password?: string | null
    username?: string | null
    appointments?: appointmentsCreateNestedManyWithoutUsersInput
    user_contacts?: user_contactsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPatientsInput = {
    user_id?: bigint | number
    user_full_name?: string | null
    user_password?: string | null
    username?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutUsersInput
    user_contacts?: user_contactsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPatientsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPatientsInput, usersUncheckedCreateWithoutPatientsInput>
  }

  export type sessionCreateWithoutPatientsInput = {
    session_id?: bigint | number
    appointments: appointmentsCreateNestedOneWithoutSessionInput
    clinic_staff: clinic_staffCreateNestedOneWithoutSessionInput
    session_details?: session_detailsCreateNestedManyWithoutSessionInput
  }

  export type sessionUncheckedCreateWithoutPatientsInput = {
    session_id?: bigint | number
    staff_id: bigint | number
    appoint_id: bigint | number
    session_details?: session_detailsUncheckedCreateNestedManyWithoutSessionInput
  }

  export type sessionCreateOrConnectWithoutPatientsInput = {
    where: sessionWhereUniqueInput
    create: XOR<sessionCreateWithoutPatientsInput, sessionUncheckedCreateWithoutPatientsInput>
  }

  export type sessionCreateManyPatientsInputEnvelope = {
    data: sessionCreateManyPatientsInput | sessionCreateManyPatientsInput[]
    skipDuplicates?: boolean
  }

  export type patient_appointmentsUpsertWithWhereUniqueWithoutPatientsInput = {
    where: patient_appointmentsWhereUniqueInput
    update: XOR<patient_appointmentsUpdateWithoutPatientsInput, patient_appointmentsUncheckedUpdateWithoutPatientsInput>
    create: XOR<patient_appointmentsCreateWithoutPatientsInput, patient_appointmentsUncheckedCreateWithoutPatientsInput>
  }

  export type patient_appointmentsUpdateWithWhereUniqueWithoutPatientsInput = {
    where: patient_appointmentsWhereUniqueInput
    data: XOR<patient_appointmentsUpdateWithoutPatientsInput, patient_appointmentsUncheckedUpdateWithoutPatientsInput>
  }

  export type patient_appointmentsUpdateManyWithWhereWithoutPatientsInput = {
    where: patient_appointmentsScalarWhereInput
    data: XOR<patient_appointmentsUpdateManyMutationInput, patient_appointmentsUncheckedUpdateManyWithoutPatientsInput>
  }

  export type patient_detailsUpsertWithWhereUniqueWithoutPatientsInput = {
    where: patient_detailsWhereUniqueInput
    update: XOR<patient_detailsUpdateWithoutPatientsInput, patient_detailsUncheckedUpdateWithoutPatientsInput>
    create: XOR<patient_detailsCreateWithoutPatientsInput, patient_detailsUncheckedCreateWithoutPatientsInput>
  }

  export type patient_detailsUpdateWithWhereUniqueWithoutPatientsInput = {
    where: patient_detailsWhereUniqueInput
    data: XOR<patient_detailsUpdateWithoutPatientsInput, patient_detailsUncheckedUpdateWithoutPatientsInput>
  }

  export type patient_detailsUpdateManyWithWhereWithoutPatientsInput = {
    where: patient_detailsScalarWhereInput
    data: XOR<patient_detailsUpdateManyMutationInput, patient_detailsUncheckedUpdateManyWithoutPatientsInput>
  }

  export type patient_detailsScalarWhereInput = {
    AND?: patient_detailsScalarWhereInput | patient_detailsScalarWhereInput[]
    OR?: patient_detailsScalarWhereInput[]
    NOT?: patient_detailsScalarWhereInput | patient_detailsScalarWhereInput[]
    patient_details_id?: BigIntFilter<"patient_details"> | bigint | number
    patient_id?: BigIntFilter<"patient_details"> | bigint | number
    patient_conditions_id?: BigIntFilter<"patient_details"> | bigint | number
    patient_birth_date?: DateTimeNullableFilter<"patient_details"> | Date | string | null
  }

  export type usersUpsertWithoutPatientsInput = {
    update: XOR<usersUpdateWithoutPatientsInput, usersUncheckedUpdateWithoutPatientsInput>
    create: XOR<usersCreateWithoutPatientsInput, usersUncheckedCreateWithoutPatientsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPatientsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPatientsInput, usersUncheckedUpdateWithoutPatientsInput>
  }

  export type usersUpdateWithoutPatientsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_full_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutUsersNestedInput
    user_contacts?: user_contactsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPatientsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_full_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_contacts?: user_contactsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type sessionUpsertWithWhereUniqueWithoutPatientsInput = {
    where: sessionWhereUniqueInput
    update: XOR<sessionUpdateWithoutPatientsInput, sessionUncheckedUpdateWithoutPatientsInput>
    create: XOR<sessionCreateWithoutPatientsInput, sessionUncheckedCreateWithoutPatientsInput>
  }

  export type sessionUpdateWithWhereUniqueWithoutPatientsInput = {
    where: sessionWhereUniqueInput
    data: XOR<sessionUpdateWithoutPatientsInput, sessionUncheckedUpdateWithoutPatientsInput>
  }

  export type sessionUpdateManyWithWhereWithoutPatientsInput = {
    where: sessionScalarWhereInput
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyWithoutPatientsInput>
  }

  export type recurring_instancesCreateWithoutRecurrenceInput = {
    instance_id?: bigint | number
    appoint_date?: Date | string | null
    appoint_time?: Date | string | null
    instance_status?: string | null
    appointments: appointmentsCreateNestedOneWithoutRecurring_instancesInput
  }

  export type recurring_instancesUncheckedCreateWithoutRecurrenceInput = {
    instance_id?: bigint | number
    appoint_id: bigint | number
    appoint_date?: Date | string | null
    appoint_time?: Date | string | null
    instance_status?: string | null
  }

  export type recurring_instancesCreateOrConnectWithoutRecurrenceInput = {
    where: recurring_instancesWhereUniqueInput
    create: XOR<recurring_instancesCreateWithoutRecurrenceInput, recurring_instancesUncheckedCreateWithoutRecurrenceInput>
  }

  export type recurring_instancesCreateManyRecurrenceInputEnvelope = {
    data: recurring_instancesCreateManyRecurrenceInput | recurring_instancesCreateManyRecurrenceInput[]
    skipDuplicates?: boolean
  }

  export type recurring_instancesUpsertWithWhereUniqueWithoutRecurrenceInput = {
    where: recurring_instancesWhereUniqueInput
    update: XOR<recurring_instancesUpdateWithoutRecurrenceInput, recurring_instancesUncheckedUpdateWithoutRecurrenceInput>
    create: XOR<recurring_instancesCreateWithoutRecurrenceInput, recurring_instancesUncheckedCreateWithoutRecurrenceInput>
  }

  export type recurring_instancesUpdateWithWhereUniqueWithoutRecurrenceInput = {
    where: recurring_instancesWhereUniqueInput
    data: XOR<recurring_instancesUpdateWithoutRecurrenceInput, recurring_instancesUncheckedUpdateWithoutRecurrenceInput>
  }

  export type recurring_instancesUpdateManyWithWhereWithoutRecurrenceInput = {
    where: recurring_instancesScalarWhereInput
    data: XOR<recurring_instancesUpdateManyMutationInput, recurring_instancesUncheckedUpdateManyWithoutRecurrenceInput>
  }

  export type appointmentsCreateWithoutRecurring_instancesInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    appointment_status?: appointment_statusCreateNestedOneWithoutAppointmentsInput
    clinic_staff?: clinic_staffCreateNestedOneWithoutAppointmentsInput
    users?: usersCreateNestedOneWithoutAppointmentsInput
    patient_appointments?: patient_appointmentsCreateNestedManyWithoutAppointmentsInput
    session?: sessionCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateWithoutRecurring_instancesInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    staff_id?: bigint | number | null
    appointment_status_id?: bigint | number | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    user_id?: bigint | number | null
    patient_appointments?: patient_appointmentsUncheckedCreateNestedManyWithoutAppointmentsInput
    session?: sessionUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsCreateOrConnectWithoutRecurring_instancesInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutRecurring_instancesInput, appointmentsUncheckedCreateWithoutRecurring_instancesInput>
  }

  export type recurrenceCreateWithoutRecurring_instancesInput = {
    recurrence_id?: bigint | number
    recurrence_type?: string | null
    interval?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    occurence_count?: bigint | number | null
    time?: Date | string | null
  }

  export type recurrenceUncheckedCreateWithoutRecurring_instancesInput = {
    recurrence_id?: bigint | number
    recurrence_type?: string | null
    interval?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    occurence_count?: bigint | number | null
    time?: Date | string | null
  }

  export type recurrenceCreateOrConnectWithoutRecurring_instancesInput = {
    where: recurrenceWhereUniqueInput
    create: XOR<recurrenceCreateWithoutRecurring_instancesInput, recurrenceUncheckedCreateWithoutRecurring_instancesInput>
  }

  export type appointmentsUpsertWithoutRecurring_instancesInput = {
    update: XOR<appointmentsUpdateWithoutRecurring_instancesInput, appointmentsUncheckedUpdateWithoutRecurring_instancesInput>
    create: XOR<appointmentsCreateWithoutRecurring_instancesInput, appointmentsUncheckedCreateWithoutRecurring_instancesInput>
    where?: appointmentsWhereInput
  }

  export type appointmentsUpdateToOneWithWhereWithoutRecurring_instancesInput = {
    where?: appointmentsWhereInput
    data: XOR<appointmentsUpdateWithoutRecurring_instancesInput, appointmentsUncheckedUpdateWithoutRecurring_instancesInput>
  }

  export type appointmentsUpdateWithoutRecurring_instancesInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointment_status?: appointment_statusUpdateOneWithoutAppointmentsNestedInput
    clinic_staff?: clinic_staffUpdateOneWithoutAppointmentsNestedInput
    users?: usersUpdateOneWithoutAppointmentsNestedInput
    patient_appointments?: patient_appointmentsUpdateManyWithoutAppointmentsNestedInput
    session?: sessionUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutRecurring_instancesInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staff_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    appointment_status_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    patient_appointments?: patient_appointmentsUncheckedUpdateManyWithoutAppointmentsNestedInput
    session?: sessionUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type recurrenceUpsertWithoutRecurring_instancesInput = {
    update: XOR<recurrenceUpdateWithoutRecurring_instancesInput, recurrenceUncheckedUpdateWithoutRecurring_instancesInput>
    create: XOR<recurrenceCreateWithoutRecurring_instancesInput, recurrenceUncheckedCreateWithoutRecurring_instancesInput>
    where?: recurrenceWhereInput
  }

  export type recurrenceUpdateToOneWithWhereWithoutRecurring_instancesInput = {
    where?: recurrenceWhereInput
    data: XOR<recurrenceUpdateWithoutRecurring_instancesInput, recurrenceUncheckedUpdateWithoutRecurring_instancesInput>
  }

  export type recurrenceUpdateWithoutRecurring_instancesInput = {
    recurrence_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recurrence_type?: NullableStringFieldUpdateOperationsInput | string | null
    interval?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occurence_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type recurrenceUncheckedUpdateWithoutRecurring_instancesInput = {
    recurrence_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recurrence_type?: NullableStringFieldUpdateOperationsInput | string | null
    interval?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    occurence_count?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type appointmentsCreateWithoutSessionInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    appointment_status?: appointment_statusCreateNestedOneWithoutAppointmentsInput
    clinic_staff?: clinic_staffCreateNestedOneWithoutAppointmentsInput
    users?: usersCreateNestedOneWithoutAppointmentsInput
    patient_appointments?: patient_appointmentsCreateNestedManyWithoutAppointmentsInput
    recurring_instances?: recurring_instancesCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateWithoutSessionInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    staff_id?: bigint | number | null
    appointment_status_id?: bigint | number | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    user_id?: bigint | number | null
    patient_appointments?: patient_appointmentsUncheckedCreateNestedManyWithoutAppointmentsInput
    recurring_instances?: recurring_instancesUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsCreateOrConnectWithoutSessionInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutSessionInput, appointmentsUncheckedCreateWithoutSessionInput>
  }

  export type patientsCreateWithoutSessionInput = {
    patient_id?: bigint | number
    patient_name?: string | null
    patient_appointments?: patient_appointmentsCreateNestedManyWithoutPatientsInput
    patient_details?: patient_detailsCreateNestedManyWithoutPatientsInput
    users: usersCreateNestedOneWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutSessionInput = {
    patient_id?: bigint | number
    patient_name?: string | null
    user_id: bigint | number
    patient_appointments?: patient_appointmentsUncheckedCreateNestedManyWithoutPatientsInput
    patient_details?: patient_detailsUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutSessionInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutSessionInput, patientsUncheckedCreateWithoutSessionInput>
  }

  export type clinic_staffCreateWithoutSessionInput = {
    staff_id?: bigint | number
    staff_name?: string | null
    staff_birthdate?: Date | string | null
    appointments?: appointmentsCreateNestedManyWithoutClinic_staffInput
    clinic_staff_details?: clinic_staff_detailsCreateNestedManyWithoutClinic_staffInput
    staff_role?: staff_roleCreateNestedManyWithoutClinic_staffInput
  }

  export type clinic_staffUncheckedCreateWithoutSessionInput = {
    staff_id?: bigint | number
    staff_name?: string | null
    staff_birthdate?: Date | string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutClinic_staffInput
    clinic_staff_details?: clinic_staff_detailsUncheckedCreateNestedManyWithoutClinic_staffInput
    staff_role?: staff_roleUncheckedCreateNestedManyWithoutClinic_staffInput
  }

  export type clinic_staffCreateOrConnectWithoutSessionInput = {
    where: clinic_staffWhereUniqueInput
    create: XOR<clinic_staffCreateWithoutSessionInput, clinic_staffUncheckedCreateWithoutSessionInput>
  }

  export type session_detailsCreateWithoutSessionInput = {
    session_details_id?: bigint | number
    session_description?: string | null
    session_date?: Date | string | null
    session_time?: Date | string | null
    session_document?: Uint8Array | null
  }

  export type session_detailsUncheckedCreateWithoutSessionInput = {
    session_details_id?: bigint | number
    session_description?: string | null
    session_date?: Date | string | null
    session_time?: Date | string | null
    session_document?: Uint8Array | null
  }

  export type session_detailsCreateOrConnectWithoutSessionInput = {
    where: session_detailsWhereUniqueInput
    create: XOR<session_detailsCreateWithoutSessionInput, session_detailsUncheckedCreateWithoutSessionInput>
  }

  export type session_detailsCreateManySessionInputEnvelope = {
    data: session_detailsCreateManySessionInput | session_detailsCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type appointmentsUpsertWithoutSessionInput = {
    update: XOR<appointmentsUpdateWithoutSessionInput, appointmentsUncheckedUpdateWithoutSessionInput>
    create: XOR<appointmentsCreateWithoutSessionInput, appointmentsUncheckedCreateWithoutSessionInput>
    where?: appointmentsWhereInput
  }

  export type appointmentsUpdateToOneWithWhereWithoutSessionInput = {
    where?: appointmentsWhereInput
    data: XOR<appointmentsUpdateWithoutSessionInput, appointmentsUncheckedUpdateWithoutSessionInput>
  }

  export type appointmentsUpdateWithoutSessionInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointment_status?: appointment_statusUpdateOneWithoutAppointmentsNestedInput
    clinic_staff?: clinic_staffUpdateOneWithoutAppointmentsNestedInput
    users?: usersUpdateOneWithoutAppointmentsNestedInput
    patient_appointments?: patient_appointmentsUpdateManyWithoutAppointmentsNestedInput
    recurring_instances?: recurring_instancesUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutSessionInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staff_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    appointment_status_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    patient_appointments?: patient_appointmentsUncheckedUpdateManyWithoutAppointmentsNestedInput
    recurring_instances?: recurring_instancesUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type patientsUpsertWithoutSessionInput = {
    update: XOR<patientsUpdateWithoutSessionInput, patientsUncheckedUpdateWithoutSessionInput>
    create: XOR<patientsCreateWithoutSessionInput, patientsUncheckedCreateWithoutSessionInput>
    where?: patientsWhereInput
  }

  export type patientsUpdateToOneWithWhereWithoutSessionInput = {
    where?: patientsWhereInput
    data: XOR<patientsUpdateWithoutSessionInput, patientsUncheckedUpdateWithoutSessionInput>
  }

  export type patientsUpdateWithoutSessionInput = {
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_name?: NullableStringFieldUpdateOperationsInput | string | null
    patient_appointments?: patient_appointmentsUpdateManyWithoutPatientsNestedInput
    patient_details?: patient_detailsUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneRequiredWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutSessionInput = {
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_appointments?: patient_appointmentsUncheckedUpdateManyWithoutPatientsNestedInput
    patient_details?: patient_detailsUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type clinic_staffUpsertWithoutSessionInput = {
    update: XOR<clinic_staffUpdateWithoutSessionInput, clinic_staffUncheckedUpdateWithoutSessionInput>
    create: XOR<clinic_staffCreateWithoutSessionInput, clinic_staffUncheckedCreateWithoutSessionInput>
    where?: clinic_staffWhereInput
  }

  export type clinic_staffUpdateToOneWithWhereWithoutSessionInput = {
    where?: clinic_staffWhereInput
    data: XOR<clinic_staffUpdateWithoutSessionInput, clinic_staffUncheckedUpdateWithoutSessionInput>
  }

  export type clinic_staffUpdateWithoutSessionInput = {
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_name?: NullableStringFieldUpdateOperationsInput | string | null
    staff_birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUpdateManyWithoutClinic_staffNestedInput
    clinic_staff_details?: clinic_staff_detailsUpdateManyWithoutClinic_staffNestedInput
    staff_role?: staff_roleUpdateManyWithoutClinic_staffNestedInput
  }

  export type clinic_staffUncheckedUpdateWithoutSessionInput = {
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_name?: NullableStringFieldUpdateOperationsInput | string | null
    staff_birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutClinic_staffNestedInput
    clinic_staff_details?: clinic_staff_detailsUncheckedUpdateManyWithoutClinic_staffNestedInput
    staff_role?: staff_roleUncheckedUpdateManyWithoutClinic_staffNestedInput
  }

  export type session_detailsUpsertWithWhereUniqueWithoutSessionInput = {
    where: session_detailsWhereUniqueInput
    update: XOR<session_detailsUpdateWithoutSessionInput, session_detailsUncheckedUpdateWithoutSessionInput>
    create: XOR<session_detailsCreateWithoutSessionInput, session_detailsUncheckedCreateWithoutSessionInput>
  }

  export type session_detailsUpdateWithWhereUniqueWithoutSessionInput = {
    where: session_detailsWhereUniqueInput
    data: XOR<session_detailsUpdateWithoutSessionInput, session_detailsUncheckedUpdateWithoutSessionInput>
  }

  export type session_detailsUpdateManyWithWhereWithoutSessionInput = {
    where: session_detailsScalarWhereInput
    data: XOR<session_detailsUpdateManyMutationInput, session_detailsUncheckedUpdateManyWithoutSessionInput>
  }

  export type session_detailsScalarWhereInput = {
    AND?: session_detailsScalarWhereInput | session_detailsScalarWhereInput[]
    OR?: session_detailsScalarWhereInput[]
    NOT?: session_detailsScalarWhereInput | session_detailsScalarWhereInput[]
    session_details_id?: BigIntFilter<"session_details"> | bigint | number
    session_id?: BigIntFilter<"session_details"> | bigint | number
    session_description?: StringNullableFilter<"session_details"> | string | null
    session_date?: DateTimeNullableFilter<"session_details"> | Date | string | null
    session_time?: DateTimeNullableFilter<"session_details"> | Date | string | null
    session_document?: BytesNullableFilter<"session_details"> | Uint8Array | null
  }

  export type sessionCreateWithoutSession_detailsInput = {
    session_id?: bigint | number
    appointments: appointmentsCreateNestedOneWithoutSessionInput
    patients: patientsCreateNestedOneWithoutSessionInput
    clinic_staff: clinic_staffCreateNestedOneWithoutSessionInput
  }

  export type sessionUncheckedCreateWithoutSession_detailsInput = {
    session_id?: bigint | number
    patient_id: bigint | number
    staff_id: bigint | number
    appoint_id: bigint | number
  }

  export type sessionCreateOrConnectWithoutSession_detailsInput = {
    where: sessionWhereUniqueInput
    create: XOR<sessionCreateWithoutSession_detailsInput, sessionUncheckedCreateWithoutSession_detailsInput>
  }

  export type sessionUpsertWithoutSession_detailsInput = {
    update: XOR<sessionUpdateWithoutSession_detailsInput, sessionUncheckedUpdateWithoutSession_detailsInput>
    create: XOR<sessionCreateWithoutSession_detailsInput, sessionUncheckedCreateWithoutSession_detailsInput>
    where?: sessionWhereInput
  }

  export type sessionUpdateToOneWithWhereWithoutSession_detailsInput = {
    where?: sessionWhereInput
    data: XOR<sessionUpdateWithoutSession_detailsInput, sessionUncheckedUpdateWithoutSession_detailsInput>
  }

  export type sessionUpdateWithoutSession_detailsInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appointments?: appointmentsUpdateOneRequiredWithoutSessionNestedInput
    patients?: patientsUpdateOneRequiredWithoutSessionNestedInput
    clinic_staff?: clinic_staffUpdateOneRequiredWithoutSessionNestedInput
  }

  export type sessionUncheckedUpdateWithoutSession_detailsInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type clinic_staffCreateWithoutStaff_roleInput = {
    staff_id?: bigint | number
    staff_name?: string | null
    staff_birthdate?: Date | string | null
    appointments?: appointmentsCreateNestedManyWithoutClinic_staffInput
    clinic_staff_details?: clinic_staff_detailsCreateNestedManyWithoutClinic_staffInput
    session?: sessionCreateNestedManyWithoutClinic_staffInput
  }

  export type clinic_staffUncheckedCreateWithoutStaff_roleInput = {
    staff_id?: bigint | number
    staff_name?: string | null
    staff_birthdate?: Date | string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutClinic_staffInput
    clinic_staff_details?: clinic_staff_detailsUncheckedCreateNestedManyWithoutClinic_staffInput
    session?: sessionUncheckedCreateNestedManyWithoutClinic_staffInput
  }

  export type clinic_staffCreateOrConnectWithoutStaff_roleInput = {
    where: clinic_staffWhereUniqueInput
    create: XOR<clinic_staffCreateWithoutStaff_roleInput, clinic_staffUncheckedCreateWithoutStaff_roleInput>
  }

  export type clinic_staffUpsertWithoutStaff_roleInput = {
    update: XOR<clinic_staffUpdateWithoutStaff_roleInput, clinic_staffUncheckedUpdateWithoutStaff_roleInput>
    create: XOR<clinic_staffCreateWithoutStaff_roleInput, clinic_staffUncheckedCreateWithoutStaff_roleInput>
    where?: clinic_staffWhereInput
  }

  export type clinic_staffUpdateToOneWithWhereWithoutStaff_roleInput = {
    where?: clinic_staffWhereInput
    data: XOR<clinic_staffUpdateWithoutStaff_roleInput, clinic_staffUncheckedUpdateWithoutStaff_roleInput>
  }

  export type clinic_staffUpdateWithoutStaff_roleInput = {
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_name?: NullableStringFieldUpdateOperationsInput | string | null
    staff_birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUpdateManyWithoutClinic_staffNestedInput
    clinic_staff_details?: clinic_staff_detailsUpdateManyWithoutClinic_staffNestedInput
    session?: sessionUpdateManyWithoutClinic_staffNestedInput
  }

  export type clinic_staffUncheckedUpdateWithoutStaff_roleInput = {
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_name?: NullableStringFieldUpdateOperationsInput | string | null
    staff_birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutClinic_staffNestedInput
    clinic_staff_details?: clinic_staff_detailsUncheckedUpdateManyWithoutClinic_staffNestedInput
    session?: sessionUncheckedUpdateManyWithoutClinic_staffNestedInput
  }

  export type usersCreateWithoutUser_contactsInput = {
    user_id?: bigint | number
    user_full_name?: string | null
    user_password?: string | null
    username?: string | null
    appointments?: appointmentsCreateNestedManyWithoutUsersInput
    patients?: patientsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_contactsInput = {
    user_id?: bigint | number
    user_full_name?: string | null
    user_password?: string | null
    username?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutUsersInput
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_contactsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_contactsInput, usersUncheckedCreateWithoutUser_contactsInput>
  }

  export type usersUpsertWithoutUser_contactsInput = {
    update: XOR<usersUpdateWithoutUser_contactsInput, usersUncheckedUpdateWithoutUser_contactsInput>
    create: XOR<usersCreateWithoutUser_contactsInput, usersUncheckedCreateWithoutUser_contactsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_contactsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_contactsInput, usersUncheckedUpdateWithoutUser_contactsInput>
  }

  export type usersUpdateWithoutUser_contactsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_full_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutUsersNestedInput
    patients?: patientsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_contactsInput = {
    user_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_full_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutUsersNestedInput
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type appointmentsCreateWithoutUsersInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    appointment_status?: appointment_statusCreateNestedOneWithoutAppointmentsInput
    clinic_staff?: clinic_staffCreateNestedOneWithoutAppointmentsInput
    patient_appointments?: patient_appointmentsCreateNestedManyWithoutAppointmentsInput
    recurring_instances?: recurring_instancesCreateNestedManyWithoutAppointmentsInput
    session?: sessionCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateWithoutUsersInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    staff_id?: bigint | number | null
    appointment_status_id?: bigint | number | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    patient_appointments?: patient_appointmentsUncheckedCreateNestedManyWithoutAppointmentsInput
    recurring_instances?: recurring_instancesUncheckedCreateNestedManyWithoutAppointmentsInput
    session?: sessionUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsCreateOrConnectWithoutUsersInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutUsersInput, appointmentsUncheckedCreateWithoutUsersInput>
  }

  export type appointmentsCreateManyUsersInputEnvelope = {
    data: appointmentsCreateManyUsersInput | appointmentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type patientsCreateWithoutUsersInput = {
    patient_id?: bigint | number
    patient_name?: string | null
    patient_appointments?: patient_appointmentsCreateNestedManyWithoutPatientsInput
    patient_details?: patient_detailsCreateNestedManyWithoutPatientsInput
    session?: sessionCreateNestedManyWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutUsersInput = {
    patient_id?: bigint | number
    patient_name?: string | null
    patient_appointments?: patient_appointmentsUncheckedCreateNestedManyWithoutPatientsInput
    patient_details?: patient_detailsUncheckedCreateNestedManyWithoutPatientsInput
    session?: sessionUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutUsersInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput>
  }

  export type patientsCreateManyUsersInputEnvelope = {
    data: patientsCreateManyUsersInput | patientsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_contactsCreateWithoutUsersInput = {
    user_contact_id?: bigint | number
    user_email?: string | null
    user_contact_number?: string | null
  }

  export type user_contactsUncheckedCreateWithoutUsersInput = {
    user_contact_id?: bigint | number
    user_email?: string | null
    user_contact_number?: string | null
  }

  export type user_contactsCreateOrConnectWithoutUsersInput = {
    where: user_contactsWhereUniqueInput
    create: XOR<user_contactsCreateWithoutUsersInput, user_contactsUncheckedCreateWithoutUsersInput>
  }

  export type user_contactsCreateManyUsersInputEnvelope = {
    data: user_contactsCreateManyUsersInput | user_contactsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type appointmentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: appointmentsWhereUniqueInput
    update: XOR<appointmentsUpdateWithoutUsersInput, appointmentsUncheckedUpdateWithoutUsersInput>
    create: XOR<appointmentsCreateWithoutUsersInput, appointmentsUncheckedCreateWithoutUsersInput>
  }

  export type appointmentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: appointmentsWhereUniqueInput
    data: XOR<appointmentsUpdateWithoutUsersInput, appointmentsUncheckedUpdateWithoutUsersInput>
  }

  export type appointmentsUpdateManyWithWhereWithoutUsersInput = {
    where: appointmentsScalarWhereInput
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type patientsUpsertWithWhereUniqueWithoutUsersInput = {
    where: patientsWhereUniqueInput
    update: XOR<patientsUpdateWithoutUsersInput, patientsUncheckedUpdateWithoutUsersInput>
    create: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput>
  }

  export type patientsUpdateWithWhereUniqueWithoutUsersInput = {
    where: patientsWhereUniqueInput
    data: XOR<patientsUpdateWithoutUsersInput, patientsUncheckedUpdateWithoutUsersInput>
  }

  export type patientsUpdateManyWithWhereWithoutUsersInput = {
    where: patientsScalarWhereInput
    data: XOR<patientsUpdateManyMutationInput, patientsUncheckedUpdateManyWithoutUsersInput>
  }

  export type patientsScalarWhereInput = {
    AND?: patientsScalarWhereInput | patientsScalarWhereInput[]
    OR?: patientsScalarWhereInput[]
    NOT?: patientsScalarWhereInput | patientsScalarWhereInput[]
    patient_id?: BigIntFilter<"patients"> | bigint | number
    patient_name?: StringNullableFilter<"patients"> | string | null
    user_id?: BigIntFilter<"patients"> | bigint | number
  }

  export type user_contactsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_contactsWhereUniqueInput
    update: XOR<user_contactsUpdateWithoutUsersInput, user_contactsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_contactsCreateWithoutUsersInput, user_contactsUncheckedCreateWithoutUsersInput>
  }

  export type user_contactsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_contactsWhereUniqueInput
    data: XOR<user_contactsUpdateWithoutUsersInput, user_contactsUncheckedUpdateWithoutUsersInput>
  }

  export type user_contactsUpdateManyWithWhereWithoutUsersInput = {
    where: user_contactsScalarWhereInput
    data: XOR<user_contactsUpdateManyMutationInput, user_contactsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_contactsScalarWhereInput = {
    AND?: user_contactsScalarWhereInput | user_contactsScalarWhereInput[]
    OR?: user_contactsScalarWhereInput[]
    NOT?: user_contactsScalarWhereInput | user_contactsScalarWhereInput[]
    user_contact_id?: BigIntFilter<"user_contacts"> | bigint | number
    user_id?: BigIntFilter<"user_contacts"> | bigint | number
    user_email?: StringNullableFilter<"user_contacts"> | string | null
    user_contact_number?: StringNullableFilter<"user_contacts"> | string | null
  }

  export type appointmentsCreateManyAppointment_statusInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    staff_id?: bigint | number | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    user_id?: bigint | number | null
  }

  export type appointmentsUpdateWithoutAppointment_statusInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clinic_staff?: clinic_staffUpdateOneWithoutAppointmentsNestedInput
    users?: usersUpdateOneWithoutAppointmentsNestedInput
    patient_appointments?: patient_appointmentsUpdateManyWithoutAppointmentsNestedInput
    recurring_instances?: recurring_instancesUpdateManyWithoutAppointmentsNestedInput
    session?: sessionUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutAppointment_statusInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staff_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    patient_appointments?: patient_appointmentsUncheckedUpdateManyWithoutAppointmentsNestedInput
    recurring_instances?: recurring_instancesUncheckedUpdateManyWithoutAppointmentsNestedInput
    session?: sessionUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateManyWithoutAppointment_statusInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staff_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type patient_appointmentsCreateManyAppointmentsInput = {
    patient_appointments_id?: bigint | number
    patient_id: bigint | number
    booking_date?: Date | string | null
  }

  export type recurring_instancesCreateManyAppointmentsInput = {
    instance_id?: bigint | number
    recurrence_id: bigint | number
    appoint_date?: Date | string | null
    appoint_time?: Date | string | null
    instance_status?: string | null
  }

  export type sessionCreateManyAppointmentsInput = {
    session_id?: bigint | number
    patient_id: bigint | number
    staff_id: bigint | number
  }

  export type patient_appointmentsUpdateWithoutAppointmentsInput = {
    patient_appointments_id?: BigIntFieldUpdateOperationsInput | bigint | number
    booking_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patients?: patientsUpdateOneRequiredWithoutPatient_appointmentsNestedInput
  }

  export type patient_appointmentsUncheckedUpdateWithoutAppointmentsInput = {
    patient_appointments_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    booking_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_appointmentsUncheckedUpdateManyWithoutAppointmentsInput = {
    patient_appointments_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    booking_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type recurring_instancesUpdateWithoutAppointmentsInput = {
    instance_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appoint_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance_status?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: recurrenceUpdateOneRequiredWithoutRecurring_instancesNestedInput
  }

  export type recurring_instancesUncheckedUpdateWithoutAppointmentsInput = {
    instance_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recurrence_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appoint_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recurring_instancesUncheckedUpdateManyWithoutAppointmentsInput = {
    instance_id?: BigIntFieldUpdateOperationsInput | bigint | number
    recurrence_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appoint_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionUpdateWithoutAppointmentsInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patients?: patientsUpdateOneRequiredWithoutSessionNestedInput
    clinic_staff?: clinic_staffUpdateOneRequiredWithoutSessionNestedInput
    session_details?: session_detailsUpdateManyWithoutSessionNestedInput
  }

  export type sessionUncheckedUpdateWithoutAppointmentsInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    session_details?: session_detailsUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type sessionUncheckedUpdateManyWithoutAppointmentsInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type appointmentsCreateManyClinic_staffInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    appointment_status_id?: bigint | number | null
    final_date?: Date | string | null
    final_time?: Date | string | null
    user_id?: bigint | number | null
  }

  export type clinic_staff_detailsCreateManyClinic_staffInput = {
    clinic_staff_contact_id?: bigint | number
    staff_contact?: string | null
    staff_address?: string | null
  }

  export type sessionCreateManyClinic_staffInput = {
    session_id?: bigint | number
    patient_id: bigint | number
    appoint_id: bigint | number
  }

  export type staff_roleCreateManyClinic_staffInput = {
    staff_role_id?: bigint | number
    staff_role?: string | null
  }

  export type appointmentsUpdateWithoutClinic_staffInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointment_status?: appointment_statusUpdateOneWithoutAppointmentsNestedInput
    users?: usersUpdateOneWithoutAppointmentsNestedInput
    patient_appointments?: patient_appointmentsUpdateManyWithoutAppointmentsNestedInput
    recurring_instances?: recurring_instancesUpdateManyWithoutAppointmentsNestedInput
    session?: sessionUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutClinic_staffInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointment_status_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    patient_appointments?: patient_appointmentsUncheckedUpdateManyWithoutAppointmentsNestedInput
    recurring_instances?: recurring_instancesUncheckedUpdateManyWithoutAppointmentsNestedInput
    session?: sessionUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateManyWithoutClinic_staffInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointment_status_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type clinic_staff_detailsUpdateWithoutClinic_staffInput = {
    clinic_staff_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_contact?: NullableStringFieldUpdateOperationsInput | string | null
    staff_address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinic_staff_detailsUncheckedUpdateWithoutClinic_staffInput = {
    clinic_staff_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_contact?: NullableStringFieldUpdateOperationsInput | string | null
    staff_address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinic_staff_detailsUncheckedUpdateManyWithoutClinic_staffInput = {
    clinic_staff_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_contact?: NullableStringFieldUpdateOperationsInput | string | null
    staff_address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionUpdateWithoutClinic_staffInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appointments?: appointmentsUpdateOneRequiredWithoutSessionNestedInput
    patients?: patientsUpdateOneRequiredWithoutSessionNestedInput
    session_details?: session_detailsUpdateManyWithoutSessionNestedInput
  }

  export type sessionUncheckedUpdateWithoutClinic_staffInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    session_details?: session_detailsUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type sessionUncheckedUpdateManyWithoutClinic_staffInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type staff_roleUpdateWithoutClinic_staffInput = {
    staff_role_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staff_roleUncheckedUpdateWithoutClinic_staffInput = {
    staff_role_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type staff_roleUncheckedUpdateManyWithoutClinic_staffInput = {
    staff_role_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type patient_appointmentsCreateManyPatientsInput = {
    patient_appointments_id?: bigint | number
    appoint_id: bigint | number
    booking_date?: Date | string | null
  }

  export type patient_detailsCreateManyPatientsInput = {
    patient_details_id?: bigint | number
    patient_conditions_id: bigint | number
    patient_birth_date?: Date | string | null
  }

  export type sessionCreateManyPatientsInput = {
    session_id?: bigint | number
    staff_id: bigint | number
    appoint_id: bigint | number
  }

  export type patient_appointmentsUpdateWithoutPatientsInput = {
    patient_appointments_id?: BigIntFieldUpdateOperationsInput | bigint | number
    booking_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUpdateOneRequiredWithoutPatient_appointmentsNestedInput
  }

  export type patient_appointmentsUncheckedUpdateWithoutPatientsInput = {
    patient_appointments_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    booking_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_appointmentsUncheckedUpdateManyWithoutPatientsInput = {
    patient_appointments_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    booking_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_detailsUpdateWithoutPatientsInput = {
    patient_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_conditions_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_detailsUncheckedUpdateWithoutPatientsInput = {
    patient_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_conditions_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_detailsUncheckedUpdateManyWithoutPatientsInput = {
    patient_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_conditions_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionUpdateWithoutPatientsInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appointments?: appointmentsUpdateOneRequiredWithoutSessionNestedInput
    clinic_staff?: clinic_staffUpdateOneRequiredWithoutSessionNestedInput
    session_details?: session_detailsUpdateManyWithoutSessionNestedInput
  }

  export type sessionUncheckedUpdateWithoutPatientsInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    session_details?: session_detailsUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type sessionUncheckedUpdateManyWithoutPatientsInput = {
    session_id?: BigIntFieldUpdateOperationsInput | bigint | number
    staff_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type recurring_instancesCreateManyRecurrenceInput = {
    instance_id?: bigint | number
    appoint_id: bigint | number
    appoint_date?: Date | string | null
    appoint_time?: Date | string | null
    instance_status?: string | null
  }

  export type recurring_instancesUpdateWithoutRecurrenceInput = {
    instance_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appoint_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance_status?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateOneRequiredWithoutRecurring_instancesNestedInput
  }

  export type recurring_instancesUncheckedUpdateWithoutRecurrenceInput = {
    instance_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appoint_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recurring_instancesUncheckedUpdateManyWithoutRecurrenceInput = {
    instance_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    appoint_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appoint_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instance_status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type session_detailsCreateManySessionInput = {
    session_details_id?: bigint | number
    session_description?: string | null
    session_date?: Date | string | null
    session_time?: Date | string | null
    session_document?: Uint8Array | null
  }

  export type session_detailsUpdateWithoutSessionInput = {
    session_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    session_description?: NullableStringFieldUpdateOperationsInput | string | null
    session_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_document?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type session_detailsUncheckedUpdateWithoutSessionInput = {
    session_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    session_description?: NullableStringFieldUpdateOperationsInput | string | null
    session_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_document?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type session_detailsUncheckedUpdateManyWithoutSessionInput = {
    session_details_id?: BigIntFieldUpdateOperationsInput | bigint | number
    session_description?: NullableStringFieldUpdateOperationsInput | string | null
    session_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    session_document?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type appointmentsCreateManyUsersInput = {
    appoint_id?: bigint | number
    preferred_time?: Date | string | null
    preferred_date?: Date | string | null
    staff_id?: bigint | number | null
    appointment_status_id?: bigint | number | null
    final_date?: Date | string | null
    final_time?: Date | string | null
  }

  export type patientsCreateManyUsersInput = {
    patient_id?: bigint | number
    patient_name?: string | null
  }

  export type user_contactsCreateManyUsersInput = {
    user_contact_id?: bigint | number
    user_email?: string | null
    user_contact_number?: string | null
  }

  export type appointmentsUpdateWithoutUsersInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointment_status?: appointment_statusUpdateOneWithoutAppointmentsNestedInput
    clinic_staff?: clinic_staffUpdateOneWithoutAppointmentsNestedInput
    patient_appointments?: patient_appointmentsUpdateManyWithoutAppointmentsNestedInput
    recurring_instances?: recurring_instancesUpdateManyWithoutAppointmentsNestedInput
    session?: sessionUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutUsersInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staff_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    appointment_status_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient_appointments?: patient_appointmentsUncheckedUpdateManyWithoutAppointmentsNestedInput
    recurring_instances?: recurring_instancesUncheckedUpdateManyWithoutAppointmentsNestedInput
    session?: sessionUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateManyWithoutUsersInput = {
    appoint_id?: BigIntFieldUpdateOperationsInput | bigint | number
    preferred_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferred_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    staff_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    appointment_status_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    final_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patientsUpdateWithoutUsersInput = {
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_name?: NullableStringFieldUpdateOperationsInput | string | null
    patient_appointments?: patient_appointmentsUpdateManyWithoutPatientsNestedInput
    patient_details?: patient_detailsUpdateManyWithoutPatientsNestedInput
    session?: sessionUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutUsersInput = {
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_name?: NullableStringFieldUpdateOperationsInput | string | null
    patient_appointments?: patient_appointmentsUncheckedUpdateManyWithoutPatientsNestedInput
    patient_details?: patient_detailsUncheckedUpdateManyWithoutPatientsNestedInput
    session?: sessionUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateManyWithoutUsersInput = {
    patient_id?: BigIntFieldUpdateOperationsInput | bigint | number
    patient_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_contactsUpdateWithoutUsersInput = {
    user_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_contact_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_contactsUncheckedUpdateWithoutUsersInput = {
    user_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_contact_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_contactsUncheckedUpdateManyWithoutUsersInput = {
    user_contact_id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_contact_number?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}